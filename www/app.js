/******/
(function (modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/
	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/
	function __webpack_require__(moduleId) {
		/******/
		/******/ 		// Check if module is in cache
		/******/
		if (installedModules[moduleId]) {
			/******/
			return installedModules[moduleId].exports;
			/******/
		}
		/******/ 		// Create a new module (and put it into the cache)
		/******/
		var module = installedModules[moduleId] = {
			/******/            i: moduleId,
			/******/            l: false,
			/******/            exports: {}
			/******/
		};
		/******/
		/******/ 		// Execute the module function
		/******/
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ 		// Flag the module as loaded
		/******/
		module.l = true;
		/******/
		/******/ 		// Return the exports of the module
		/******/
		return module.exports;
		/******/
	}

	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/
	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/
	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/
	__webpack_require__.d = function (exports, name, getter) {
		/******/
		if (!__webpack_require__.o(exports, name)) {
			/******/
			Object.defineProperty(exports, name, {enumerable: true, get: getter});
			/******/
		}
		/******/
	};
	/******/
	/******/ 	// define __esModule on exports
	/******/
	__webpack_require__.r = function (exports) {
		/******/
		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
			/******/
			Object.defineProperty(exports, Symbol.toStringTag, {value: 'Module'});
			/******/
		}
		/******/
		Object.defineProperty(exports, '__esModule', {value: true});
		/******/
	};
	/******/
	/******/ 	// create a fake namespace object
	/******/ 	// mode & 1: value is a module id, require it
	/******/ 	// mode & 2: merge all properties of value into the ns
	/******/ 	// mode & 4: return value when already ns object
	/******/ 	// mode & 8|1: behave like require
	/******/
	__webpack_require__.t = function (value, mode) {
		/******/
		if (mode & 1) value = __webpack_require__(value);
		/******/
		if (mode & 8) return value;
		/******/
		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
		/******/
		var ns = Object.create(null);
		/******/
		__webpack_require__.r(ns);
		/******/
		Object.defineProperty(ns, 'default', {enumerable: true, value: value});
		/******/
		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
			return value[key];
		}.bind(null, key));
		/******/
		return ns;
		/******/
	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/
	__webpack_require__.n = function (module) {
		/******/
		var getter = module && module.__esModule ?
			/******/            function getDefault() {
				return module['default'];
			} :
			/******/            function getModuleExports() {
				return module;
			};
		/******/
		__webpack_require__.d(getter, 'a', getter);
		/******/
		return getter;
		/******/
	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/
	__webpack_require__.o = function (object, property) {
		return Object.prototype.hasOwnProperty.call(object, property);
	};
	/******/
	/******/ 	// __webpack_public_path__
	/******/
	__webpack_require__.p = "";
	/******/
	/******/
	/******/ 	// Load entry module and return exports
	/******/
	return __webpack_require__(__webpack_require__.s = 5);
	/******/
})
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (module) {
			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

			function _typeof(obj) {
				"@babel/helpers - typeof";
				if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
					_typeof = function _typeof(obj) {
						return typeof obj;
					};
				} else {
					_typeof = function _typeof(obj) {
						return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
					};
				}
				return _typeof(obj);
			}

			/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
			(function (global, factory) {
				"use strict";

				if ((false ? undefined : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
					// For CommonJS and CommonJS-like environments where a proper `window`
					// is present, execute the factory and get jQuery.
					// For environments that do not have a `window` with a `document`
					// (such as Node.js), expose a factory as module.exports.
					// This accentuates the need for the creation of a real `window`.
					// e.g. var jQuery = require("jquery")(window);
					// See ticket #14549 for more info.
					module.exports = global.document ? factory(global, true) : function (w) {
						if (!w.document) {
							throw new Error("jQuery requires a window with a document");
						}

						return factory(w);
					};
				} else {
					factory(global);
				} // Pass this if window is not defined yet

			})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
				// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
				// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
				// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
				// enough that all such attempts are guarded in a try block.
				"use strict";

				var arr = [];
				var getProto = Object.getPrototypeOf;
				var _slice = arr.slice;
				var flat = arr.flat ? function (array) {
					return arr.flat.call(array);
				} : function (array) {
					return arr.concat.apply([], array);
				};
				var push = arr.push;
				var indexOf = arr.indexOf;
				var class2type = {};
				var toString = class2type.toString;
				var hasOwn = class2type.hasOwnProperty;
				var fnToString = hasOwn.toString;
				var ObjectFunctionString = fnToString.call(Object);
				var support = {};

				var isFunction = function isFunction(obj) {
					// Support: Chrome <=57, Firefox <=52
					// In some browsers, typeof returns "function" for HTML <object> elements
					// (i.e., `typeof document.createElement( "object" ) === "function"`).
					// We don't want to classify *any* DOM node as a function.
					return typeof obj === "function" && typeof obj.nodeType !== "number";
				};

				var isWindow = function isWindow(obj) {
					return obj != null && obj === obj.window;
				};

				var document = window.document;
				var preservedScriptAttributes = {
					type: true,
					src: true,
					nonce: true,
					noModule: true
				};

				function DOMEval(code, node, doc) {
					doc = doc || document;
					var i,
						val,
						script = doc.createElement("script");
					script.text = code;

					if (node) {
						for (i in preservedScriptAttributes) {
							// Support: Firefox 64+, Edge 18+
							// Some browsers don't support the "nonce" property on scripts.
							// On the other hand, just using `getAttribute` is not enough as
							// the `nonce` attribute is reset to an empty string whenever it
							// becomes browsing-context connected.
							// See https://github.com/whatwg/html/issues/2369
							// See https://html.spec.whatwg.org/#nonce-attributes
							// The `node.getAttribute` check was added for the sake of
							// `jQuery.globalEval` so that it can fake a nonce-containing node
							// via an object.
							val = node[i] || node.getAttribute && node.getAttribute(i);

							if (val) {
								script.setAttribute(i, val);
							}
						}
					}

					doc.head.appendChild(script).parentNode.removeChild(script);
				}

				function toType(obj) {
					if (obj == null) {
						return obj + "";
					} // Support: Android <=2.3 only (functionish RegExp)


					return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
				}

				/* global Symbol */
				// Defining this global in .eslintrc.json would create a danger of using the global
				// unguarded in another place, it seems safer to define global only for this module


				var version = "3.5.1",
					// Define a local copy of jQuery
					jQuery = function jQuery(selector, context) {
						// The jQuery object is actually just the init constructor 'enhanced'
						// Need init if jQuery is called (just allow error to be thrown if not included)
						return new jQuery.fn.init(selector, context);
					};

				jQuery.fn = jQuery.prototype = {
					// The current version of jQuery being used
					jquery: version,
					constructor: jQuery,
					// The default length of a jQuery object is 0
					length: 0,
					toArray: function toArray() {
						return _slice.call(this);
					},
					// Get the Nth element in the matched element set OR
					// Get the whole matched element set as a clean array
					get: function get(num) {
						// Return all the elements in a clean array
						if (num == null) {
							return _slice.call(this);
						} // Return just the one element from the set


						return num < 0 ? this[num + this.length] : this[num];
					},
					// Take an array of elements and push it onto the stack
					// (returning the new matched element set)
					pushStack: function pushStack(elems) {
						// Build a new jQuery matched element set
						var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

						ret.prevObject = this; // Return the newly-formed element set

						return ret;
					},
					// Execute a callback for every element in the matched set.
					each: function each(callback) {
						return jQuery.each(this, callback);
					},
					map: function map(callback) {
						return this.pushStack(jQuery.map(this, function (elem, i) {
							return callback.call(elem, i, elem);
						}));
					},
					slice: function slice() {
						return this.pushStack(_slice.apply(this, arguments));
					},
					first: function first() {
						return this.eq(0);
					},
					last: function last() {
						return this.eq(-1);
					},
					even: function even() {
						return this.pushStack(jQuery.grep(this, function (_elem, i) {
							return (i + 1) % 2;
						}));
					},
					odd: function odd() {
						return this.pushStack(jQuery.grep(this, function (_elem, i) {
							return i % 2;
						}));
					},
					eq: function eq(i) {
						var len = this.length,
							j = +i + (i < 0 ? len : 0);
						return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
					},
					end: function end() {
						return this.prevObject || this.constructor();
					},
					// For internal use only.
					// Behaves like an Array's method, not like a jQuery method.
					push: push,
					sort: arr.sort,
					splice: arr.splice
				};

				jQuery.extend = jQuery.fn.extend = function () {
					var options,
						name,
						src,
						copy,
						copyIsArray,
						clone,
						target = arguments[0] || {},
						i = 1,
						length = arguments.length,
						deep = false; // Handle a deep copy situation

					if (typeof target === "boolean") {
						deep = target; // Skip the boolean and the target

						target = arguments[i] || {};
						i++;
					} // Handle case when target is a string or something (possible in deep copy)


					if (_typeof(target) !== "object" && !isFunction(target)) {
						target = {};
					} // Extend jQuery itself if only one argument is passed


					if (i === length) {
						target = this;
						i--;
					}

					for (; i < length; i++) {
						// Only deal with non-null/undefined values
						if ((options = arguments[i]) != null) {
							// Extend the base object
							for (name in options) {
								copy = options[name]; // Prevent Object.prototype pollution
								// Prevent never-ending loop

								if (name === "__proto__" || target === copy) {
									continue;
								} // Recurse if we're merging plain objects or arrays


								if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
									src = target[name]; // Ensure proper type for the source value

									if (copyIsArray && !Array.isArray(src)) {
										clone = [];
									} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
										clone = {};
									} else {
										clone = src;
									}

									copyIsArray = false; // Never move original objects, clone them

									target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
								} else if (copy !== undefined) {
									target[name] = copy;
								}
							}
						}
					} // Return the modified object


					return target;
				};

				jQuery.extend({
					// Unique for each copy of jQuery on the page
					expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
					// Assume jQuery is ready without the ready module
					isReady: true,
					error: function error(msg) {
						throw new Error(msg);
					},
					noop: function noop() {
					},
					isPlainObject: function isPlainObject(obj) {
						var proto, Ctor; // Detect obvious negatives
						// Use toString instead of jQuery.type to catch host objects

						if (!obj || toString.call(obj) !== "[object Object]") {
							return false;
						}

						proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

						if (!proto) {
							return true;
						} // Objects with prototype are plain iff they were constructed by a global Object function


						Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
						return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
					},
					isEmptyObject: function isEmptyObject(obj) {
						var name;

						for (name in obj) {
							return false;
						}

						return true;
					},
					// Evaluates a script in a provided context; falls back to the global one
					// if not specified.
					globalEval: function globalEval(code, options, doc) {
						DOMEval(code, {
							nonce: options && options.nonce
						}, doc);
					},
					each: function each(obj, callback) {
						var length,
							i = 0;

						if (isArrayLike(obj)) {
							length = obj.length;

							for (; i < length; i++) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						} else {
							for (i in obj) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						}

						return obj;
					},
					// results is for internal usage only
					makeArray: function makeArray(arr, results) {
						var ret = results || [];

						if (arr != null) {
							if (isArrayLike(Object(arr))) {
								jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
							} else {
								push.call(ret, arr);
							}
						}

						return ret;
					},
					inArray: function inArray(elem, arr, i) {
						return arr == null ? -1 : indexOf.call(arr, elem, i);
					},
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					merge: function merge(first, second) {
						var len = +second.length,
							j = 0,
							i = first.length;

						for (; j < len; j++) {
							first[i++] = second[j];
						}

						first.length = i;
						return first;
					},
					grep: function grep(elems, callback, invert) {
						var callbackInverse,
							matches = [],
							i = 0,
							length = elems.length,
							callbackExpect = !invert; // Go through the array, only saving the items
						// that pass the validator function

						for (; i < length; i++) {
							callbackInverse = !callback(elems[i], i);

							if (callbackInverse !== callbackExpect) {
								matches.push(elems[i]);
							}
						}

						return matches;
					},
					// arg is for internal usage only
					map: function map(elems, callback, arg) {
						var length,
							value,
							i = 0,
							ret = []; // Go through the array, translating each of the items to their new values

						if (isArrayLike(elems)) {
							length = elems.length;

							for (; i < length; i++) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret.push(value);
								}
							} // Go through every key on the object,

						} else {
							for (i in elems) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret.push(value);
								}
							}
						} // Flatten any nested arrays


						return flat(ret);
					},
					// A global GUID counter for objects
					guid: 1,
					// jQuery.support is not used in Core but other projects attach their
					// properties to it so it needs to exist.
					support: support
				});

				if (typeof Symbol === "function") {
					jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
				} // Populate the class2type map


				jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
					class2type["[object " + name + "]"] = name.toLowerCase();
				});

				function isArrayLike(obj) {
					// Support: real iOS 8.2 only (not reproducible in simulator)
					// `in` check used to prevent JIT error (gh-2145)
					// hasOwn isn't used here due to false negatives
					// regarding Nodelist length in IE
					var length = !!obj && "length" in obj && obj.length,
						type = toType(obj);

					if (isFunction(obj) || isWindow(obj)) {
						return false;
					}

					return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
				}

				var Sizzle =
					/*!
   * Sizzle CSS Selector Engine v2.3.5
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2020-03-14
   */
					function (window) {
						var i,
							support,
							Expr,
							getText,
							isXML,
							tokenize,
							compile,
							select,
							outermostContext,
							sortInput,
							hasDuplicate,
							// Local document vars
							setDocument,
							document,
							docElem,
							documentIsHTML,
							rbuggyQSA,
							rbuggyMatches,
							matches,
							contains,
							// Instance-specific data
							expando = "sizzle" + 1 * new Date(),
							preferredDoc = window.document,
							dirruns = 0,
							done = 0,
							classCache = createCache(),
							tokenCache = createCache(),
							compilerCache = createCache(),
							nonnativeSelectorCache = createCache(),
							sortOrder = function sortOrder(a, b) {
								if (a === b) {
									hasDuplicate = true;
								}

								return 0;
							},
							// Instance methods
							hasOwn = {}.hasOwnProperty,
							arr = [],
							pop = arr.pop,
							pushNative = arr.push,
							push = arr.push,
							slice = arr.slice,
							// Use a stripped-down indexOf as it's faster than native
							// https://jsperf.com/thor-indexof-vs-for/5
							indexOf = function indexOf(list, elem) {
								var i = 0,
									len = list.length;

								for (; i < len; i++) {
									if (list[i] === elem) {
										return i;
									}
								}

								return -1;
							},
							booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
							// Regular expressions
							// http://www.w3.org/TR/css3-selectors/#whitespace
							whitespace = "[\\x20\\t\\r\\n\\f]",
							// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
							identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
							// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
							attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
								"*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
								// or strings [capture 3 or capture 4]"
								"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
							pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
								// 1. quoted (capture 3; capture 4 or capture 5)
								"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
								"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
								".*" + ")\\)|)",
							// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
							rwhitespace = new RegExp(whitespace + "+", "g"),
							rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
							rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
							rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
							rdescend = new RegExp(whitespace + "|>"),
							rpseudo = new RegExp(pseudos),
							ridentifier = new RegExp("^" + identifier + "$"),
							matchExpr = {
								"ID": new RegExp("^#(" + identifier + ")"),
								"CLASS": new RegExp("^\\.(" + identifier + ")"),
								"TAG": new RegExp("^(" + identifier + "|[*])"),
								"ATTR": new RegExp("^" + attributes),
								"PSEUDO": new RegExp("^" + pseudos),
								"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
								"bool": new RegExp("^(?:" + booleans + ")$", "i"),
								// For use in libraries implementing .is()
								// We use this for POS matching in `select`
								"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
							},
							rhtml = /HTML$/i,
							rinputs = /^(?:input|select|textarea|button)$/i,
							rheader = /^h\d$/i,
							rnative = /^[^{]+\{\s*\[native \w/,
							// Easily-parseable/retrievable ID or TAG or CLASS selectors
							rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
							rsibling = /[+~]/,
							// CSS escapes
							// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
							runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
							funescape = function funescape(escape, nonHex) {
								var high = "0x" + escape.slice(1) - 0x10000;
								return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
									nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
									// Support: IE <=11+
									// For values outside the Basic Multilingual Plane (BMP), manually construct a
									// surrogate pair
									high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
							},
							// CSS string/identifier serialization
							// https://drafts.csswg.org/cssom/#common-serializing-idioms
							rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
							fcssescape = function fcssescape(ch, asCodePoint) {
								if (asCodePoint) {
									// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
									if (ch === "\0") {
										return "\uFFFD";
									} // Control characters and (dependent upon position) numbers get escaped as code points


									return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
								} // Other potentially-special ASCII characters get backslash-escaped


								return "\\" + ch;
							},
							// Used for iframes
							// See setDocument()
							// Removing the function wrapper causes a "Permission Denied"
							// error in IE
							unloadHandler = function unloadHandler() {
								setDocument();
							},
							inDisabledFieldset = addCombinator(function (elem) {
								return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
							}, {
								dir: "parentNode",
								next: "legend"
							}); // Optimize for push.apply( _, NodeList )


						try {
							push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
							// Detect silently failing push.apply
							// eslint-disable-next-line no-unused-expressions

							arr[preferredDoc.childNodes.length].nodeType;
						} catch (e) {
							push = {
								apply: arr.length ? // Leverage slice if possible
									function (target, els) {
										pushNative.apply(target, slice.call(els));
									} : // Support: IE<9
									// Otherwise append directly
									function (target, els) {
										var j = target.length,
											i = 0; // Can't trust NodeList.length

										while (target[j++] = els[i++]) {
										}

										target.length = j - 1;
									}
							};
						}

						function Sizzle(selector, context, results, seed) {
							var m,
								i,
								elem,
								nid,
								match,
								groups,
								newSelector,
								newContext = context && context.ownerDocument,
								// nodeType defaults to 9, since context defaults to document
								nodeType = context ? context.nodeType : 9;
							results = results || []; // Return early from calls with invalid selector or context

							if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
								return results;
							} // Try to shortcut find operations (as opposed to filters) in HTML documents


							if (!seed) {
								setDocument(context);
								context = context || document;

								if (documentIsHTML) {
									// If the selector is sufficiently simple, try using a "get*By*" DOM method
									// (excepting DocumentFragment context, where the methods don't exist)
									if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
										// ID selector
										if (m = match[1]) {
											// Document context
											if (nodeType === 9) {
												if (elem = context.getElementById(m)) {
													// Support: IE, Opera, Webkit
													// TODO: identify versions
													// getElementById can match elements by name instead of ID
													if (elem.id === m) {
														results.push(elem);
														return results;
													}
												} else {
													return results;
												} // Element context

											} else {
												// Support: IE, Opera, Webkit
												// TODO: identify versions
												// getElementById can match elements by name instead of ID
												if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
													results.push(elem);
													return results;
												}
											} // Type selector

										} else if (match[2]) {
											push.apply(results, context.getElementsByTagName(selector));
											return results; // Class selector
										} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
											push.apply(results, context.getElementsByClassName(m));
											return results;
										}
									} // Take advantage of querySelectorAll


									if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
										// Exclude object elements
										nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
										newSelector = selector;
										newContext = context; // qSA considers elements outside a scoping root when evaluating child or
										// descendant combinators, which is not what we want.
										// In such cases, we work around the behavior by prefixing every selector in the
										// list with an ID selector referencing the scope context.
										// The technique has to be used as well when a leading combinator is used
										// as such selectors are not recognized by querySelectorAll.
										// Thanks to Andrew Dupont for this technique.

										if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
											// Expand context for sibling selectors
											newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
											// supports it & if we're not changing the context.

											if (newContext !== context || !support.scope) {
												// Capture the context ID, setting it first if necessary
												if (nid = context.getAttribute("id")) {
													nid = nid.replace(rcssescape, fcssescape);
												} else {
													context.setAttribute("id", nid = expando);
												}
											} // Prefix every selector in the list


											groups = tokenize(selector);
											i = groups.length;

											while (i--) {
												groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
											}

											newSelector = groups.join(",");
										}

										try {
											push.apply(results, newContext.querySelectorAll(newSelector));
											return results;
										} catch (qsaError) {
											nonnativeSelectorCache(selector, true);
										} finally {
											if (nid === expando) {
												context.removeAttribute("id");
											}
										}
									}
								}
							} // All others


							return select(selector.replace(rtrim, "$1"), context, results, seed);
						}

						/**
						 * Create key-value caches of limited size
						 * @returns {function(string, object)} Returns the Object data after storing it on itself with
						 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
						 *	deleting the oldest entry
						 */


						function createCache() {
							var keys = [];

							function cache(key, value) {
								// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
								if (keys.push(key + " ") > Expr.cacheLength) {
									// Only keep the most recent entries
									delete cache[keys.shift()];
								}

								return cache[key + " "] = value;
							}

							return cache;
						}

						/**
						 * Mark a function for special use by Sizzle
						 * @param {Function} fn The function to mark
						 */


						function markFunction(fn) {
							fn[expando] = true;
							return fn;
						}

						/**
						 * Support testing using an element
						 * @param {Function} fn Passed the created element and returns a boolean result
						 */


						function assert(fn) {
							var el = document.createElement("fieldset");

							try {
								return !!fn(el);
							} catch (e) {
								return false;
							} finally {
								// Remove from its parent by default
								if (el.parentNode) {
									el.parentNode.removeChild(el);
								} // release memory in IE


								el = null;
							}
						}

						/**
						 * Adds the same handler for all of the specified attrs
						 * @param {String} attrs Pipe-separated list of attributes
						 * @param {Function} handler The method that will be applied
						 */


						function addHandle(attrs, handler) {
							var arr = attrs.split("|"),
								i = arr.length;

							while (i--) {
								Expr.attrHandle[arr[i]] = handler;
							}
						}

						/**
						 * Checks document order of two siblings
						 * @param {Element} a
						 * @param {Element} b
						 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
						 */


						function siblingCheck(a, b) {
							var cur = b && a,
								diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

							if (diff) {
								return diff;
							} // Check if b follows a


							if (cur) {
								while (cur = cur.nextSibling) {
									if (cur === b) {
										return -1;
									}
								}
							}

							return a ? 1 : -1;
						}

						/**
						 * Returns a function to use in pseudos for input types
						 * @param {String} type
						 */


						function createInputPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && elem.type === type;
							};
						}

						/**
						 * Returns a function to use in pseudos for buttons
						 * @param {String} type
						 */


						function createButtonPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return (name === "input" || name === "button") && elem.type === type;
							};
						}

						/**
						 * Returns a function to use in pseudos for :enabled/:disabled
						 * @param {Boolean} disabled true for :disabled; false for :enabled
						 */


						function createDisabledPseudo(disabled) {
							// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
							return function (elem) {
								// Only certain elements can match :enabled or :disabled
								// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
								// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
								if ("form" in elem) {
									// Check for inherited disabledness on relevant non-disabled elements:
									// * listed form-associated elements in a disabled fieldset
									//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
									//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
									// * option elements in a disabled optgroup
									//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
									// All such elements have a "form" property.
									if (elem.parentNode && elem.disabled === false) {
										// Option elements defer to a parent optgroup if present
										if ("label" in elem) {
											if ("label" in elem.parentNode) {
												return elem.parentNode.disabled === disabled;
											} else {
												return elem.disabled === disabled;
											}
										} // Support: IE 6 - 11
										// Use the isDisabled shortcut property to check for disabled fieldset ancestors


										return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

											/* jshint -W018 */
											elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
									}

									return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
									// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
									// even exist on them, let alone have a boolean value.
								} else if ("label" in elem) {
									return elem.disabled === disabled;
								} // Remaining elements are neither :enabled nor :disabled


								return false;
							};
						}

						/**
						 * Returns a function to use in pseudos for positionals
						 * @param {Function} fn
						 */


						function createPositionalPseudo(fn) {
							return markFunction(function (argument) {
								argument = +argument;
								return markFunction(function (seed, matches) {
									var j,
										matchIndexes = fn([], seed.length, argument),
										i = matchIndexes.length; // Match elements found at the specified indexes

									while (i--) {
										if (seed[j = matchIndexes[i]]) {
											seed[j] = !(matches[j] = seed[j]);
										}
									}
								});
							});
						}

						/**
						 * Checks a node for validity as a Sizzle context
						 * @param {Element|Object=} context
						 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
						 */


						function testContext(context) {
							return context && typeof context.getElementsByTagName !== "undefined" && context;
						} // Expose support vars for convenience


						support = Sizzle.support = {};
						/**
						 * Detects XML nodes
						 * @param {Element|Object} elem An element or a document
						 * @returns {Boolean} True iff elem is a non-HTML XML node
						 */

						isXML = Sizzle.isXML = function (elem) {
							var namespace = elem.namespaceURI,
								docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8
							// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
							// https://bugs.jquery.com/ticket/4833

							return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
						};
						/**
						 * Sets document-related variables once based on the current document
						 * @param {Element|Object} [doc] An element or document object to use to set the document
						 * @returns {Object} Returns the current document
						 */


						setDocument = Sizzle.setDocument = function (node) {
							var hasCompare,
								subWindow,
								doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq

							if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
								return document;
							} // Update global variables


							document = doc;
							docElem = document.documentElement;
							documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
							// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq

							if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
								// Support: IE 11, Edge
								if (subWindow.addEventListener) {
									subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
								} else if (subWindow.attachEvent) {
									subWindow.attachEvent("onunload", unloadHandler);
								}
							} // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
							// Safari 4 - 5 only, Opera <=11.6 - 12.x only
							// IE/Edge & older browsers don't support the :scope pseudo-class.
							// Support: Safari 6.0 only
							// Safari 6.0 supports :scope but it's an alias of :root there.


							support.scope = assert(function (el) {
								docElem.appendChild(el).appendChild(document.createElement("div"));
								return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
							});
							/* Attributes
      ---------------------------------------------------------------------- */
							// Support: IE<8
							// Verify that getAttribute really returns attributes and not properties
							// (excepting IE8 booleans)

							support.attributes = assert(function (el) {
								el.className = "i";
								return !el.getAttribute("className");
							});
							/* getElement(s)By*
      ---------------------------------------------------------------------- */
							// Check if getElementsByTagName("*") returns only elements

							support.getElementsByTagName = assert(function (el) {
								el.appendChild(document.createComment(""));
								return !el.getElementsByTagName("*").length;
							}); // Support: IE<9

							support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
							// Check if getElementById returns elements by name
							// The broken getElementById methods don't pick up programmatically-set names,
							// so use a roundabout getElementsByName test

							support.getById = assert(function (el) {
								docElem.appendChild(el).id = expando;
								return !document.getElementsByName || !document.getElementsByName(expando).length;
							}); // ID filter and find

							if (support.getById) {
								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										return elem.getAttribute("id") === attrId;
									};
								};

								Expr.find["ID"] = function (id, context) {
									if (typeof context.getElementById !== "undefined" && documentIsHTML) {
										var elem = context.getElementById(id);
										return elem ? [elem] : [];
									}
								};
							} else {
								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
										return node && node.value === attrId;
									};
								}; // Support: IE 6 - 7 only
								// getElementById is not reliable as a find shortcut


								Expr.find["ID"] = function (id, context) {
									if (typeof context.getElementById !== "undefined" && documentIsHTML) {
										var node,
											i,
											elems,
											elem = context.getElementById(id);

										if (elem) {
											// Verify the id attribute
											node = elem.getAttributeNode("id");

											if (node && node.value === id) {
												return [elem];
											} // Fall back on getElementsByName


											elems = context.getElementsByName(id);
											i = 0;

											while (elem = elems[i++]) {
												node = elem.getAttributeNode("id");

												if (node && node.value === id) {
													return [elem];
												}
											}
										}

										return [];
									}
								};
							} // Tag


							Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
								if (typeof context.getElementsByTagName !== "undefined") {
									return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
								} else if (support.qsa) {
									return context.querySelectorAll(tag);
								}
							} : function (tag, context) {
								var elem,
									tmp = [],
									i = 0,
									// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
									results = context.getElementsByTagName(tag); // Filter out possible comments

								if (tag === "*") {
									while (elem = results[i++]) {
										if (elem.nodeType === 1) {
											tmp.push(elem);
										}
									}

									return tmp;
								}

								return results;
							}; // Class

							Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
								if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
									return context.getElementsByClassName(className);
								}
							};
							/* QSA/matchesSelector
      ---------------------------------------------------------------------- */
							// QSA and matchesSelector support
							// matchesSelector(:active) reports false when true (IE9/Opera 11.5)


							rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
							// We allow this because of a bug in IE8/9 that throws an error
							// whenever `document.activeElement` is accessed on an iframe
							// So, we allow :focus to pass through QSA all the time to avoid the IE error
							// See https://bugs.jquery.com/ticket/13378

							rbuggyQSA = [];

							if (support.qsa = rnative.test(document.querySelectorAll)) {
								// Build QSA regex
								// Regex strategy adopted from Diego Perini
								assert(function (el) {
									var input; // Select is set to empty string on purpose
									// This is to test IE's treatment of not explicitly
									// setting a boolean content attribute,
									// since its presence should be enough
									// https://bugs.jquery.com/ticket/12359

									docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
									// Nothing should be selected when empty strings follow ^= or $= or *=
									// The test attribute must be unknown in Opera but "safe" for WinRT
									// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

									if (el.querySelectorAll("[msallowcapture^='']").length) {
										rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
									} // Support: IE8
									// Boolean attributes and "value" are not treated correctly


									if (!el.querySelectorAll("[selected]").length) {
										rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
									} // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


									if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
										rbuggyQSA.push("~=");
									} // Support: IE 11+, Edge 15 - 18+
									// IE 11/Edge don't find elements on a `[name='']` query in some cases.
									// Adding a temporary attribute to the document before the selection works
									// around the issue.
									// Interestingly, IE 10 & older don't seem to have the issue.


									input = document.createElement("input");
									input.setAttribute("name", "");
									el.appendChild(input);

									if (!el.querySelectorAll("[name='']").length) {
										rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
									} // Webkit/Opera - :checked should return selected option elements
									// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
									// IE8 throws error here and will not see later tests


									if (!el.querySelectorAll(":checked").length) {
										rbuggyQSA.push(":checked");
									} // Support: Safari 8+, iOS 8+
									// https://bugs.webkit.org/show_bug.cgi?id=136851
									// In-page `selector#id sibling-combinator selector` fails


									if (!el.querySelectorAll("a#" + expando + "+*").length) {
										rbuggyQSA.push(".#.+[+~]");
									} // Support: Firefox <=3.6 - 5 only
									// Old Firefox doesn't throw on a badly-escaped identifier.


									el.querySelectorAll("\\\f");
									rbuggyQSA.push("[\\r\\n\\f]");
								});
								assert(function (el) {
									el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
									// The type and name attributes are restricted during .innerHTML assignment

									var input = document.createElement("input");
									input.setAttribute("type", "hidden");
									el.appendChild(input).setAttribute("name", "D"); // Support: IE8
									// Enforce case-sensitivity of name attribute

									if (el.querySelectorAll("[name=d]").length) {
										rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
									} // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
									// IE8 throws error here and will not see later tests


									if (el.querySelectorAll(":enabled").length !== 2) {
										rbuggyQSA.push(":enabled", ":disabled");
									} // Support: IE9-11+
									// IE's :disabled selector does not pick up the children of disabled fieldsets


									docElem.appendChild(el).disabled = true;

									if (el.querySelectorAll(":disabled").length !== 2) {
										rbuggyQSA.push(":enabled", ":disabled");
									} // Support: Opera 10 - 11 only
									// Opera 10-11 does not throw on post-comma invalid pseudos


									el.querySelectorAll("*,:x");
									rbuggyQSA.push(",.*:");
								});
							}

							if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
								assert(function (el) {
									// Check to see if it's possible to do matchesSelector
									// on a disconnected node (IE 9)
									support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
									// Gecko does not error, returns false instead

									matches.call(el, "[s!='']:x");
									rbuggyMatches.push("!=", pseudos);
								});
							}

							rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
							rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
							/* Contains
      ---------------------------------------------------------------------- */

							hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
							// Purposefully self-exclusive
							// As in, an element does not contain itself

							contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
								var adown = a.nodeType === 9 ? a.documentElement : a,
									bup = b && b.parentNode;
								return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
							} : function (a, b) {
								if (b) {
									while (b = b.parentNode) {
										if (b === a) {
											return true;
										}
									}
								}

								return false;
							};
							/* Sorting
      ---------------------------------------------------------------------- */
							// Document order sorting

							sortOrder = hasCompare ? function (a, b) {
								// Flag for duplicate removal
								if (a === b) {
									hasDuplicate = true;
									return 0;
								} // Sort on method existence if only one input has compareDocumentPosition


								var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

								if (compare) {
									return compare;
								} // Calculate position if both inputs belong to the same document
								// Support: IE 11+, Edge 17 - 18+
								// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
								// two documents; shallow comparisons work.
								// eslint-disable-next-line eqeqeq


								compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
									1; // Disconnected nodes

								if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
									// Choose the first element that is related to our preferred document
									// Support: IE 11+, Edge 17 - 18+
									// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
									// two documents; shallow comparisons work.
									// eslint-disable-next-line eqeqeq
									if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
										return -1;
									} // Support: IE 11+, Edge 17 - 18+
									// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
									// two documents; shallow comparisons work.
									// eslint-disable-next-line eqeqeq


									if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
										return 1;
									} // Maintain original order


									return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
								}

								return compare & 4 ? -1 : 1;
							} : function (a, b) {
								// Exit early if the nodes are identical
								if (a === b) {
									hasDuplicate = true;
									return 0;
								}

								var cur,
									i = 0,
									aup = a.parentNode,
									bup = b.parentNode,
									ap = [a],
									bp = [b]; // Parentless nodes are either documents or disconnected

								if (!aup || !bup) {
									// Support: IE 11+, Edge 17 - 18+
									// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
									// two documents; shallow comparisons work.

									/* eslint-disable eqeqeq */
									return a == document ? -1 : b == document ? 1 :
										/* eslint-enable eqeqeq */
										aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
								} else if (aup === bup) {
									return siblingCheck(a, b);
								} // Otherwise we need full lists of their ancestors for comparison


								cur = a;

								while (cur = cur.parentNode) {
									ap.unshift(cur);
								}

								cur = b;

								while (cur = cur.parentNode) {
									bp.unshift(cur);
								} // Walk down the tree looking for a discrepancy


								while (ap[i] === bp[i]) {
									i++;
								}

								return i ? // Do a sibling check if the nodes have a common ancestor
									siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
									// Support: IE 11+, Edge 17 - 18+
									// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
									// two documents; shallow comparisons work.

									/* eslint-disable eqeqeq */
									ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
										/* eslint-enable eqeqeq */
										0;
							};
							return document;
						};

						Sizzle.matches = function (expr, elements) {
							return Sizzle(expr, null, null, elements);
						};

						Sizzle.matchesSelector = function (elem, expr) {
							setDocument(elem);

							if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
								try {
									var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

									if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
										// fragment in IE 9
										elem.document && elem.document.nodeType !== 11) {
										return ret;
									}
								} catch (e) {
									nonnativeSelectorCache(expr, true);
								}
							}

							return Sizzle(expr, document, null, [elem]).length > 0;
						};

						Sizzle.contains = function (context, elem) {
							// Set document vars if needed
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if ((context.ownerDocument || context) != document) {
								setDocument(context);
							}

							return contains(context, elem);
						};

						Sizzle.attr = function (elem, name) {
							// Set document vars if needed
							// Support: IE 11+, Edge 17 - 18+
							// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
							// two documents; shallow comparisons work.
							// eslint-disable-next-line eqeqeq
							if ((elem.ownerDocument || elem) != document) {
								setDocument(elem);
							}

							var fn = Expr.attrHandle[name.toLowerCase()],
								// Don't get fooled by Object.prototype properties (jQuery #13807)
								val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
							return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
						};

						Sizzle.escape = function (sel) {
							return (sel + "").replace(rcssescape, fcssescape);
						};

						Sizzle.error = function (msg) {
							throw new Error("Syntax error, unrecognized expression: " + msg);
						};
						/**
						 * Document sorting and removing duplicates
						 * @param {ArrayLike} results
						 */


						Sizzle.uniqueSort = function (results) {
							var elem,
								duplicates = [],
								j = 0,
								i = 0; // Unless we *know* we can detect duplicates, assume their presence

							hasDuplicate = !support.detectDuplicates;
							sortInput = !support.sortStable && results.slice(0);
							results.sort(sortOrder);

							if (hasDuplicate) {
								while (elem = results[i++]) {
									if (elem === results[i]) {
										j = duplicates.push(i);
									}
								}

								while (j--) {
									results.splice(duplicates[j], 1);
								}
							} // Clear input after sorting to release objects
							// See https://github.com/jquery/sizzle/pull/225


							sortInput = null;
							return results;
						};
						/**
						 * Utility function for retrieving the text value of an array of DOM nodes
						 * @param {Array|Element} elem
						 */


						getText = Sizzle.getText = function (elem) {
							var node,
								ret = "",
								i = 0,
								nodeType = elem.nodeType;

							if (!nodeType) {
								// If no nodeType, this is expected to be an array
								while (node = elem[i++]) {
									// Do not traverse comment nodes
									ret += getText(node);
								}
							} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
								// Use textContent for elements
								// innerText usage removed for consistency of new lines (jQuery #11153)
								if (typeof elem.textContent === "string") {
									return elem.textContent;
								} else {
									// Traverse its children
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										ret += getText(elem);
									}
								}
							} else if (nodeType === 3 || nodeType === 4) {
								return elem.nodeValue;
							} // Do not include comment or processing instruction nodes


							return ret;
						};

						Expr = Sizzle.selectors = {
							// Can be adjusted by the user
							cacheLength: 50,
							createPseudo: markFunction,
							match: matchExpr,
							attrHandle: {},
							find: {},
							relative: {
								">": {
									dir: "parentNode",
									first: true
								},
								" ": {
									dir: "parentNode"
								},
								"+": {
									dir: "previousSibling",
									first: true
								},
								"~": {
									dir: "previousSibling"
								}
							},
							preFilter: {
								"ATTR": function ATTR(match) {
									match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

									match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

									if (match[2] === "~=") {
										match[3] = " " + match[3] + " ";
									}

									return match.slice(0, 4);
								},
								"CHILD": function CHILD(match) {
									/* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
									match[1] = match[1].toLowerCase();

									if (match[1].slice(0, 3) === "nth") {
										// nth-* requires argument
										if (!match[3]) {
											Sizzle.error(match[0]);
										} // numeric x and y parameters for Expr.filter.CHILD
										// remember that false/true cast respectively to 0/1


										match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
										match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
									} else if (match[3]) {
										Sizzle.error(match[0]);
									}

									return match;
								},
								"PSEUDO": function PSEUDO(match) {
									var excess,
										unquoted = !match[6] && match[2];

									if (matchExpr["CHILD"].test(match[0])) {
										return null;
									} // Accept quoted arguments as-is


									if (match[3]) {
										match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
									} else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
										excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
										excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
										// excess is a negative index
										match[0] = match[0].slice(0, excess);
										match[2] = unquoted.slice(0, excess);
									} // Return only captures needed by the pseudo filter method (type and argument)


									return match.slice(0, 3);
								}
							},
							filter: {
								"TAG": function TAG(nodeNameSelector) {
									var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
									return nodeNameSelector === "*" ? function () {
										return true;
									} : function (elem) {
										return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
									};
								},
								"CLASS": function CLASS(className) {
									var pattern = classCache[className + " "];
									return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
										return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
									});
								},
								"ATTR": function ATTR(name, operator, check) {
									return function (elem) {
										var result = Sizzle.attr(elem, name);

										if (result == null) {
											return operator === "!=";
										}

										if (!operator) {
											return true;
										}

										result += "";
										/* eslint-disable max-len */

										return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
										/* eslint-enable max-len */
									};
								},
								"CHILD": function CHILD(type, what, _argument, first, last) {
									var simple = type.slice(0, 3) !== "nth",
										forward = type.slice(-4) !== "last",
										ofType = what === "of-type";
									return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
										function (elem) {
											return !!elem.parentNode;
										} : function (elem, _context, xml) {
											var cache,
												uniqueCache,
												outerCache,
												node,
												nodeIndex,
												start,
												dir = simple !== forward ? "nextSibling" : "previousSibling",
												parent = elem.parentNode,
												name = ofType && elem.nodeName.toLowerCase(),
												useCache = !xml && !ofType,
												diff = false;

											if (parent) {
												// :(first|last|only)-(child|of-type)
												if (simple) {
													while (dir) {
														node = elem;

														while (node = node[dir]) {
															if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
																return false;
															}
														} // Reverse direction for :only-* (if we haven't yet done so)


														start = dir = type === "only" && !start && "nextSibling";
													}

													return true;
												}

												start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

												if (forward && useCache) {
													// Seek `elem` from a previously-cached index
													// ...in a gzip-friendly way
													node = parent;
													outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
													// Defend against cloned attroperties (jQuery gh-1709)

													uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
													cache = uniqueCache[type] || [];
													nodeIndex = cache[0] === dirruns && cache[1];
													diff = nodeIndex && cache[2];
													node = nodeIndex && parent.childNodes[nodeIndex];

													while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
														diff = nodeIndex = 0) || start.pop()) {
														// When found, cache indexes on `parent` and break
														if (node.nodeType === 1 && ++diff && node === elem) {
															uniqueCache[type] = [dirruns, nodeIndex, diff];
															break;
														}
													}
												} else {
													// Use previously-cached element index if available
													if (useCache) {
														// ...in a gzip-friendly way
														node = elem;
														outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)

														uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
														cache = uniqueCache[type] || [];
														nodeIndex = cache[0] === dirruns && cache[1];
														diff = nodeIndex;
													} // xml :nth-child(...)
													// or :nth-last-child(...) or :nth(-last)?-of-type(...)


													if (diff === false) {
														// Use the same loop as above to seek `elem` from the start
														while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
															if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
																// Cache the index of each encountered element
																if (useCache) {
																	outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
																	// Defend against cloned attroperties (jQuery gh-1709)

																	uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
																	uniqueCache[type] = [dirruns, diff];
																}

																if (node === elem) {
																	break;
																}
															}
														}
													}
												} // Incorporate the offset, then check against cycle size


												diff -= last;
												return diff === first || diff % first === 0 && diff / first >= 0;
											}
										};
								},
								"PSEUDO": function PSEUDO(pseudo, argument) {
									// pseudo-class names are case-insensitive
									// http://www.w3.org/TR/selectors/#pseudo-classes
									// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
									// Remember that setFilters inherits from pseudos
									var args,
										fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
									// arguments are needed to create the filter function
									// just as Sizzle does

									if (fn[expando]) {
										return fn(argument);
									} // But maintain support for old signatures


									if (fn.length > 1) {
										args = [pseudo, pseudo, "", argument];
										return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
											var idx,
												matched = fn(seed, argument),
												i = matched.length;

											while (i--) {
												idx = indexOf(seed, matched[i]);
												seed[idx] = !(matches[idx] = matched[i]);
											}
										}) : function (elem) {
											return fn(elem, 0, args);
										};
									}

									return fn;
								}
							},
							pseudos: {
								// Potentially complex pseudos
								"not": markFunction(function (selector) {
									// Trim the selector passed to compile
									// to avoid treating leading and trailing
									// spaces as combinators
									var input = [],
										results = [],
										matcher = compile(selector.replace(rtrim, "$1"));
									return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
										var elem,
											unmatched = matcher(seed, null, xml, []),
											i = seed.length; // Match elements unmatched by `matcher`

										while (i--) {
											if (elem = unmatched[i]) {
												seed[i] = !(matches[i] = elem);
											}
										}
									}) : function (elem, _context, xml) {
										input[0] = elem;
										matcher(input, null, xml, results); // Don't keep the element (issue #299)

										input[0] = null;
										return !results.pop();
									};
								}),
								"has": markFunction(function (selector) {
									return function (elem) {
										return Sizzle(selector, elem).length > 0;
									};
								}),
								"contains": markFunction(function (text) {
									text = text.replace(runescape, funescape);
									return function (elem) {
										return (elem.textContent || getText(elem)).indexOf(text) > -1;
									};
								}),
								// "Whether an element is represented by a :lang() selector
								// is based solely on the element's language value
								// being equal to the identifier C,
								// or beginning with the identifier C immediately followed by "-".
								// The matching of C against the element's language value is performed case-insensitively.
								// The identifier C does not have to be a valid language name."
								// http://www.w3.org/TR/selectors/#lang-pseudo
								"lang": markFunction(function (lang) {
									// lang value must be a valid identifier
									if (!ridentifier.test(lang || "")) {
										Sizzle.error("unsupported lang: " + lang);
									}

									lang = lang.replace(runescape, funescape).toLowerCase();
									return function (elem) {
										var elemLang;

										do {
											if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
												elemLang = elemLang.toLowerCase();
												return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
											}
										} while ((elem = elem.parentNode) && elem.nodeType === 1);

										return false;
									};
								}),
								// Miscellaneous
								"target": function target(elem) {
									var hash = window.location && window.location.hash;
									return hash && hash.slice(1) === elem.id;
								},
								"root": function root(elem) {
									return elem === docElem;
								},
								"focus": function focus(elem) {
									return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
								},
								// Boolean properties
								"enabled": createDisabledPseudo(false),
								"disabled": createDisabledPseudo(true),
								"checked": function checked(elem) {
									// In CSS3, :checked should return both checked and selected elements
									// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
									var nodeName = elem.nodeName.toLowerCase();
									return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
								},
								"selected": function selected(elem) {
									// Accessing this property makes selected-by-default
									// options in Safari work properly
									if (elem.parentNode) {
										// eslint-disable-next-line no-unused-expressions
										elem.parentNode.selectedIndex;
									}

									return elem.selected === true;
								},
								// Contents
								"empty": function empty(elem) {
									// http://www.w3.org/TR/selectors/#empty-pseudo
									// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
									//   but not by others (comment: 8; processing instruction: 7; etc.)
									// nodeType < 6 works because attributes (2) do not appear as children
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										if (elem.nodeType < 6) {
											return false;
										}
									}

									return true;
								},
								"parent": function parent(elem) {
									return !Expr.pseudos["empty"](elem);
								},
								// Element/input types
								"header": function header(elem) {
									return rheader.test(elem.nodeName);
								},
								"input": function input(elem) {
									return rinputs.test(elem.nodeName);
								},
								"button": function button(elem) {
									var name = elem.nodeName.toLowerCase();
									return name === "input" && elem.type === "button" || name === "button";
								},
								"text": function text(elem) {
									var attr;
									return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
										// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
										(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
								},
								// Position-in-collection
								"first": createPositionalPseudo(function () {
									return [0];
								}),
								"last": createPositionalPseudo(function (_matchIndexes, length) {
									return [length - 1];
								}),
								"eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
									return [argument < 0 ? argument + length : argument];
								}),
								"even": createPositionalPseudo(function (matchIndexes, length) {
									var i = 0;

									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}

									return matchIndexes;
								}),
								"odd": createPositionalPseudo(function (matchIndexes, length) {
									var i = 1;

									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}

									return matchIndexes;
								}),
								"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument > length ? length : argument;

									for (; --i >= 0;) {
										matchIndexes.push(i);
									}

									return matchIndexes;
								}),
								"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument;

									for (; ++i < length;) {
										matchIndexes.push(i);
									}

									return matchIndexes;
								})
							}
						};
						Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

						for (i in {
							radio: true,
							checkbox: true,
							file: true,
							password: true,
							image: true
						}) {
							Expr.pseudos[i] = createInputPseudo(i);
						}

						for (i in {
							submit: true,
							reset: true
						}) {
							Expr.pseudos[i] = createButtonPseudo(i);
						} // Easy API for creating new setFilters


						function setFilters() {
						}

						setFilters.prototype = Expr.filters = Expr.pseudos;
						Expr.setFilters = new setFilters();

						tokenize = Sizzle.tokenize = function (selector, parseOnly) {
							var matched,
								match,
								tokens,
								type,
								soFar,
								groups,
								preFilters,
								cached = tokenCache[selector + " "];

							if (cached) {
								return parseOnly ? 0 : cached.slice(0);
							}

							soFar = selector;
							groups = [];
							preFilters = Expr.preFilter;

							while (soFar) {
								// Comma and first run
								if (!matched || (match = rcomma.exec(soFar))) {
									if (match) {
										// Don't consume trailing commas as valid
										soFar = soFar.slice(match[0].length) || soFar;
									}

									groups.push(tokens = []);
								}

								matched = false; // Combinators

								if (match = rcombinators.exec(soFar)) {
									matched = match.shift();
									tokens.push({
										value: matched,
										// Cast descendant combinators to space
										type: match[0].replace(rtrim, " ")
									});
									soFar = soFar.slice(matched.length);
								} // Filters


								for (type in Expr.filter) {
									if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
										matched = match.shift();
										tokens.push({
											value: matched,
											type: type,
											matches: match
										});
										soFar = soFar.slice(matched.length);
									}
								}

								if (!matched) {
									break;
								}
							} // Return the length of the invalid excess
							// if we're just parsing
							// Otherwise, throw an error or return tokens


							return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
								tokenCache(selector, groups).slice(0);
						};

						function toSelector(tokens) {
							var i = 0,
								len = tokens.length,
								selector = "";

							for (; i < len; i++) {
								selector += tokens[i].value;
							}

							return selector;
						}

						function addCombinator(matcher, combinator, base) {
							var dir = combinator.dir,
								skip = combinator.next,
								key = skip || dir,
								checkNonElements = base && key === "parentNode",
								doneName = done++;
							return combinator.first ? // Check against closest ancestor/preceding element
								function (elem, context, xml) {
									while (elem = elem[dir]) {
										if (elem.nodeType === 1 || checkNonElements) {
											return matcher(elem, context, xml);
										}
									}

									return false;
								} : // Check against all ancestor/preceding elements
								function (elem, context, xml) {
									var oldCache,
										uniqueCache,
										outerCache,
										newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

									if (xml) {
										while (elem = elem[dir]) {
											if (elem.nodeType === 1 || checkNonElements) {
												if (matcher(elem, context, xml)) {
													return true;
												}
											}
										}
									} else {
										while (elem = elem[dir]) {
											if (elem.nodeType === 1 || checkNonElements) {
												outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)

												uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

												if (skip && skip === elem.nodeName.toLowerCase()) {
													elem = elem[dir] || elem;
												} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
													// Assign to newCache so results back-propagate to previous elements
													return newCache[2] = oldCache[2];
												} else {
													// Reuse newcache so results back-propagate to previous elements
													uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

													if (newCache[2] = matcher(elem, context, xml)) {
														return true;
													}
												}
											}
										}
									}

									return false;
								};
						}

						function elementMatcher(matchers) {
							return matchers.length > 1 ? function (elem, context, xml) {
								var i = matchers.length;

								while (i--) {
									if (!matchers[i](elem, context, xml)) {
										return false;
									}
								}

								return true;
							} : matchers[0];
						}

						function multipleContexts(selector, contexts, results) {
							var i = 0,
								len = contexts.length;

							for (; i < len; i++) {
								Sizzle(selector, contexts[i], results);
							}

							return results;
						}

						function condense(unmatched, map, filter, context, xml) {
							var elem,
								newUnmatched = [],
								i = 0,
								len = unmatched.length,
								mapped = map != null;

							for (; i < len; i++) {
								if (elem = unmatched[i]) {
									if (!filter || filter(elem, context, xml)) {
										newUnmatched.push(elem);

										if (mapped) {
											map.push(i);
										}
									}
								}
							}

							return newUnmatched;
						}

						function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
							if (postFilter && !postFilter[expando]) {
								postFilter = setMatcher(postFilter);
							}

							if (postFinder && !postFinder[expando]) {
								postFinder = setMatcher(postFinder, postSelector);
							}

							return markFunction(function (seed, results, context, xml) {
								var temp,
									i,
									elem,
									preMap = [],
									postMap = [],
									preexisting = results.length,
									// Get initial elements from seed or context
									elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
									// Prefilter to get matcher input, preserving a map for seed-results synchronization
									matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
									matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
										postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
											[] : // ...otherwise use results directly
											results : matcherIn; // Find primary matches

								if (matcher) {
									matcher(matcherIn, matcherOut, context, xml);
								} // Apply postFilter


								if (postFilter) {
									temp = condense(matcherOut, postMap);
									postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

									i = temp.length;

									while (i--) {
										if (elem = temp[i]) {
											matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
										}
									}
								}

								if (seed) {
									if (postFinder || preFilter) {
										if (postFinder) {
											// Get the final matcherOut by condensing this intermediate into postFinder contexts
											temp = [];
											i = matcherOut.length;

											while (i--) {
												if (elem = matcherOut[i]) {
													// Restore matcherIn since elem is not yet a final match
													temp.push(matcherIn[i] = elem);
												}
											}

											postFinder(null, matcherOut = [], temp, xml);
										} // Move matched elements from seed to results to keep them synchronized


										i = matcherOut.length;

										while (i--) {
											if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
												seed[temp] = !(results[temp] = elem);
											}
										}
									} // Add elements to results, through postFinder if defined

								} else {
									matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

									if (postFinder) {
										postFinder(null, results, matcherOut, xml);
									} else {
										push.apply(results, matcherOut);
									}
								}
							});
						}

						function matcherFromTokens(tokens) {
							var checkContext,
								matcher,
								j,
								len = tokens.length,
								leadingRelative = Expr.relative[tokens[0].type],
								implicitRelative = leadingRelative || Expr.relative[" "],
								i = leadingRelative ? 1 : 0,
								// The foundational matcher ensures that elements are reachable from top-level context(s)
								matchContext = addCombinator(function (elem) {
									return elem === checkContext;
								}, implicitRelative, true),
								matchAnyContext = addCombinator(function (elem) {
									return indexOf(checkContext, elem) > -1;
								}, implicitRelative, true),
								matchers = [function (elem, context, xml) {
									var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

									checkContext = null;
									return ret;
								}];

							for (; i < len; i++) {
								if (matcher = Expr.relative[tokens[i].type]) {
									matchers = [addCombinator(elementMatcher(matchers), matcher)];
								} else {
									matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

									if (matcher[expando]) {
										// Find the next relative operator (if any) for proper handling
										j = ++i;

										for (; j < len; j++) {
											if (Expr.relative[tokens[j].type]) {
												break;
											}
										}

										return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
											tokens.slice(0, i - 1).concat({
												value: tokens[i - 2].type === " " ? "*" : ""
											})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
									}

									matchers.push(matcher);
								}
							}

							return elementMatcher(matchers);
						}

						function matcherFromGroupMatchers(elementMatchers, setMatchers) {
							var bySet = setMatchers.length > 0,
								byElement = elementMatchers.length > 0,
								superMatcher = function superMatcher(seed, context, xml, results, outermost) {
									var elem,
										j,
										matcher,
										matchedCount = 0,
										i = "0",
										unmatched = seed && [],
										setMatched = [],
										contextBackup = outermostContext,
										// We must always have either seed elements or outermost context
										elems = seed || byElement && Expr.find["TAG"]("*", outermost),
										// Use integer dirruns iff this is the outermost matcher
										dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
										len = elems.length;

									if (outermost) {
										// Support: IE 11+, Edge 17 - 18+
										// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
										// two documents; shallow comparisons work.
										// eslint-disable-next-line eqeqeq
										outermostContext = context == document || context || outermost;
									} // Add elements passing elementMatchers directly to results
									// Support: IE<9, Safari
									// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


									for (; i !== len && (elem = elems[i]) != null; i++) {
										if (byElement && elem) {
											j = 0; // Support: IE 11+, Edge 17 - 18+
											// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
											// two documents; shallow comparisons work.
											// eslint-disable-next-line eqeqeq

											if (!context && elem.ownerDocument != document) {
												setDocument(elem);
												xml = !documentIsHTML;
											}

											while (matcher = elementMatchers[j++]) {
												if (matcher(elem, context || document, xml)) {
													results.push(elem);
													break;
												}
											}

											if (outermost) {
												dirruns = dirrunsUnique;
											}
										} // Track unmatched elements for set filters


										if (bySet) {
											// They will have gone through all possible matchers
											if (elem = !matcher && elem) {
												matchedCount--;
											} // Lengthen the array for every element, matched or not


											if (seed) {
												unmatched.push(elem);
											}
										}
									} // `i` is now the count of elements visited above, and adding it to `matchedCount`
									// makes the latter nonnegative.


									matchedCount += i; // Apply set filters to unmatched elements
									// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
									// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
									// no element matchers and no seed.
									// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
									// case, which will result in a "00" `matchedCount` that differs from `i` but is also
									// numerically zero.

									if (bySet && i !== matchedCount) {
										j = 0;

										while (matcher = setMatchers[j++]) {
											matcher(unmatched, setMatched, context, xml);
										}

										if (seed) {
											// Reintegrate element matches to eliminate the need for sorting
											if (matchedCount > 0) {
												while (i--) {
													if (!(unmatched[i] || setMatched[i])) {
														setMatched[i] = pop.call(results);
													}
												}
											} // Discard index placeholder values to get only actual matches


											setMatched = condense(setMatched);
										} // Add matches to results


										push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

										if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
											Sizzle.uniqueSort(results);
										}
									} // Override manipulation of globals by nested matchers


									if (outermost) {
										dirruns = dirrunsUnique;
										outermostContext = contextBackup;
									}

									return unmatched;
								};

							return bySet ? markFunction(superMatcher) : superMatcher;
						}

						compile = Sizzle.compile = function (selector, match
															 /* Internal Use Only */
						) {
							var i,
								setMatchers = [],
								elementMatchers = [],
								cached = compilerCache[selector + " "];

							if (!cached) {
								// Generate a function of recursive functions that can be used to check each element
								if (!match) {
									match = tokenize(selector);
								}

								i = match.length;

								while (i--) {
									cached = matcherFromTokens(match[i]);

									if (cached[expando]) {
										setMatchers.push(cached);
									} else {
										elementMatchers.push(cached);
									}
								} // Cache the compiled function


								cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

								cached.selector = selector;
							}

							return cached;
						};
						/**
						 * A low-level selection function that works with Sizzle's compiled
						 *  selector functions
						 * @param {String|Function} selector A selector or a pre-compiled
						 *  selector function built with Sizzle.compile
						 * @param {Element} context
						 * @param {Array} [results]
						 * @param {Array} [seed] A set of elements to match against
						 */


						select = Sizzle.select = function (selector, context, results, seed) {
							var i,
								tokens,
								token,
								type,
								find,
								compiled = typeof selector === "function" && selector,
								match = !seed && tokenize(selector = compiled.selector || selector);
							results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
							// (the latter of which guarantees us context)

							if (match.length === 1) {
								// Reduce context if the leading compound selector is an ID
								tokens = match[0] = match[0].slice(0);

								if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
									context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

									if (!context) {
										return results; // Precompiled matchers will still verify ancestry, so step up a level
									} else if (compiled) {
										context = context.parentNode;
									}

									selector = selector.slice(tokens.shift().value.length);
								} // Fetch a seed set for right-to-left matching


								i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

								while (i--) {
									token = tokens[i]; // Abort if we hit a combinator

									if (Expr.relative[type = token.type]) {
										break;
									}

									if (find = Expr.find[type]) {
										// Search, expanding context for leading sibling combinators
										if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
											// If seed is empty or no tokens remain, we can return early
											tokens.splice(i, 1);
											selector = seed.length && toSelector(tokens);

											if (!selector) {
												push.apply(results, seed);
												return results;
											}

											break;
										}
									}
								}
							} // Compile and execute a filtering function if one is not provided
							// Provide `match` to avoid retokenization if we modified the selector above


							(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
							return results;
						}; // One-time assignments
						// Sort stability


						support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
						// Always assume duplicates if they aren't passed to the comparison function

						support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

						setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
						// Detached nodes confoundingly follow *each other*

						support.sortDetached = assert(function (el) {
							// Should return 1, but returns 4 (following)
							return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
						}); // Support: IE<8
						// Prevent attribute/property "interpolation"
						// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

						if (!assert(function (el) {
							el.innerHTML = "<a href='#'></a>";
							return el.firstChild.getAttribute("href") === "#";
						})) {
							addHandle("type|href|height|width", function (elem, name, isXML) {
								if (!isXML) {
									return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
								}
							});
						} // Support: IE<9
						// Use defaultValue in place of getAttribute("value")


						if (!support.attributes || !assert(function (el) {
							el.innerHTML = "<input/>";
							el.firstChild.setAttribute("value", "");
							return el.firstChild.getAttribute("value") === "";
						})) {
							addHandle("value", function (elem, _name, isXML) {
								if (!isXML && elem.nodeName.toLowerCase() === "input") {
									return elem.defaultValue;
								}
							});
						} // Support: IE<9
						// Use getAttributeNode to fetch booleans when getAttribute lies


						if (!assert(function (el) {
							return el.getAttribute("disabled") == null;
						})) {
							addHandle(booleans, function (elem, name, isXML) {
								var val;

								if (!isXML) {
									return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
								}
							});
						}

						return Sizzle;
					}(window);

				jQuery.find = Sizzle;
				jQuery.expr = Sizzle.selectors; // Deprecated

				jQuery.expr[":"] = jQuery.expr.pseudos;
				jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
				jQuery.text = Sizzle.getText;
				jQuery.isXMLDoc = Sizzle.isXML;
				jQuery.contains = Sizzle.contains;
				jQuery.escapeSelector = Sizzle.escape;

				var dir = function dir(elem, _dir, until) {
					var matched = [],
						truncate = until !== undefined;

					while ((elem = elem[_dir]) && elem.nodeType !== 9) {
						if (elem.nodeType === 1) {
							if (truncate && jQuery(elem).is(until)) {
								break;
							}

							matched.push(elem);
						}
					}

					return matched;
				};

				var _siblings = function siblings(n, elem) {
					var matched = [];

					for (; n; n = n.nextSibling) {
						if (n.nodeType === 1 && n !== elem) {
							matched.push(n);
						}
					}

					return matched;
				};

				var rneedsContext = jQuery.expr.match.needsContext;

				function nodeName(elem, name) {
					return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				}

				;
				var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

				function winnow(elements, qualifier, not) {
					if (isFunction(qualifier)) {
						return jQuery.grep(elements, function (elem, i) {
							return !!qualifier.call(elem, i, elem) !== not;
						});
					} // Single element


					if (qualifier.nodeType) {
						return jQuery.grep(elements, function (elem) {
							return elem === qualifier !== not;
						});
					} // Arraylike of elements (jQuery, arguments, Array)


					if (typeof qualifier !== "string") {
						return jQuery.grep(elements, function (elem) {
							return indexOf.call(qualifier, elem) > -1 !== not;
						});
					} // Filtered directly for both simple and complex selectors


					return jQuery.filter(qualifier, elements, not);
				}

				jQuery.filter = function (expr, elems, not) {
					var elem = elems[0];

					if (not) {
						expr = ":not(" + expr + ")";
					}

					if (elems.length === 1 && elem.nodeType === 1) {
						return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
					}

					return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
						return elem.nodeType === 1;
					}));
				};

				jQuery.fn.extend({
					find: function find(selector) {
						var i,
							ret,
							len = this.length,
							self = this;

						if (typeof selector !== "string") {
							return this.pushStack(jQuery(selector).filter(function () {
								for (i = 0; i < len; i++) {
									if (jQuery.contains(self[i], this)) {
										return true;
									}
								}
							}));
						}

						ret = this.pushStack([]);

						for (i = 0; i < len; i++) {
							jQuery.find(selector, self[i], ret);
						}

						return len > 1 ? jQuery.uniqueSort(ret) : ret;
					},
					filter: function filter(selector) {
						return this.pushStack(winnow(this, selector || [], false));
					},
					not: function not(selector) {
						return this.pushStack(winnow(this, selector || [], true));
					},
					is: function is(selector) {
						return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
							// so $("p:first").is("p:last") won't return true for a doc with two "p".
							typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
					}
				}); // Initialize a jQuery object
				// A central reference to the root jQuery(document)

				var rootjQuery,
					// A simple way to check for HTML strings
					// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
					// Strict HTML recognition (#11290: must start with <)
					// Shortcut simple #id case for speed
					rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
					init = jQuery.fn.init = function (selector, context, root) {
						var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

						if (!selector) {
							return this;
						} // Method init() accepts an alternate rootjQuery
						// so migrate can support jQuery.sub (gh-2101)


						root = root || rootjQuery; // Handle HTML strings

						if (typeof selector === "string") {
							if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
								// Assume that strings that start and end with <> are HTML and skip the regex check
								match = [null, selector, null];
							} else {
								match = rquickExpr.exec(selector);
							} // Match html or make sure no context is specified for #id


							if (match && (match[1] || !context)) {
								// HANDLE: $(html) -> $(array)
								if (match[1]) {
									context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
									// Intentionally let the error be thrown if parseHTML is not present

									jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

									if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
										for (match in context) {
											// Properties of context are called as methods if possible
											if (isFunction(this[match])) {
												this[match](context[match]); // ...and otherwise set as attributes
											} else {
												this.attr(match, context[match]);
											}
										}
									}

									return this; // HANDLE: $(#id)
								} else {
									elem = document.getElementById(match[2]);

									if (elem) {
										// Inject the element directly into the jQuery object
										this[0] = elem;
										this.length = 1;
									}

									return this;
								} // HANDLE: $(expr, $(...))

							} else if (!context || context.jquery) {
								return (context || root).find(selector); // HANDLE: $(expr, context)
								// (which is just equivalent to: $(context).find(expr)
							} else {
								return this.constructor(context).find(selector);
							} // HANDLE: $(DOMElement)

						} else if (selector.nodeType) {
							this[0] = selector;
							this.length = 1;
							return this; // HANDLE: $(function)
							// Shortcut for document ready
						} else if (isFunction(selector)) {
							return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
								selector(jQuery);
						}

						return jQuery.makeArray(selector, this);
					}; // Give the init function the jQuery prototype for later instantiation


				init.prototype = jQuery.fn; // Initialize central reference

				rootjQuery = jQuery(document);
				var rparentsprev = /^(?:parents|prev(?:Until|All))/,
					// Methods guaranteed to produce a unique set when starting from a unique set
					guaranteedUnique = {
						children: true,
						contents: true,
						next: true,
						prev: true
					};
				jQuery.fn.extend({
					has: function has(target) {
						var targets = jQuery(target, this),
							l = targets.length;
						return this.filter(function () {
							var i = 0;

							for (; i < l; i++) {
								if (jQuery.contains(this, targets[i])) {
									return true;
								}
							}
						});
					},
					closest: function closest(selectors, context) {
						var cur,
							i = 0,
							l = this.length,
							matched = [],
							targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

						if (!rneedsContext.test(selectors)) {
							for (; i < l; i++) {
								for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
									// Always skip document fragments
									if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
										cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
										matched.push(cur);
										break;
									}
								}
							}
						}

						return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
					},
					// Determine the position of an element within the set
					index: function index(elem) {
						// No argument, return index in parent
						if (!elem) {
							return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
						} // Index in selector


						if (typeof elem === "string") {
							return indexOf.call(jQuery(elem), this[0]);
						} // Locate the position of the desired element


						return indexOf.call(this, // If it receives a jQuery object, the first element is used
							elem.jquery ? elem[0] : elem);
					},
					add: function add(selector, context) {
						return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
					},
					addBack: function addBack(selector) {
						return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
					}
				});

				function sibling(cur, dir) {
					while ((cur = cur[dir]) && cur.nodeType !== 1) {
					}

					return cur;
				}

				jQuery.each({
					parent: function parent(elem) {
						var parent = elem.parentNode;
						return parent && parent.nodeType !== 11 ? parent : null;
					},
					parents: function parents(elem) {
						return dir(elem, "parentNode");
					},
					parentsUntil: function parentsUntil(elem, _i, until) {
						return dir(elem, "parentNode", until);
					},
					next: function next(elem) {
						return sibling(elem, "nextSibling");
					},
					prev: function prev(elem) {
						return sibling(elem, "previousSibling");
					},
					nextAll: function nextAll(elem) {
						return dir(elem, "nextSibling");
					},
					prevAll: function prevAll(elem) {
						return dir(elem, "previousSibling");
					},
					nextUntil: function nextUntil(elem, _i, until) {
						return dir(elem, "nextSibling", until);
					},
					prevUntil: function prevUntil(elem, _i, until) {
						return dir(elem, "previousSibling", until);
					},
					siblings: function siblings(elem) {
						return _siblings((elem.parentNode || {}).firstChild, elem);
					},
					children: function children(elem) {
						return _siblings(elem.firstChild);
					},
					contents: function contents(elem) {
						if (elem.contentDocument != null && // Support: IE 11+
							// <object> elements with no `data` attribute has an object
							// `contentDocument` with a `null` prototype.
							getProto(elem.contentDocument)) {
							return elem.contentDocument;
						} // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
						// Treat the template element as a regular one in browsers that
						// don't support it.


						if (nodeName(elem, "template")) {
							elem = elem.content || elem;
						}

						return jQuery.merge([], elem.childNodes);
					}
				}, function (name, fn) {
					jQuery.fn[name] = function (until, selector) {
						var matched = jQuery.map(this, fn, until);

						if (name.slice(-5) !== "Until") {
							selector = until;
						}

						if (selector && typeof selector === "string") {
							matched = jQuery.filter(selector, matched);
						}

						if (this.length > 1) {
							// Remove duplicates
							if (!guaranteedUnique[name]) {
								jQuery.uniqueSort(matched);
							} // Reverse order for parents* and prev-derivatives


							if (rparentsprev.test(name)) {
								matched.reverse();
							}
						}

						return this.pushStack(matched);
					};
				});
				var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

				function createOptions(options) {
					var object = {};
					jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
						object[flag] = true;
					});
					return object;
				}

				/*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


				jQuery.Callbacks = function (options) {
					// Convert options from String-formatted to Object-formatted if needed
					// (we check in cache first)
					options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

					var // Flag to know if list is currently firing
						firing,
						// Last fire value for non-forgettable lists
						memory,
						// Flag to know if list was already fired
						_fired,
						// Flag to prevent firing
						_locked,
						// Actual callback list
						list = [],
						// Queue of execution data for repeatable lists
						queue = [],
						// Index of currently firing callback (modified by add/remove as needed)
						firingIndex = -1,
						// Fire callbacks
						fire = function fire() {
							// Enforce single-firing
							_locked = _locked || options.once; // Execute callbacks for all pending executions,
							// respecting firingIndex overrides and runtime changes

							_fired = firing = true;

							for (; queue.length; firingIndex = -1) {
								memory = queue.shift();

								while (++firingIndex < list.length) {
									// Run callback and check for early termination
									if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
										// Jump to end and forget the data so .add doesn't re-fire
										firingIndex = list.length;
										memory = false;
									}
								}
							} // Forget the data if we're done with it


							if (!options.memory) {
								memory = false;
							}

							firing = false; // Clean up if we're done firing for good

							if (_locked) {
								// Keep an empty list if we have data for future add calls
								if (memory) {
									list = []; // Otherwise, this object is spent
								} else {
									list = "";
								}
							}
						},
						// Actual Callbacks object
						self = {
							// Add a callback or a collection of callbacks to the list
							add: function add() {
								if (list) {
									// If we have memory from a past run, we should fire after adding
									if (memory && !firing) {
										firingIndex = list.length - 1;
										queue.push(memory);
									}

									(function add(args) {
										jQuery.each(args, function (_, arg) {
											if (isFunction(arg)) {
												if (!options.unique || !self.has(arg)) {
													list.push(arg);
												}
											} else if (arg && arg.length && toType(arg) !== "string") {
												// Inspect recursively
												add(arg);
											}
										});
									})(arguments);

									if (memory && !firing) {
										fire();
									}
								}

								return this;
							},
							// Remove a callback from the list
							remove: function remove() {
								jQuery.each(arguments, function (_, arg) {
									var index;

									while ((index = jQuery.inArray(arg, list, index)) > -1) {
										list.splice(index, 1); // Handle firing indexes

										if (index <= firingIndex) {
											firingIndex--;
										}
									}
								});
								return this;
							},
							// Check if a given callback is in the list.
							// If no argument is given, return whether or not list has callbacks attached.
							has: function has(fn) {
								return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
							},
							// Remove all callbacks from the list
							empty: function empty() {
								if (list) {
									list = [];
								}

								return this;
							},
							// Disable .fire and .add
							// Abort any current/pending executions
							// Clear all callbacks and values
							disable: function disable() {
								_locked = queue = [];
								list = memory = "";
								return this;
							},
							disabled: function disabled() {
								return !list;
							},
							// Disable .fire
							// Also disable .add unless we have memory (since it would have no effect)
							// Abort any pending executions
							lock: function lock() {
								_locked = queue = [];

								if (!memory && !firing) {
									list = memory = "";
								}

								return this;
							},
							locked: function locked() {
								return !!_locked;
							},
							// Call all callbacks with the given context and arguments
							fireWith: function fireWith(context, args) {
								if (!_locked) {
									args = args || [];
									args = [context, args.slice ? args.slice() : args];
									queue.push(args);

									if (!firing) {
										fire();
									}
								}

								return this;
							},
							// Call all the callbacks with the given arguments
							fire: function fire() {
								self.fireWith(this, arguments);
								return this;
							},
							// To know if the callbacks have already been called at least once
							fired: function fired() {
								return !!_fired;
							}
						};

					return self;
				};

				function Identity(v) {
					return v;
				}

				function Thrower(ex) {
					throw ex;
				}

				function adoptValue(value, resolve, reject, noValue) {
					var method;

					try {
						// Check for promise aspect first to privilege synchronous behavior
						if (value && isFunction(method = value.promise)) {
							method.call(value).done(resolve).fail(reject); // Other thenables
						} else if (value && isFunction(method = value.then)) {
							method.call(value, resolve, reject); // Other non-thenables
						} else {
							// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
							// * false: [ value ].slice( 0 ) => resolve( value )
							// * true: [ value ].slice( 1 ) => resolve()
							resolve.apply(undefined, [value].slice(noValue));
						} // For Promises/A+, convert exceptions into rejections
						// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
						// Deferred#then to conditionally suppress rejection.

					} catch (value) {
						// Support: Android 4.0 only
						// Strict mode functions invoked without .call/.apply get global-object context
						reject.apply(undefined, [value]);
					}
				}

				jQuery.extend({
					Deferred: function Deferred(func) {
						var tuples = [// action, add listener, callbacks,
								// ... .then handlers, argument index, [final state]
								["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
							_state = "pending",
							_promise = {
								state: function state() {
									return _state;
								},
								always: function always() {
									deferred.done(arguments).fail(arguments);
									return this;
								},
								"catch": function _catch(fn) {
									return _promise.then(null, fn);
								},
								// Keep pipe for back-compat
								pipe: function pipe()
									/* fnDone, fnFail, fnProgress */ {
									var fns = arguments;
									return jQuery.Deferred(function (newDefer) {
										jQuery.each(tuples, function (_i, tuple) {
											// Map tuples (progress, done, fail) to arguments (done, fail, progress)
											var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
											// deferred.done(function() { bind to newDefer or newDefer.resolve })
											// deferred.fail(function() { bind to newDefer or newDefer.reject })

											deferred[tuple[1]](function () {
												var returned = fn && fn.apply(this, arguments);

												if (returned && isFunction(returned.promise)) {
													returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
												} else {
													newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
												}
											});
										});
										fns = null;
									}).promise();
								},
								then: function then(onFulfilled, onRejected, onProgress) {
									var maxDepth = 0;

									function resolve(depth, deferred, handler, special) {
										return function () {
											var that = this,
												args = arguments,
												mightThrow = function mightThrow() {
													var returned, then; // Support: Promises/A+ section 2.3.3.3.3
													// https://promisesaplus.com/#point-59
													// Ignore double-resolution attempts

													if (depth < maxDepth) {
														return;
													}

													returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
													// https://promisesaplus.com/#point-48

													if (returned === deferred.promise()) {
														throw new TypeError("Thenable self-resolution");
													} // Support: Promises/A+ sections 2.3.3.1, 3.5
													// https://promisesaplus.com/#point-54
													// https://promisesaplus.com/#point-75
													// Retrieve `then` only once


													then = returned && ( // Support: Promises/A+ section 2.3.4
														// https://promisesaplus.com/#point-64
														// Only check objects and functions for thenability
														_typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

													if (isFunction(then)) {
														// Special processors (notify) just wait for resolution
														if (special) {
															then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
														} else {
															// ...and disregard older resolution values
															maxDepth++;
															then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
														} // Handle all other returned values

													} else {
														// Only substitute handlers pass on context
														// and multiple values (non-spec behavior)
														if (handler !== Identity) {
															that = undefined;
															args = [returned];
														} // Process the value(s)
														// Default process is resolve


														(special || deferred.resolveWith)(that, args);
													}
												},
												// Only normal processors (resolve) catch and reject exceptions
												process = special ? mightThrow : function () {
													try {
														mightThrow();
													} catch (e) {
														if (jQuery.Deferred.exceptionHook) {
															jQuery.Deferred.exceptionHook(e, process.stackTrace);
														} // Support: Promises/A+ section 2.3.3.3.4.1
														// https://promisesaplus.com/#point-61
														// Ignore post-resolution exceptions


														if (depth + 1 >= maxDepth) {
															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if (handler !== Thrower) {
																that = undefined;
																args = [e];
															}

															deferred.rejectWith(that, args);
														}
													}
												}; // Support: Promises/A+ section 2.3.3.3.1
											// https://promisesaplus.com/#point-57
											// Re-resolve promises immediately to dodge false rejection from
											// subsequent errors


											if (depth) {
												process();
											} else {
												// Call an optional hook to record the stack, in case of exception
												// since it's otherwise lost when execution goes async
												if (jQuery.Deferred.getStackHook) {
													process.stackTrace = jQuery.Deferred.getStackHook();
												}

												window.setTimeout(process);
											}
										};
									}

									return jQuery.Deferred(function (newDefer) {
										// progress_handlers.add( ... )
										tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

										tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

										tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
									}).promise();
								},
								// Get a promise for this deferred
								// If obj is provided, the promise aspect is added to the object
								promise: function promise(obj) {
									return obj != null ? jQuery.extend(obj, _promise) : _promise;
								}
							},
							deferred = {}; // Add list-specific methods

						jQuery.each(tuples, function (i, tuple) {
							var list = tuple[2],
								stateString = tuple[5]; // promise.progress = list.add
							// promise.done = list.add
							// promise.fail = list.add

							_promise[tuple[1]] = list.add; // Handle state

							if (stateString) {
								list.add(function () {
										// state = "resolved" (i.e., fulfilled)
										// state = "rejected"
										_state = stateString;
									}, // rejected_callbacks.disable
									// fulfilled_callbacks.disable
									tuples[3 - i][2].disable, // rejected_handlers.disable
									// fulfilled_handlers.disable
									tuples[3 - i][3].disable, // progress_callbacks.lock
									tuples[0][2].lock, // progress_handlers.lock
									tuples[0][3].lock);
							} // progress_handlers.fire
							// fulfilled_handlers.fire
							// rejected_handlers.fire


							list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
							// deferred.resolve = function() { deferred.resolveWith(...) }
							// deferred.reject = function() { deferred.rejectWith(...) }

							deferred[tuple[0]] = function () {
								deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
								return this;
							}; // deferred.notifyWith = list.fireWith
							// deferred.resolveWith = list.fireWith
							// deferred.rejectWith = list.fireWith


							deferred[tuple[0] + "With"] = list.fireWith;
						}); // Make the deferred a promise

						_promise.promise(deferred); // Call given func if any


						if (func) {
							func.call(deferred, deferred);
						} // All done!


						return deferred;
					},
					// Deferred helper
					when: function when(singleValue) {
						var // count of uncompleted subordinates
							remaining = arguments.length,
							// count of unprocessed arguments
							i = remaining,
							// subordinate fulfillment data
							resolveContexts = Array(i),
							resolveValues = _slice.call(arguments),
							// the master Deferred
							master = jQuery.Deferred(),
							// subordinate callback factory
							updateFunc = function updateFunc(i) {
								return function (value) {
									resolveContexts[i] = this;
									resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

									if (!--remaining) {
										master.resolveWith(resolveContexts, resolveValues);
									}
								};
							}; // Single- and empty arguments are adopted like Promise.resolve


						if (remaining <= 1) {
							adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

							if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
								return master.then();
							}
						} // Multiple arguments are aggregated like Promise.all array elements


						while (i--) {
							adoptValue(resolveValues[i], updateFunc(i), master.reject);
						}

						return master.promise();
					}
				}); // These usually indicate a programmer mistake during development,
				// warn about them ASAP rather than swallowing them by default.

				var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

				jQuery.Deferred.exceptionHook = function (error, stack) {
					// Support: IE 8 - 9 only
					// Console exists when dev tools are open, which can happen at any time
					if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
						window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
					}
				};

				jQuery.readyException = function (error) {
					window.setTimeout(function () {
						throw error;
					});
				}; // The deferred used on DOM ready


				var readyList = jQuery.Deferred();

				jQuery.fn.ready = function (fn) {
					readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
						// happens at the time of error handling instead of callback
						// registration.
						["catch"](function (error) {
						jQuery.readyException(error);
					});
					return this;
				};

				jQuery.extend({
					// Is the DOM ready to be used? Set to true once it occurs.
					isReady: false,
					// A counter to track how many items to wait for before
					// the ready event fires. See #6781
					readyWait: 1,
					// Handle when the DOM is ready
					ready: function ready(wait) {
						// Abort if there are pending holds or we're already ready
						if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
							return;
						} // Remember that the DOM is ready


						jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

						if (wait !== true && --jQuery.readyWait > 0) {
							return;
						} // If there are functions bound, to execute


						readyList.resolveWith(document, [jQuery]);
					}
				});
				jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

				function completed() {
					document.removeEventListener("DOMContentLoaded", completed);
					window.removeEventListener("load", completed);
					jQuery.ready();
				} // Catch cases where $(document).ready() is called
				// after the browser event has already occurred.
				// Support: IE <=9 - 10 only
				// Older IE sometimes signals "interactive" too soon


				if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
					// Handle it asynchronously to allow scripts the opportunity to delay ready
					window.setTimeout(jQuery.ready);
				} else {
					// Use the handy event callback
					document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

					window.addEventListener("load", completed);
				} // Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function


				var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
					var i = 0,
						len = elems.length,
						bulk = key == null; // Sets many values

					if (toType(key) === "object") {
						chainable = true;

						for (i in key) {
							access(elems, fn, i, key[i], true, emptyGet, raw);
						} // Sets one value

					} else if (value !== undefined) {
						chainable = true;

						if (!isFunction(value)) {
							raw = true;
						}

						if (bulk) {
							// Bulk operations run against the entire set
							if (raw) {
								fn.call(elems, value);
								fn = null; // ...except when executing function values
							} else {
								bulk = fn;

								fn = function fn(elem, _key, value) {
									return bulk.call(jQuery(elem), value);
								};
							}
						}

						if (fn) {
							for (; i < len; i++) {
								fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
							}
						}
					}

					if (chainable) {
						return elems;
					} // Gets


					if (bulk) {
						return fn.call(elems);
					}

					return len ? fn(elems[0], key) : emptyGet;
				}; // Matches dashed string for camelizing


				var rmsPrefix = /^-ms-/,
					rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

				function fcamelCase(_all, letter) {
					return letter.toUpperCase();
				} // Convert dashed to camelCase; used by the css and data modules
				// Support: IE <=9 - 11, Edge 12 - 15
				// Microsoft forgot to hump their vendor prefix (#9572)


				function camelCase(string) {
					return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
				}

				var acceptData = function acceptData(owner) {
					// Accepts only:
					//  - Node
					//    - Node.ELEMENT_NODE
					//    - Node.DOCUMENT_NODE
					//  - Object
					//    - Any
					return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
				};

				function Data() {
					this.expando = jQuery.expando + Data.uid++;
				}

				Data.uid = 1;
				Data.prototype = {
					cache: function cache(owner) {
						// Check if the owner object already has a cache
						var value = owner[this.expando]; // If not, create one

						if (!value) {
							value = {}; // We can accept data for non-element nodes in modern browsers,
							// but we should not, see #8335.
							// Always return an empty object.

							if (acceptData(owner)) {
								// If it is a node unlikely to be stringify-ed or looped over
								// use plain assignment
								if (owner.nodeType) {
									owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
									// configurable must be true to allow the property to be
									// deleted when data is removed
								} else {
									Object.defineProperty(owner, this.expando, {
										value: value,
										configurable: true
									});
								}
							}
						}

						return value;
					},
					set: function set(owner, data, value) {
						var prop,
							cache = this.cache(owner); // Handle: [ owner, key, value ] args
						// Always use camelCase key (gh-2257)

						if (typeof data === "string") {
							cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
						} else {
							// Copy the properties one-by-one to the cache object
							for (prop in data) {
								cache[camelCase(prop)] = data[prop];
							}
						}

						return cache;
					},
					get: function get(owner, key) {
						return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
							owner[this.expando] && owner[this.expando][camelCase(key)];
					},
					access: function access(owner, key, value) {
						// In cases where either:
						//
						//   1. No key was specified
						//   2. A string key was specified, but no value provided
						//
						// Take the "read" path and allow the get method to determine
						// which value to return, respectively either:
						//
						//   1. The entire cache object
						//   2. The data stored at the key
						//
						if (key === undefined || key && typeof key === "string" && value === undefined) {
							return this.get(owner, key);
						} // When the key is not a string, or both a key and value
						// are specified, set or extend (existing objects) with either:
						//
						//   1. An object of properties
						//   2. A key and value
						//


						this.set(owner, key, value); // Since the "set" path can have two possible entry points
						// return the expected data based on which path was taken[*]

						return value !== undefined ? value : key;
					},
					remove: function remove(owner, key) {
						var i,
							cache = owner[this.expando];

						if (cache === undefined) {
							return;
						}

						if (key !== undefined) {
							// Support array or space separated string of keys
							if (Array.isArray(key)) {
								// If key is an array of keys...
								// We always set camelCase keys, so remove that.
								key = key.map(camelCase);
							} else {
								key = camelCase(key); // If a key with the spaces exists, use it.
								// Otherwise, create an array by matching non-whitespace

								key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
							}

							i = key.length;

							while (i--) {
								delete cache[key[i]];
							}
						} // Remove the expando if there's no more data


						if (key === undefined || jQuery.isEmptyObject(cache)) {
							// Support: Chrome <=35 - 45
							// Webkit & Blink performance suffers when deleting properties
							// from DOM nodes, so set to undefined instead
							// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
							if (owner.nodeType) {
								owner[this.expando] = undefined;
							} else {
								delete owner[this.expando];
							}
						}
					},
					hasData: function hasData(owner) {
						var cache = owner[this.expando];
						return cache !== undefined && !jQuery.isEmptyObject(cache);
					}
				};
				var dataPriv = new Data();
				var dataUser = new Data(); //	Implementation Summary
				//
				//	1. Enforce API surface and semantic compatibility with 1.9.x branch
				//	2. Improve the module's maintainability by reducing the storage
				//		paths to a single mechanism.
				//	3. Use the same single mechanism to support "private" and "user" data.
				//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
				//	5. Avoid exposing implementation details on user objects (eg. expando properties)
				//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
					rmultiDash = /[A-Z]/g;

				function getData(data) {
					if (data === "true") {
						return true;
					}

					if (data === "false") {
						return false;
					}

					if (data === "null") {
						return null;
					} // Only convert to a number if it doesn't change the string


					if (data === +data + "") {
						return +data;
					}

					if (rbrace.test(data)) {
						return JSON.parse(data);
					}

					return data;
				}

				function dataAttr(elem, key, data) {
					var name; // If nothing was found internally, try to fetch any
					// data from the HTML5 data-* attribute

					if (data === undefined && elem.nodeType === 1) {
						name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
						data = elem.getAttribute(name);

						if (typeof data === "string") {
							try {
								data = getData(data);
							} catch (e) {
							} // Make sure we set the data so it isn't changed later


							dataUser.set(elem, key, data);
						} else {
							data = undefined;
						}
					}

					return data;
				}

				jQuery.extend({
					hasData: function hasData(elem) {
						return dataUser.hasData(elem) || dataPriv.hasData(elem);
					},
					data: function data(elem, name, _data) {
						return dataUser.access(elem, name, _data);
					},
					removeData: function removeData(elem, name) {
						dataUser.remove(elem, name);
					},
					// TODO: Now that all calls to _data and _removeData have been replaced
					// with direct calls to dataPriv methods, these can be deprecated.
					_data: function _data(elem, name, data) {
						return dataPriv.access(elem, name, data);
					},
					_removeData: function _removeData(elem, name) {
						dataPriv.remove(elem, name);
					}
				});
				jQuery.fn.extend({
					data: function data(key, value) {
						var i,
							name,
							data,
							elem = this[0],
							attrs = elem && elem.attributes; // Gets all values

						if (key === undefined) {
							if (this.length) {
								data = dataUser.get(elem);

								if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
									i = attrs.length;

									while (i--) {
										// Support: IE 11 only
										// The attrs elements can be null (#14894)
										if (attrs[i]) {
											name = attrs[i].name;

											if (name.indexOf("data-") === 0) {
												name = camelCase(name.slice(5));
												dataAttr(elem, name, data[name]);
											}
										}
									}

									dataPriv.set(elem, "hasDataAttrs", true);
								}
							}

							return data;
						} // Sets multiple values


						if (_typeof(key) === "object") {
							return this.each(function () {
								dataUser.set(this, key);
							});
						}

						return access(this, function (value) {
							var data; // The calling jQuery object (element matches) is not empty
							// (and therefore has an element appears at this[ 0 ]) and the
							// `value` parameter was not undefined. An empty jQuery object
							// will result in `undefined` for elem = this[ 0 ] which will
							// throw an exception if an attempt to read a data cache is made.

							if (elem && value === undefined) {
								// Attempt to get data from the cache
								// The key will always be camelCased in Data
								data = dataUser.get(elem, key);

								if (data !== undefined) {
									return data;
								} // Attempt to "discover" the data in
								// HTML5 custom data-* attrs


								data = dataAttr(elem, key);

								if (data !== undefined) {
									return data;
								} // We tried really hard, but the data doesn't exist.


								return;
							} // Set the data...


							this.each(function () {
								// We always store the camelCased key
								dataUser.set(this, key, value);
							});
						}, null, value, arguments.length > 1, null, true);
					},
					removeData: function removeData(key) {
						return this.each(function () {
							dataUser.remove(this, key);
						});
					}
				});
				jQuery.extend({
					queue: function queue(elem, type, data) {
						var queue;

						if (elem) {
							type = (type || "fx") + "queue";
							queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

							if (data) {
								if (!queue || Array.isArray(data)) {
									queue = dataPriv.access(elem, type, jQuery.makeArray(data));
								} else {
									queue.push(data);
								}
							}

							return queue || [];
						}
					},
					dequeue: function dequeue(elem, type) {
						type = type || "fx";

						var queue = jQuery.queue(elem, type),
							startLength = queue.length,
							fn = queue.shift(),
							hooks = jQuery._queueHooks(elem, type),
							next = function next() {
								jQuery.dequeue(elem, type);
							}; // If the fx queue is dequeued, always remove the progress sentinel


						if (fn === "inprogress") {
							fn = queue.shift();
							startLength--;
						}

						if (fn) {
							// Add a progress sentinel to prevent the fx queue from being
							// automatically dequeued
							if (type === "fx") {
								queue.unshift("inprogress");
							} // Clear up the last queue stop function


							delete hooks.stop;
							fn.call(elem, next, hooks);
						}

						if (!startLength && hooks) {
							hooks.empty.fire();
						}
					},
					// Not public - generate a queueHooks object, or return the current one
					_queueHooks: function _queueHooks(elem, type) {
						var key = type + "queueHooks";
						return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
							empty: jQuery.Callbacks("once memory").add(function () {
								dataPriv.remove(elem, [type + "queue", key]);
							})
						});
					}
				});
				jQuery.fn.extend({
					queue: function queue(type, data) {
						var setter = 2;

						if (typeof type !== "string") {
							data = type;
							type = "fx";
							setter--;
						}

						if (arguments.length < setter) {
							return jQuery.queue(this[0], type);
						}

						return data === undefined ? this : this.each(function () {
							var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

							jQuery._queueHooks(this, type);

							if (type === "fx" && queue[0] !== "inprogress") {
								jQuery.dequeue(this, type);
							}
						});
					},
					dequeue: function dequeue(type) {
						return this.each(function () {
							jQuery.dequeue(this, type);
						});
					},
					clearQueue: function clearQueue(type) {
						return this.queue(type || "fx", []);
					},
					// Get a promise resolved when queues of a certain type
					// are emptied (fx is the type by default)
					promise: function promise(type, obj) {
						var tmp,
							count = 1,
							defer = jQuery.Deferred(),
							elements = this,
							i = this.length,
							resolve = function resolve() {
								if (!--count) {
									defer.resolveWith(elements, [elements]);
								}
							};

						if (typeof type !== "string") {
							obj = type;
							type = undefined;
						}

						type = type || "fx";

						while (i--) {
							tmp = dataPriv.get(elements[i], type + "queueHooks");

							if (tmp && tmp.empty) {
								count++;
								tmp.empty.add(resolve);
							}
						}

						resolve();
						return defer.promise(obj);
					}
				});
				var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
				var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
				var cssExpand = ["Top", "Right", "Bottom", "Left"];
				var documentElement = document.documentElement;

				var isAttached = function isAttached(elem) {
						return jQuery.contains(elem.ownerDocument, elem);
					},
					composed = {
						composed: true
					}; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
				// Check attachment across shadow DOM boundaries when possible (gh-3504)
				// Support: iOS 10.0-10.2 only
				// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
				// leading to errors. We need to check for `getRootNode`.


				if (documentElement.getRootNode) {
					isAttached = function isAttached(elem) {
						return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
					};
				}

				var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
					// isHiddenWithinTree might be called from jQuery#filter function;
					// in that case, element will be second argument
					elem = el || elem; // Inline style trumps all

					return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
						// Support: Firefox <=43 - 45
						// Disconnected elements can have computed display: none, so first confirm that elem is
						// in the document.
						isAttached(elem) && jQuery.css(elem, "display") === "none";
				};

				function adjustCSS(elem, prop, valueParts, tween) {
					var adjusted,
						scale,
						maxIterations = 20,
						currentValue = tween ? function () {
							return tween.cur();
						} : function () {
							return jQuery.css(elem, prop, "");
						},
						initial = currentValue(),
						unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
						// Starting value computation is required for potential unit mismatches
						initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

					if (initialInUnit && initialInUnit[3] !== unit) {
						// Support: Firefox <=54
						// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
						initial = initial / 2; // Trust units reported by jQuery.css

						unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

						initialInUnit = +initial || 1;

						while (maxIterations--) {
							// Evaluate and update our best guess (doubling guesses that zero out).
							// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
							jQuery.style(elem, prop, initialInUnit + unit);

							if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
								maxIterations = 0;
							}

							initialInUnit = initialInUnit / scale;
						}

						initialInUnit = initialInUnit * 2;
						jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

						valueParts = valueParts || [];
					}

					if (valueParts) {
						initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

						adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

						if (tween) {
							tween.unit = unit;
							tween.start = initialInUnit;
							tween.end = adjusted;
						}
					}

					return adjusted;
				}

				var defaultDisplayMap = {};

				function getDefaultDisplay(elem) {
					var temp,
						doc = elem.ownerDocument,
						nodeName = elem.nodeName,
						display = defaultDisplayMap[nodeName];

					if (display) {
						return display;
					}

					temp = doc.body.appendChild(doc.createElement(nodeName));
					display = jQuery.css(temp, "display");
					temp.parentNode.removeChild(temp);

					if (display === "none") {
						display = "block";
					}

					defaultDisplayMap[nodeName] = display;
					return display;
				}

				function showHide(elements, show) {
					var display,
						elem,
						values = [],
						index = 0,
						length = elements.length; // Determine new display value for elements that need to change

					for (; index < length; index++) {
						elem = elements[index];

						if (!elem.style) {
							continue;
						}

						display = elem.style.display;

						if (show) {
							// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
							// check is required in this first loop unless we have a nonempty display value (either
							// inline or about-to-be-restored)
							if (display === "none") {
								values[index] = dataPriv.get(elem, "display") || null;

								if (!values[index]) {
									elem.style.display = "";
								}
							}

							if (elem.style.display === "" && isHiddenWithinTree(elem)) {
								values[index] = getDefaultDisplay(elem);
							}
						} else {
							if (display !== "none") {
								values[index] = "none"; // Remember what we're overwriting

								dataPriv.set(elem, "display", display);
							}
						}
					} // Set the display of the elements in a second loop to avoid constant reflow


					for (index = 0; index < length; index++) {
						if (values[index] != null) {
							elements[index].style.display = values[index];
						}
					}

					return elements;
				}

				jQuery.fn.extend({
					show: function show() {
						return showHide(this, true);
					},
					hide: function hide() {
						return showHide(this);
					},
					toggle: function toggle(state) {
						if (typeof state === "boolean") {
							return state ? this.show() : this.hide();
						}

						return this.each(function () {
							if (isHiddenWithinTree(this)) {
								jQuery(this).show();
							} else {
								jQuery(this).hide();
							}
						});
					}
				});
				var rcheckableType = /^(?:checkbox|radio)$/i;
				var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
				var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

				(function () {
					var fragment = document.createDocumentFragment(),
						div = fragment.appendChild(document.createElement("div")),
						input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
					// Check state lost if the name is set (#11217)
					// Support: Windows Web Apps (WWA)
					// `name` and `type` must use .setAttribute for WWA (#14901)

					input.setAttribute("type", "radio");
					input.setAttribute("checked", "checked");
					input.setAttribute("name", "t");
					div.appendChild(input); // Support: Android <=4.1 only
					// Older WebKit doesn't clone checked state correctly in fragments

					support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
					// Make sure textarea (and checkbox) defaultValue is properly cloned

					div.innerHTML = "<textarea>x</textarea>";
					support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
					// IE <=9 replaces <option> tags with their contents when inserted outside of
					// the select element.

					div.innerHTML = "<option></option>";
					support.option = !!div.lastChild;
				})(); // We have to close these tags to support XHTML (#13200)


				var wrapMap = {
					// XHTML parsers do not magically insert elements in the
					// same way that tag soup parsers do. So we cannot shorten
					// this by omitting <tbody> or other required elements.
					thead: [1, "<table>", "</table>"],
					col: [2, "<table><colgroup>", "</colgroup></table>"],
					tr: [2, "<table><tbody>", "</tbody></table>"],
					td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
					_default: [0, "", ""]
				};
				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td; // Support: IE <=9 only

				if (!support.option) {
					wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
				}

				function getAll(context, tag) {
					// Support: IE <=9 - 11 only
					// Use typeof to avoid zero-argument method invocation on host objects (#15151)
					var ret;

					if (typeof context.getElementsByTagName !== "undefined") {
						ret = context.getElementsByTagName(tag || "*");
					} else if (typeof context.querySelectorAll !== "undefined") {
						ret = context.querySelectorAll(tag || "*");
					} else {
						ret = [];
					}

					if (tag === undefined || tag && nodeName(context, tag)) {
						return jQuery.merge([context], ret);
					}

					return ret;
				} // Mark scripts as having already been evaluated


				function setGlobalEval(elems, refElements) {
					var i = 0,
						l = elems.length;

					for (; i < l; i++) {
						dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
					}
				}

				var rhtml = /<|&#?\w+;/;

				function buildFragment(elems, context, scripts, selection, ignored) {
					var elem,
						tmp,
						tag,
						wrap,
						attached,
						j,
						fragment = context.createDocumentFragment(),
						nodes = [],
						i = 0,
						l = elems.length;

					for (; i < l; i++) {
						elem = elems[i];

						if (elem || elem === 0) {
							// Add nodes directly
							if (toType(elem) === "object") {
								// Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
							} else if (!rhtml.test(elem)) {
								nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
							} else {
								tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

								tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
								wrap = wrapMap[tag] || wrapMap._default;
								tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

								j = wrap[0];

								while (j--) {
									tmp = tmp.lastChild;
								} // Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit


								jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

								tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

								tmp.textContent = "";
							}
						}
					} // Remove wrapper from fragment


					fragment.textContent = "";
					i = 0;

					while (elem = nodes[i++]) {
						// Skip elements already in the context collection (trac-4087)
						if (selection && jQuery.inArray(elem, selection) > -1) {
							if (ignored) {
								ignored.push(elem);
							}

							continue;
						}

						attached = isAttached(elem); // Append to fragment

						tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

						if (attached) {
							setGlobalEval(tmp);
						} // Capture executables


						if (scripts) {
							j = 0;

							while (elem = tmp[j++]) {
								if (rscriptType.test(elem.type || "")) {
									scripts.push(elem);
								}
							}
						}
					}

					return fragment;
				}

				var rkeyEvent = /^key/,
					rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
					rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

				function returnTrue() {
					return true;
				}

				function returnFalse() {
					return false;
				} // Support: IE <=9 - 11+
				// focus() and blur() are asynchronous, except when they are no-op.
				// So expect focus to be synchronous when the element is already active,
				// and blur to be synchronous when the element is not already active.
				// (focus and blur are always synchronous in other supported browsers,
				// this just defines when we can count on it).


				function expectSync(elem, type) {
					return elem === safeActiveElement() === (type === "focus");
				} // Support: IE <=9 only
				// Accessing document.activeElement can throw unexpectedly
				// https://bugs.jquery.com/ticket/13393


				function safeActiveElement() {
					try {
						return document.activeElement;
					} catch (err) {
					}
				}

				function _on(elem, types, selector, data, fn, one) {
					var origFn, type; // Types can be a map of types/handlers

					if (_typeof(types) === "object") {
						// ( types-Object, selector, data )
						if (typeof selector !== "string") {
							// ( types-Object, data )
							data = data || selector;
							selector = undefined;
						}

						for (type in types) {
							_on(elem, type, selector, data, types[type], one);
						}

						return elem;
					}

					if (data == null && fn == null) {
						// ( types, fn )
						fn = selector;
						data = selector = undefined;
					} else if (fn == null) {
						if (typeof selector === "string") {
							// ( types, selector, fn )
							fn = data;
							data = undefined;
						} else {
							// ( types, data, fn )
							fn = data;
							data = selector;
							selector = undefined;
						}
					}

					if (fn === false) {
						fn = returnFalse;
					} else if (!fn) {
						return elem;
					}

					if (one === 1) {
						origFn = fn;

						fn = function fn(event) {
							// Can use an empty set, since event contains the info
							jQuery().off(event);
							return origFn.apply(this, arguments);
						}; // Use same guid so caller can remove using origFn


						fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
					}

					return elem.each(function () {
						jQuery.event.add(this, types, fn, data, selector);
					});
				}

				/*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


				jQuery.event = {
					global: {},
					add: function add(elem, types, handler, data, selector) {
						var handleObjIn,
							eventHandle,
							tmp,
							events,
							t,
							handleObj,
							special,
							handlers,
							type,
							namespaces,
							origType,
							elemData = dataPriv.get(elem); // Only attach events to objects that accept data

						if (!acceptData(elem)) {
							return;
						} // Caller can pass in an object of custom data in lieu of the handler


						if (handler.handler) {
							handleObjIn = handler;
							handler = handleObjIn.handler;
							selector = handleObjIn.selector;
						} // Ensure that invalid selectors throw exceptions at attach time
						// Evaluate against documentElement in case elem is a non-element node (e.g., document)


						if (selector) {
							jQuery.find.matchesSelector(documentElement, selector);
						} // Make sure that the handler has a unique ID, used to find/remove it later


						if (!handler.guid) {
							handler.guid = jQuery.guid++;
						} // Init the element's event structure and main handler, if this is the first


						if (!(events = elemData.events)) {
							events = elemData.events = Object.create(null);
						}

						if (!(eventHandle = elemData.handle)) {
							eventHandle = elemData.handle = function (e) {
								// Discard the second event of a jQuery.event.trigger() and
								// when an event is called after a page has unloaded
								return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
							};
						} // Handle multiple events separated by a space


						types = (types || "").match(rnothtmlwhite) || [""];
						t = types.length;

						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

							if (!type) {
								continue;
							} // If event changes its type, use the special event handlers for the changed type


							special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

							type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

							special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

							handleObj = jQuery.extend({
								type: type,
								origType: origType,
								data: data,
								handler: handler,
								guid: handler.guid,
								selector: selector,
								needsContext: selector && jQuery.expr.match.needsContext.test(selector),
								namespace: namespaces.join(".")
							}, handleObjIn); // Init the event handler queue if we're the first

							if (!(handlers = events[type])) {
								handlers = events[type] = [];
								handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

								if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
									if (elem.addEventListener) {
										elem.addEventListener(type, eventHandle);
									}
								}
							}

							if (special.add) {
								special.add.call(elem, handleObj);

								if (!handleObj.handler.guid) {
									handleObj.handler.guid = handler.guid;
								}
							} // Add to the element's handler list, delegates in front


							if (selector) {
								handlers.splice(handlers.delegateCount++, 0, handleObj);
							} else {
								handlers.push(handleObj);
							} // Keep track of which events have ever been used, for event optimization


							jQuery.event.global[type] = true;
						}
					},
					// Detach an event or set of events from an element
					remove: function remove(elem, types, handler, selector, mappedTypes) {
						var j,
							origCount,
							tmp,
							events,
							t,
							handleObj,
							special,
							handlers,
							type,
							namespaces,
							origType,
							elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

						if (!elemData || !(events = elemData.events)) {
							return;
						} // Once for each type.namespace in types; type may be omitted


						types = (types || "").match(rnothtmlwhite) || [""];
						t = types.length;

						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

							if (!type) {
								for (type in events) {
									jQuery.event.remove(elem, type + types[t], handler, selector, true);
								}

								continue;
							}

							special = jQuery.event.special[type] || {};
							type = (selector ? special.delegateType : special.bindType) || type;
							handlers = events[type] || [];
							tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

							origCount = j = handlers.length;

							while (j--) {
								handleObj = handlers[j];

								if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
									handlers.splice(j, 1);

									if (handleObj.selector) {
										handlers.delegateCount--;
									}

									if (special.remove) {
										special.remove.call(elem, handleObj);
									}
								}
							} // Remove generic event handler if we removed something and no more handlers exist
							// (avoids potential for endless recursion during removal of special event handlers)


							if (origCount && !handlers.length) {
								if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
									jQuery.removeEvent(elem, type, elemData.handle);
								}

								delete events[type];
							}
						} // Remove data and the expando if it's no longer used


						if (jQuery.isEmptyObject(events)) {
							dataPriv.remove(elem, "handle events");
						}
					},
					dispatch: function dispatch(nativeEvent) {
						var i,
							j,
							ret,
							matched,
							handleObj,
							handlerQueue,
							args = new Array(arguments.length),
							// Make a writable jQuery.Event from the native event object
							event = jQuery.event.fix(nativeEvent),
							handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
							special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

						args[0] = event;

						for (i = 1; i < arguments.length; i++) {
							args[i] = arguments[i];
						}

						event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

						if (special.preDispatch && special.preDispatch.call(this, event) === false) {
							return;
						} // Determine handlers


						handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

						i = 0;

						while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
							event.currentTarget = matched.elem;
							j = 0;

							while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
								// If the event is namespaced, then each handler is only invoked if it is
								// specially universal or its namespaces are a superset of the event's.
								if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
									event.handleObj = handleObj;
									event.data = handleObj.data;
									ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

									if (ret !== undefined) {
										if ((event.result = ret) === false) {
											event.preventDefault();
											event.stopPropagation();
										}
									}
								}
							}
						} // Call the postDispatch hook for the mapped type


						if (special.postDispatch) {
							special.postDispatch.call(this, event);
						}

						return event.result;
					},
					handlers: function handlers(event, _handlers) {
						var i,
							handleObj,
							sel,
							matchedHandlers,
							matchedSelectors,
							handlerQueue = [],
							delegateCount = _handlers.delegateCount,
							cur = event.target; // Find delegate handlers

						if (delegateCount && // Support: IE <=9
							// Black-hole SVG <use> instance trees (trac-13180)
							cur.nodeType && // Support: Firefox <=42
							// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
							// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
							// Support: IE 11 only
							// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
							!(event.type === "click" && event.button >= 1)) {
							for (; cur !== this; cur = cur.parentNode || this) {
								// Don't check non-elements (#13208)
								// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
								if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
									matchedHandlers = [];
									matchedSelectors = {};

									for (i = 0; i < delegateCount; i++) {
										handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

										sel = handleObj.selector + " ";

										if (matchedSelectors[sel] === undefined) {
											matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
										}

										if (matchedSelectors[sel]) {
											matchedHandlers.push(handleObj);
										}
									}

									if (matchedHandlers.length) {
										handlerQueue.push({
											elem: cur,
											handlers: matchedHandlers
										});
									}
								}
							}
						} // Add the remaining (directly-bound) handlers


						cur = this;

						if (delegateCount < _handlers.length) {
							handlerQueue.push({
								elem: cur,
								handlers: _handlers.slice(delegateCount)
							});
						}

						return handlerQueue;
					},
					addProp: function addProp(name, hook) {
						Object.defineProperty(jQuery.Event.prototype, name, {
							enumerable: true,
							configurable: true,
							get: isFunction(hook) ? function () {
								if (this.originalEvent) {
									return hook(this.originalEvent);
								}
							} : function () {
								if (this.originalEvent) {
									return this.originalEvent[name];
								}
							},
							set: function set(value) {
								Object.defineProperty(this, name, {
									enumerable: true,
									configurable: true,
									writable: true,
									value: value
								});
							}
						});
					},
					fix: function fix(originalEvent) {
						return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
					},
					special: {
						load: {
							// Prevent triggered image.load events from bubbling to window.load
							noBubble: true
						},
						click: {
							// Utilize native event to ensure correct state for checkable inputs
							setup: function setup(data) {
								// For mutual compressibility with _default, replace `this` access with a local var.
								// `|| data` is dead code meant only to preserve the variable through minification.
								var el = this || data; // Claim the first handler

								if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
									// dataPriv.set( el, "click", ... )
									leverageNative(el, "click", returnTrue);
								} // Return false to allow normal processing in the caller


								return false;
							},
							trigger: function trigger(data) {
								// For mutual compressibility with _default, replace `this` access with a local var.
								// `|| data` is dead code meant only to preserve the variable through minification.
								var el = this || data; // Force setup before triggering a click

								if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
									leverageNative(el, "click");
								} // Return non-false to allow normal event-path propagation


								return true;
							},
							// For cross-browser consistency, suppress native .click() on links
							// Also prevent it if we're currently inside a leveraged native-event stack
							_default: function _default(event) {
								var target = event.target;
								return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
							}
						},
						beforeunload: {
							postDispatch: function postDispatch(event) {
								// Support: Firefox 20+
								// Firefox doesn't alert if the returnValue field is not set.
								if (event.result !== undefined && event.originalEvent) {
									event.originalEvent.returnValue = event.result;
								}
							}
						}
					}
				}; // Ensure the presence of an event listener that handles manually-triggered
				// synthetic events by interrupting progress until reinvoked in response to
				// *native* events that it fires directly, ensuring that state changes have
				// already occurred before other listeners are invoked.

				function leverageNative(el, type, expectSync) {
					// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
					if (!expectSync) {
						if (dataPriv.get(el, type) === undefined) {
							jQuery.event.add(el, type, returnTrue);
						}

						return;
					} // Register the controller as a special universal handler for all event namespaces


					dataPriv.set(el, type, false);
					jQuery.event.add(el, type, {
						namespace: false,
						handler: function handler(event) {
							var notAsync,
								result,
								saved = dataPriv.get(this, type);

							if (event.isTrigger & 1 && this[type]) {
								// Interrupt processing of the outer synthetic .trigger()ed event
								// Saved data should be false in such cases, but might be a leftover capture object
								// from an async native handler (gh-4350)
								if (!saved.length) {
									// Store arguments for use when handling the inner native event
									// There will always be at least one argument (an event object), so this array
									// will not be confused with a leftover capture object.
									saved = _slice.call(arguments);
									dataPriv.set(this, type, saved); // Trigger the native event and capture its result
									// Support: IE <=9 - 11+
									// focus() and blur() are asynchronous

									notAsync = expectSync(this, type);
									this[type]();
									result = dataPriv.get(this, type);

									if (saved !== result || notAsync) {
										dataPriv.set(this, type, false);
									} else {
										result = {};
									}

									if (saved !== result) {
										// Cancel the outer synthetic event
										event.stopImmediatePropagation();
										event.preventDefault();
										return result.value;
									} // If this is an inner synthetic event for an event with a bubbling surrogate
									// (focus or blur), assume that the surrogate already propagated from triggering the
									// native event and prevent that from happening again here.
									// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
									// bubbling surrogate propagates *after* the non-bubbling base), but that seems
									// less bad than duplication.

								} else if ((jQuery.event.special[type] || {}).delegateType) {
									event.stopPropagation();
								} // If this is a native event triggered above, everything is now in order
								// Fire an inner synthetic event with the original arguments

							} else if (saved.length) {
								// ...and capture the result
								dataPriv.set(this, type, {
									value: jQuery.event.trigger( // Support: IE <=9 - 11+
										// Extend with the prototype to reset the above stopImmediatePropagation()
										jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
								}); // Abort handling of the native event

								event.stopImmediatePropagation();
							}
						}
					});
				}

				jQuery.removeEvent = function (elem, type, handle) {
					// This "if" is needed for plain objects
					if (elem.removeEventListener) {
						elem.removeEventListener(type, handle);
					}
				};

				jQuery.Event = function (src, props) {
					// Allow instantiation without the 'new' keyword
					if (!(this instanceof jQuery.Event)) {
						return new jQuery.Event(src, props);
					} // Event object


					if (src && src.type) {
						this.originalEvent = src;
						this.type = src.type; // Events bubbling up the document may have been marked as prevented
						// by a handler lower down the tree; reflect the correct value.

						this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
						src.returnValue === false ? returnTrue : returnFalse; // Create target properties
						// Support: Safari <=6 - 7 only
						// Target should not be a text node (#504, #13143)

						this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
						this.currentTarget = src.currentTarget;
						this.relatedTarget = src.relatedTarget; // Event type
					} else {
						this.type = src;
					} // Put explicitly provided properties onto the event object


					if (props) {
						jQuery.extend(this, props);
					} // Create a timestamp if incoming event doesn't have one


					this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

					this[jQuery.expando] = true;
				}; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
				// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


				jQuery.Event.prototype = {
					constructor: jQuery.Event,
					isDefaultPrevented: returnFalse,
					isPropagationStopped: returnFalse,
					isImmediatePropagationStopped: returnFalse,
					isSimulated: false,
					preventDefault: function preventDefault() {
						var e = this.originalEvent;
						this.isDefaultPrevented = returnTrue;

						if (e && !this.isSimulated) {
							e.preventDefault();
						}
					},
					stopPropagation: function stopPropagation() {
						var e = this.originalEvent;
						this.isPropagationStopped = returnTrue;

						if (e && !this.isSimulated) {
							e.stopPropagation();
						}
					},
					stopImmediatePropagation: function stopImmediatePropagation() {
						var e = this.originalEvent;
						this.isImmediatePropagationStopped = returnTrue;

						if (e && !this.isSimulated) {
							e.stopImmediatePropagation();
						}

						this.stopPropagation();
					}
				}; // Includes all common event props including KeyEvent and MouseEvent specific props

				jQuery.each({
					altKey: true,
					bubbles: true,
					cancelable: true,
					changedTouches: true,
					ctrlKey: true,
					detail: true,
					eventPhase: true,
					metaKey: true,
					pageX: true,
					pageY: true,
					shiftKey: true,
					view: true,
					"char": true,
					code: true,
					charCode: true,
					key: true,
					keyCode: true,
					button: true,
					buttons: true,
					clientX: true,
					clientY: true,
					offsetX: true,
					offsetY: true,
					pointerId: true,
					pointerType: true,
					screenX: true,
					screenY: true,
					targetTouches: true,
					toElement: true,
					touches: true,
					which: function which(event) {
						var button = event.button; // Add which for key events

						if (event.which == null && rkeyEvent.test(event.type)) {
							return event.charCode != null ? event.charCode : event.keyCode;
						} // Add which for click: 1 === left; 2 === middle; 3 === right


						if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
							if (button & 1) {
								return 1;
							}

							if (button & 2) {
								return 3;
							}

							if (button & 4) {
								return 2;
							}

							return 0;
						}

						return event.which;
					}
				}, jQuery.event.addProp);
				jQuery.each({
					focus: "focusin",
					blur: "focusout"
				}, function (type, delegateType) {
					jQuery.event.special[type] = {
						// Utilize native event if possible so blur/focus sequence is correct
						setup: function setup() {
							// Claim the first handler
							// dataPriv.set( this, "focus", ... )
							// dataPriv.set( this, "blur", ... )
							leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

							return false;
						},
						trigger: function trigger() {
							// Force setup before trigger
							leverageNative(this, type); // Return non-false to allow normal event-path propagation

							return true;
						},
						delegateType: delegateType
					};
				}); // Create mouseenter/leave events using mouseover/out and event-time checks
				// so that event delegation works in jQuery.
				// Do the same for pointerenter/pointerleave and pointerover/pointerout
				//
				// Support: Safari 7 only
				// Safari sends mouseenter too often; see:
				// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
				// for the description of the bug (it existed in older Chrome versions as well).

				jQuery.each({
					mouseenter: "mouseover",
					mouseleave: "mouseout",
					pointerenter: "pointerover",
					pointerleave: "pointerout"
				}, function (orig, fix) {
					jQuery.event.special[orig] = {
						delegateType: fix,
						bindType: fix,
						handle: function handle(event) {
							var ret,
								target = this,
								related = event.relatedTarget,
								handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
							// NB: No relatedTarget if the mouse left/entered the browser window

							if (!related || related !== target && !jQuery.contains(target, related)) {
								event.type = handleObj.origType;
								ret = handleObj.handler.apply(this, arguments);
								event.type = fix;
							}

							return ret;
						}
					};
				});
				jQuery.fn.extend({
					on: function on(types, selector, data, fn) {
						return _on(this, types, selector, data, fn);
					},
					one: function one(types, selector, data, fn) {
						return _on(this, types, selector, data, fn, 1);
					},
					off: function off(types, selector, fn) {
						var handleObj, type;

						if (types && types.preventDefault && types.handleObj) {
							// ( event )  dispatched jQuery.Event
							handleObj = types.handleObj;
							jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
							return this;
						}

						if (_typeof(types) === "object") {
							// ( types-object [, selector] )
							for (type in types) {
								this.off(type, selector, types[type]);
							}

							return this;
						}

						if (selector === false || typeof selector === "function") {
							// ( types [, fn] )
							fn = selector;
							selector = undefined;
						}

						if (fn === false) {
							fn = returnFalse;
						}

						return this.each(function () {
							jQuery.event.remove(this, types, fn, selector);
						});
					}
				});
				var // Support: IE <=10 - 11, Edge 12 - 13 only
					// In IE/Edge using regex groups here causes severe slowdowns.
					// See https://connect.microsoft.com/IE/feedback/details/1736512/
					rnoInnerhtml = /<script|<style|<link/i,
					// checked="checked" or checked
					rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
					rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

				function manipulationTarget(elem, content) {
					if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
						return jQuery(elem).children("tbody")[0] || elem;
					}

					return elem;
				} // Replace/restore the type attribute of script elements for safe DOM manipulation


				function disableScript(elem) {
					elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
					return elem;
				}

				function restoreScript(elem) {
					if ((elem.type || "").slice(0, 5) === "true/") {
						elem.type = elem.type.slice(5);
					} else {
						elem.removeAttribute("type");
					}

					return elem;
				}

				function cloneCopyEvent(src, dest) {
					var i, l, type, pdataOld, udataOld, udataCur, events;

					if (dest.nodeType !== 1) {
						return;
					} // 1. Copy private data: events, handlers, etc.


					if (dataPriv.hasData(src)) {
						pdataOld = dataPriv.get(src);
						events = pdataOld.events;

						if (events) {
							dataPriv.remove(dest, "handle events");

							for (type in events) {
								for (i = 0, l = events[type].length; i < l; i++) {
									jQuery.event.add(dest, type, events[type][i]);
								}
							}
						}
					} // 2. Copy user data


					if (dataUser.hasData(src)) {
						udataOld = dataUser.access(src);
						udataCur = jQuery.extend({}, udataOld);
						dataUser.set(dest, udataCur);
					}
				} // Fix IE bugs, see support tests


				function fixInput(src, dest) {
					var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

					if (nodeName === "input" && rcheckableType.test(src.type)) {
						dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
					} else if (nodeName === "input" || nodeName === "textarea") {
						dest.defaultValue = src.defaultValue;
					}
				}

				function domManip(collection, args, callback, ignored) {
					// Flatten any nested arrays
					args = flat(args);
					var fragment,
						first,
						scripts,
						hasScripts,
						node,
						doc,
						i = 0,
						l = collection.length,
						iNoClone = l - 1,
						value = args[0],
						valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

					if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
						return collection.each(function (index) {
							var self = collection.eq(index);

							if (valueIsFunction) {
								args[0] = value.call(this, index, self.html());
							}

							domManip(self, args, callback, ignored);
						});
					}

					if (l) {
						fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
						first = fragment.firstChild;

						if (fragment.childNodes.length === 1) {
							fragment = first;
						} // Require either new content or an interest in ignored elements to invoke the callback


						if (first || ignored) {
							scripts = jQuery.map(getAll(fragment, "script"), disableScript);
							hasScripts = scripts.length; // Use the original fragment for the last item
							// instead of the first because it can end up
							// being emptied incorrectly in certain situations (#8070).

							for (; i < l; i++) {
								node = fragment;

								if (i !== iNoClone) {
									node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

									if (hasScripts) {
										// Support: Android <=4.0 only, PhantomJS 1 only
										// push.apply(_, arraylike) throws on ancient WebKit
										jQuery.merge(scripts, getAll(node, "script"));
									}
								}

								callback.call(collection[i], node, i);
							}

							if (hasScripts) {
								doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

								jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

								for (i = 0; i < hasScripts; i++) {
									node = scripts[i];

									if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
										if (node.src && (node.type || "").toLowerCase() !== "module") {
											// Optional AJAX dependency, but won't run scripts if not present
											if (jQuery._evalUrl && !node.noModule) {
												jQuery._evalUrl(node.src, {
													nonce: node.nonce || node.getAttribute("nonce")
												}, doc);
											}
										} else {
											DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
										}
									}
								}
							}
						}
					}

					return collection;
				}

				function _remove(elem, selector, keepData) {
					var node,
						nodes = selector ? jQuery.filter(selector, elem) : elem,
						i = 0;

					for (; (node = nodes[i]) != null; i++) {
						if (!keepData && node.nodeType === 1) {
							jQuery.cleanData(getAll(node));
						}

						if (node.parentNode) {
							if (keepData && isAttached(node)) {
								setGlobalEval(getAll(node, "script"));
							}

							node.parentNode.removeChild(node);
						}
					}

					return elem;
				}

				jQuery.extend({
					htmlPrefilter: function htmlPrefilter(html) {
						return html;
					},
					clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
						var i,
							l,
							srcElements,
							destElements,
							clone = elem.cloneNode(true),
							inPage = isAttached(elem); // Fix IE cloning issues

						if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
							// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
							destElements = getAll(clone);
							srcElements = getAll(elem);

							for (i = 0, l = srcElements.length; i < l; i++) {
								fixInput(srcElements[i], destElements[i]);
							}
						} // Copy the events from the original to the clone


						if (dataAndEvents) {
							if (deepDataAndEvents) {
								srcElements = srcElements || getAll(elem);
								destElements = destElements || getAll(clone);

								for (i = 0, l = srcElements.length; i < l; i++) {
									cloneCopyEvent(srcElements[i], destElements[i]);
								}
							} else {
								cloneCopyEvent(elem, clone);
							}
						} // Preserve script evaluation history


						destElements = getAll(clone, "script");

						if (destElements.length > 0) {
							setGlobalEval(destElements, !inPage && getAll(elem, "script"));
						} // Return the cloned set


						return clone;
					},
					cleanData: function cleanData(elems) {
						var data,
							elem,
							type,
							special = jQuery.event.special,
							i = 0;

						for (; (elem = elems[i]) !== undefined; i++) {
							if (acceptData(elem)) {
								if (data = elem[dataPriv.expando]) {
									if (data.events) {
										for (type in data.events) {
											if (special[type]) {
												jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
											} else {
												jQuery.removeEvent(elem, type, data.handle);
											}
										}
									} // Support: Chrome <=35 - 45+
									// Assign undefined instead of using delete, see Data#remove


									elem[dataPriv.expando] = undefined;
								}

								if (elem[dataUser.expando]) {
									// Support: Chrome <=35 - 45+
									// Assign undefined instead of using delete, see Data#remove
									elem[dataUser.expando] = undefined;
								}
							}
						}
					}
				});
				jQuery.fn.extend({
					detach: function detach(selector) {
						return _remove(this, selector, true);
					},
					remove: function remove(selector) {
						return _remove(this, selector);
					},
					text: function text(value) {
						return access(this, function (value) {
							return value === undefined ? jQuery.text(this) : this.empty().each(function () {
								if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
									this.textContent = value;
								}
							});
						}, null, value, arguments.length);
					},
					append: function append() {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.appendChild(elem);
							}
						});
					},
					prepend: function prepend() {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.insertBefore(elem, target.firstChild);
							}
						});
					},
					before: function before() {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this);
							}
						});
					},
					after: function after() {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this.nextSibling);
							}
						});
					},
					empty: function empty() {
						var elem,
							i = 0;

						for (; (elem = this[i]) != null; i++) {
							if (elem.nodeType === 1) {
								// Prevent memory leaks
								jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

								elem.textContent = "";
							}
						}

						return this;
					},
					clone: function clone(dataAndEvents, deepDataAndEvents) {
						dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
						deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
						return this.map(function () {
							return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
						});
					},
					html: function html(value) {
						return access(this, function (value) {
							var elem = this[0] || {},
								i = 0,
								l = this.length;

							if (value === undefined && elem.nodeType === 1) {
								return elem.innerHTML;
							} // See if we can take a shortcut and just use innerHTML


							if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
								value = jQuery.htmlPrefilter(value);

								try {
									for (; i < l; i++) {
										elem = this[i] || {}; // Remove element nodes and prevent memory leaks

										if (elem.nodeType === 1) {
											jQuery.cleanData(getAll(elem, false));
											elem.innerHTML = value;
										}
									}

									elem = 0; // If using innerHTML throws an exception, use the fallback method
								} catch (e) {
								}
							}

							if (elem) {
								this.empty().append(value);
							}
						}, null, value, arguments.length);
					},
					replaceWith: function replaceWith() {
						var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

						return domManip(this, arguments, function (elem) {
							var parent = this.parentNode;

							if (jQuery.inArray(this, ignored) < 0) {
								jQuery.cleanData(getAll(this));

								if (parent) {
									parent.replaceChild(elem, this);
								}
							} // Force callback invocation

						}, ignored);
					}
				});
				jQuery.each({
					appendTo: "append",
					prependTo: "prepend",
					insertBefore: "before",
					insertAfter: "after",
					replaceAll: "replaceWith"
				}, function (name, original) {
					jQuery.fn[name] = function (selector) {
						var elems,
							ret = [],
							insert = jQuery(selector),
							last = insert.length - 1,
							i = 0;

						for (; i <= last; i++) {
							elems = i === last ? this : this.clone(true);
							jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
							// .get() because push.apply(_, arraylike) throws on ancient WebKit

							push.apply(ret, elems.get());
						}

						return this.pushStack(ret);
					};
				});
				var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

				var getStyles = function getStyles(elem) {
					// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
					// IE throws on elements created in popups
					// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
					var view = elem.ownerDocument.defaultView;

					if (!view || !view.opener) {
						view = window;
					}

					return view.getComputedStyle(elem);
				};

				var swap = function swap(elem, options, callback) {
					var ret,
						name,
						old = {}; // Remember the old values, and insert the new ones

					for (name in options) {
						old[name] = elem.style[name];
						elem.style[name] = options[name];
					}

					ret = callback.call(elem); // Revert the old values

					for (name in options) {
						elem.style[name] = old[name];
					}

					return ret;
				};

				var rboxStyle = new RegExp(cssExpand.join("|"), "i");

				(function () {
					// Executing both pixelPosition & boxSizingReliable tests require only one layout
					// so they're executed at the same time to save the second computation.
					function computeStyleTests() {
						// This is a singleton, we need to execute it only once
						if (!div) {
							return;
						}

						container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
						div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
						documentElement.appendChild(container).appendChild(div);
						var divStyle = window.getComputedStyle(div);
						pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

						reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
						// Some styles come back with percentage values, even though they shouldn't

						div.style.right = "60%";
						pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
						// Detect misreporting of content dimensions for box-sizing:border-box elements

						boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
						// Detect overflow:scroll screwiness (gh-3699)
						// Support: Chrome <=64
						// Don't get tricked when zoom affects offsetWidth (gh-4029)

						div.style.position = "absolute";
						scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
						documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
						// it will also be a sign that checks already performed

						div = null;
					}

					function roundPixelMeasures(measure) {
						return Math.round(parseFloat(measure));
					}

					var pixelPositionVal,
						boxSizingReliableVal,
						scrollboxSizeVal,
						pixelBoxStylesVal,
						reliableTrDimensionsVal,
						reliableMarginLeftVal,
						container = document.createElement("div"),
						div = document.createElement("div"); // Finish early in limited (non-browser) environments

					if (!div.style) {
						return;
					} // Support: IE <=9 - 11 only
					// Style of cloned element affects source element cloned (#8908)


					div.style.backgroundClip = "content-box";
					div.cloneNode(true).style.backgroundClip = "";
					support.clearCloneStyle = div.style.backgroundClip === "content-box";
					jQuery.extend(support, {
						boxSizingReliable: function boxSizingReliable() {
							computeStyleTests();
							return boxSizingReliableVal;
						},
						pixelBoxStyles: function pixelBoxStyles() {
							computeStyleTests();
							return pixelBoxStylesVal;
						},
						pixelPosition: function pixelPosition() {
							computeStyleTests();
							return pixelPositionVal;
						},
						reliableMarginLeft: function reliableMarginLeft() {
							computeStyleTests();
							return reliableMarginLeftVal;
						},
						scrollboxSize: function scrollboxSize() {
							computeStyleTests();
							return scrollboxSizeVal;
						},
						// Support: IE 9 - 11+, Edge 15 - 18+
						// IE/Edge misreport `getComputedStyle` of table rows with width/height
						// set in CSS while `offset*` properties report correct values.
						// Behavior in IE 9 is more subtle than in newer versions & it passes
						// some versions of this test; make sure not to make it pass there!
						reliableTrDimensions: function reliableTrDimensions() {
							var table, tr, trChild, trStyle;

							if (reliableTrDimensionsVal == null) {
								table = document.createElement("table");
								tr = document.createElement("tr");
								trChild = document.createElement("div");
								table.style.cssText = "position:absolute;left:-11111px";
								tr.style.height = "1px";
								trChild.style.height = "9px";
								documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
								trStyle = window.getComputedStyle(tr);
								reliableTrDimensionsVal = parseInt(trStyle.height) > 3;
								documentElement.removeChild(table);
							}

							return reliableTrDimensionsVal;
						}
					});
				})();

				function curCSS(elem, name, computed) {
					var width,
						minWidth,
						maxWidth,
						ret,
						// Support: Firefox 51+
						// Retrieving style before computed somehow
						// fixes an issue with getting wrong values
						// on detached elements
						style = elem.style;
					computed = computed || getStyles(elem); // getPropertyValue is needed for:
					//   .css('filter') (IE 9 only, #12537)
					//   .css('--customProperty) (#3144)

					if (computed) {
						ret = computed.getPropertyValue(name) || computed[name];

						if (ret === "" && !isAttached(elem)) {
							ret = jQuery.style(elem, name);
						} // A tribute to the "awesome hack by Dean Edwards"
						// Android Browser returns percentage for some values,
						// but width seems to be reliably pixels.
						// This is against the CSSOM draft spec:
						// https://drafts.csswg.org/cssom/#resolved-values


						if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
							// Remember the original values
							width = style.width;
							minWidth = style.minWidth;
							maxWidth = style.maxWidth; // Put in the new values to get a computed value out

							style.minWidth = style.maxWidth = style.width = ret;
							ret = computed.width; // Revert the changed values

							style.width = width;
							style.minWidth = minWidth;
							style.maxWidth = maxWidth;
						}
					}

					return ret !== undefined ? // Support: IE <=9 - 11 only
						// IE returns zIndex value as an integer.
						ret + "" : ret;
				}

				function addGetHookIf(conditionFn, hookFn) {
					// Define the hook, we'll check on the first run if it's really needed.
					return {
						get: function get() {
							if (conditionFn()) {
								// Hook not needed (or it's not possible to use it due
								// to missing dependency), remove it.
								delete this.get;
								return;
							} // Hook needed; redefine it so that the support test is not executed again.


							return (this.get = hookFn).apply(this, arguments);
						}
					};
				}

				var cssPrefixes = ["Webkit", "Moz", "ms"],
					emptyStyle = document.createElement("div").style,
					vendorProps = {}; // Return a vendor-prefixed property or undefined

				function vendorPropName(name) {
					// Check for vendor prefixed names
					var capName = name[0].toUpperCase() + name.slice(1),
						i = cssPrefixes.length;

					while (i--) {
						name = cssPrefixes[i] + capName;

						if (name in emptyStyle) {
							return name;
						}
					}
				} // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


				function finalPropName(name) {
					var _final = jQuery.cssProps[name] || vendorProps[name];

					if (_final) {
						return _final;
					}

					if (name in emptyStyle) {
						return name;
					}

					return vendorProps[name] = vendorPropName(name) || name;
				}

				var // Swappable if display is none or starts with table
					// except "table", "table-cell", or "table-caption"
					// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
					rdisplayswap = /^(none|table(?!-c[ea]).+)/,
					rcustomProp = /^--/,
					cssShow = {
						position: "absolute",
						visibility: "hidden",
						display: "block"
					},
					cssNormalTransform = {
						letterSpacing: "0",
						fontWeight: "400"
					};

				function setPositiveNumber(_elem, value, subtract) {
					// Any relative (+/-) values have already been
					// normalized at this point
					var matches = rcssNum.exec(value);
					return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
						Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
				}

				function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
					var i = dimension === "width" ? 1 : 0,
						extra = 0,
						delta = 0; // Adjustment may not be necessary

					if (box === (isBorderBox ? "border" : "content")) {
						return 0;
					}

					for (; i < 4; i += 2) {
						// Both box models exclude margin
						if (box === "margin") {
							delta += jQuery.css(elem, box + cssExpand[i], true, styles);
						} // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


						if (!isBorderBox) {
							// Add padding
							delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

							if (box !== "padding") {
								delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
							} else {
								extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							} // If we get here with a border-box (content + padding + border), we're seeking "content" or
							// "padding" or "margin"

						} else {
							// For "content", subtract padding
							if (box === "content") {
								delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
							} // For "content" or "padding", subtract border


							if (box !== "margin") {
								delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						}
					} // Account for positive content-box scroll gutter when requested by providing computedVal


					if (!isBorderBox && computedVal >= 0) {
						// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
						// Assuming integer scroll gutter, subtract the rest and round down
						delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
							// Use an explicit zero to avoid NaN (gh-3964)
						)) || 0;
					}

					return delta;
				}

				function getWidthOrHeight(elem, dimension, extra) {
					// Start with computed style
					var styles = getStyles(elem),
						// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
						// Fake content-box until we know it's needed to know the true value.
						boxSizingNeeded = !support.boxSizingReliable() || extra,
						isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
						valueIsBorderBox = isBorderBox,
						val = curCSS(elem, dimension, styles),
						offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
					// Return a confounding non-pixel value or feign ignorance, as appropriate.

					if (rnumnonpx.test(val)) {
						if (!extra) {
							return val;
						}

						val = "auto";
					} // Support: IE 9 - 11 only
					// Use offsetWidth/offsetHeight for when box sizing is unreliable.
					// In those cases, the computed value can be trusted to be border-box.


					if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
						// IE/Edge misreport `getComputedStyle` of table rows with width/height
						// set in CSS while `offset*` properties report correct values.
						// Interestingly, in some cases IE 9 doesn't suffer from this issue.
						!support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
						// This happens for inline elements with no explicit setting (gh-3571)
						val === "auto" || // Support: Android <=4.1 - 4.3 only
						// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
						!parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
						elem.getClientRects().length) {
						isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
						// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
						// retrieved value as a content box dimension.

						valueIsBorderBox = offsetProp in elem;

						if (valueIsBorderBox) {
							val = elem[offsetProp];
						}
					} // Normalize "" and auto


					val = parseFloat(val) || 0; // Adjust for the element's box model

					return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
						val) + "px";
				}

				jQuery.extend({
					// Add in style property hooks for overriding the default
					// behavior of getting and setting a style property
					cssHooks: {
						opacity: {
							get: function get(elem, computed) {
								if (computed) {
									// We should always get a number back from opacity
									var ret = curCSS(elem, "opacity");
									return ret === "" ? "1" : ret;
								}
							}
						}
					},
					// Don't automatically add "px" to these possibly-unitless properties
					cssNumber: {
						"animationIterationCount": true,
						"columnCount": true,
						"fillOpacity": true,
						"flexGrow": true,
						"flexShrink": true,
						"fontWeight": true,
						"gridArea": true,
						"gridColumn": true,
						"gridColumnEnd": true,
						"gridColumnStart": true,
						"gridRow": true,
						"gridRowEnd": true,
						"gridRowStart": true,
						"lineHeight": true,
						"opacity": true,
						"order": true,
						"orphans": true,
						"widows": true,
						"zIndex": true,
						"zoom": true
					},
					// Add in properties whose names you wish to fix before
					// setting or getting the value
					cssProps: {},
					// Get and set the style property on a DOM Node
					style: function style(elem, name, value, extra) {
						// Don't set styles on text and comment nodes
						if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
							return;
						} // Make sure that we're working with the right name


						var ret,
							type,
							hooks,
							origName = camelCase(name),
							isCustomProp = rcustomProp.test(name),
							style = elem.style; // Make sure that we're working with the right name. We don't
						// want to query the value if it is a CSS custom property
						// since they are user-defined.

						if (!isCustomProp) {
							name = finalPropName(origName);
						} // Gets hook for the prefixed version, then unprefixed version


						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

						if (value !== undefined) {
							type = _typeof(value); // Convert "+=" or "-=" to relative numbers (#7345)

							if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
								value = adjustCSS(elem, name, ret); // Fixes bug #9237

								type = "number";
							} // Make sure that null and NaN values aren't set (#7116)


							if (value == null || value !== value) {
								return;
							} // If a number was passed in, add the unit (except for certain CSS properties)
							// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
							// "px" to a few hardcoded values.


							if (type === "number" && !isCustomProp) {
								value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
							} // background-* props affect original clone's values


							if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
								style[name] = "inherit";
							} // If a hook was provided, use that value, otherwise just set the specified value


							if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
								if (isCustomProp) {
									style.setProperty(name, value);
								} else {
									style[name] = value;
								}
							}
						} else {
							// If a hook was provided get the non-computed value from there
							if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
								return ret;
							} // Otherwise just get the value from the style object


							return style[name];
						}
					},
					css: function css(elem, name, extra, styles) {
						var val,
							num,
							hooks,
							origName = camelCase(name),
							isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
						// want to modify the value if it is a CSS custom property
						// since they are user-defined.

						if (!isCustomProp) {
							name = finalPropName(origName);
						} // Try prefixed name followed by the unprefixed name


						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

						if (hooks && "get" in hooks) {
							val = hooks.get(elem, true, extra);
						} // Otherwise, if a way to get the computed value exists, use that


						if (val === undefined) {
							val = curCSS(elem, name, styles);
						} // Convert "normal" to computed value


						if (val === "normal" && name in cssNormalTransform) {
							val = cssNormalTransform[name];
						} // Make numeric if forced or a qualifier was provided and val looks numeric


						if (extra === "" || extra) {
							num = parseFloat(val);
							return extra === true || isFinite(num) ? num || 0 : val;
						}

						return val;
					}
				});
				jQuery.each(["height", "width"], function (_i, dimension) {
					jQuery.cssHooks[dimension] = {
						get: function get(elem, computed, extra) {
							if (computed) {
								// Certain elements can have dimension info if we invisibly show them
								// but it must have a current display style that would benefit
								return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
									// Table columns in Safari have non-zero offsetWidth & zero
									// getBoundingClientRect().width unless display is changed.
									// Support: IE <=11 only
									// Running getBoundingClientRect on a disconnected node
									// in IE throws an error.
									!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
									return getWidthOrHeight(elem, dimension, extra);
								}) : getWidthOrHeight(elem, dimension, extra);
							}
						},
						set: function set(elem, value, extra) {
							var matches,
								styles = getStyles(elem),
								// Only read styles.position if the test has a chance to fail
								// to avoid forcing a reflow.
								scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
								// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
								boxSizingNeeded = scrollboxSizeBuggy || extra,
								isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
								subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
							// faking a content-box to get border and padding (gh-3699)

							if (isBorderBox && scrollboxSizeBuggy) {
								subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
							} // Convert to pixels if value adjustment is needed


							if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
								elem.style[dimension] = value;
								value = jQuery.css(elem, dimension);
							}

							return setPositiveNumber(elem, value, subtract);
						}
					};
				});
				jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
					if (computed) {
						return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
							marginLeft: 0
						}, function () {
							return elem.getBoundingClientRect().left;
						})) + "px";
					}
				}); // These hooks are used by animate to expand properties

				jQuery.each({
					margin: "",
					padding: "",
					border: "Width"
				}, function (prefix, suffix) {
					jQuery.cssHooks[prefix + suffix] = {
						expand: function expand(value) {
							var i = 0,
								expanded = {},
								// Assumes a single number if not a string
								parts = typeof value === "string" ? value.split(" ") : [value];

							for (; i < 4; i++) {
								expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
							}

							return expanded;
						}
					};

					if (prefix !== "margin") {
						jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
					}
				});
				jQuery.fn.extend({
					css: function css(name, value) {
						return access(this, function (elem, name, value) {
							var styles,
								len,
								map = {},
								i = 0;

							if (Array.isArray(name)) {
								styles = getStyles(elem);
								len = name.length;

								for (; i < len; i++) {
									map[name[i]] = jQuery.css(elem, name[i], false, styles);
								}

								return map;
							}

							return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
						}, name, value, arguments.length > 1);
					}
				});

				function Tween(elem, options, prop, end, easing) {
					return new Tween.prototype.init(elem, options, prop, end, easing);
				}

				jQuery.Tween = Tween;
				Tween.prototype = {
					constructor: Tween,
					init: function init(elem, options, prop, end, easing, unit) {
						this.elem = elem;
						this.prop = prop;
						this.easing = easing || jQuery.easing._default;
						this.options = options;
						this.start = this.now = this.cur();
						this.end = end;
						this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
					},
					cur: function cur() {
						var hooks = Tween.propHooks[this.prop];
						return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
					},
					run: function run(percent) {
						var eased,
							hooks = Tween.propHooks[this.prop];

						if (this.options.duration) {
							this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
						} else {
							this.pos = eased = percent;
						}

						this.now = (this.end - this.start) * eased + this.start;

						if (this.options.step) {
							this.options.step.call(this.elem, this.now, this);
						}

						if (hooks && hooks.set) {
							hooks.set(this);
						} else {
							Tween.propHooks._default.set(this);
						}

						return this;
					}
				};
				Tween.prototype.init.prototype = Tween.prototype;
				Tween.propHooks = {
					_default: {
						get: function get(tween) {
							var result; // Use a property on the element directly when it is not a DOM element,
							// or when there is no matching style property that exists.

							if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
								return tween.elem[tween.prop];
							} // Passing an empty string as a 3rd parameter to .css will automatically
							// attempt a parseFloat and fallback to a string if the parse fails.
							// Simple values such as "10px" are parsed to Float;
							// complex values such as "rotate(1rad)" are returned as-is.


							result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

							return !result || result === "auto" ? 0 : result;
						},
						set: function set(tween) {
							// Use step hook for back compat.
							// Use cssHook if its there.
							// Use .style if available and use plain properties where available.
							if (jQuery.fx.step[tween.prop]) {
								jQuery.fx.step[tween.prop](tween);
							} else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
								jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
							} else {
								tween.elem[tween.prop] = tween.now;
							}
						}
					}
				}; // Support: IE <=9 only
				// Panic based approach to setting things on disconnected nodes

				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
					set: function set(tween) {
						if (tween.elem.nodeType && tween.elem.parentNode) {
							tween.elem[tween.prop] = tween.now;
						}
					}
				};
				jQuery.easing = {
					linear: function linear(p) {
						return p;
					},
					swing: function swing(p) {
						return 0.5 - Math.cos(p * Math.PI) / 2;
					},
					_default: "swing"
				};
				jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

				jQuery.fx.step = {};
				var fxNow,
					inProgress,
					rfxtypes = /^(?:toggle|show|hide)$/,
					rrun = /queueHooks$/;

				function schedule() {
					if (inProgress) {
						if (document.hidden === false && window.requestAnimationFrame) {
							window.requestAnimationFrame(schedule);
						} else {
							window.setTimeout(schedule, jQuery.fx.interval);
						}

						jQuery.fx.tick();
					}
				} // Animations created synchronously will run synchronously


				function createFxNow() {
					window.setTimeout(function () {
						fxNow = undefined;
					});
					return fxNow = Date.now();
				} // Generate parameters to create a standard animation


				function genFx(type, includeWidth) {
					var which,
						i = 0,
						attrs = {
							height: type
						}; // If we include width, step value is 1 to do all cssExpand values,
					// otherwise step value is 2 to skip over Left and Right

					includeWidth = includeWidth ? 1 : 0;

					for (; i < 4; i += 2 - includeWidth) {
						which = cssExpand[i];
						attrs["margin" + which] = attrs["padding" + which] = type;
					}

					if (includeWidth) {
						attrs.opacity = attrs.width = type;
					}

					return attrs;
				}

				function createTween(value, prop, animation) {
					var tween,
						collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
						index = 0,
						length = collection.length;

					for (; index < length; index++) {
						if (tween = collection[index].call(animation, prop, value)) {
							// We're done with this property
							return tween;
						}
					}
				}

				function defaultPrefilter(elem, props, opts) {
					var prop,
						value,
						toggle,
						hooks,
						oldfire,
						propTween,
						restoreDisplay,
						display,
						isBox = "width" in props || "height" in props,
						anim = this,
						orig = {},
						style = elem.style,
						hidden = elem.nodeType && isHiddenWithinTree(elem),
						dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

					if (!opts.queue) {
						hooks = jQuery._queueHooks(elem, "fx");

						if (hooks.unqueued == null) {
							hooks.unqueued = 0;
							oldfire = hooks.empty.fire;

							hooks.empty.fire = function () {
								if (!hooks.unqueued) {
									oldfire();
								}
							};
						}

						hooks.unqueued++;
						anim.always(function () {
							// Ensure the complete handler is called before this completes
							anim.always(function () {
								hooks.unqueued--;

								if (!jQuery.queue(elem, "fx").length) {
									hooks.empty.fire();
								}
							});
						});
					} // Detect show/hide animations


					for (prop in props) {
						value = props[prop];

						if (rfxtypes.test(value)) {
							delete props[prop];
							toggle = toggle || value === "toggle";

							if (value === (hidden ? "hide" : "show")) {
								// Pretend to be hidden if this is a "show" and
								// there is still data from a stopped show/hide
								if (value === "show" && dataShow && dataShow[prop] !== undefined) {
									hidden = true; // Ignore all other no-op show/hide data
								} else {
									continue;
								}
							}

							orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
						}
					} // Bail out if this is a no-op like .hide().hide()


					propTween = !jQuery.isEmptyObject(props);

					if (!propTween && jQuery.isEmptyObject(orig)) {
						return;
					} // Restrict "overflow" and "display" styles during box animations


					if (isBox && elem.nodeType === 1) {
						// Support: IE <=9 - 11, Edge 12 - 15
						// Record all 3 overflow attributes because IE does not infer the shorthand
						// from identically-valued overflowX and overflowY and Edge just mirrors
						// the overflowX value there.
						opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

						restoreDisplay = dataShow && dataShow.display;

						if (restoreDisplay == null) {
							restoreDisplay = dataPriv.get(elem, "display");
						}

						display = jQuery.css(elem, "display");

						if (display === "none") {
							if (restoreDisplay) {
								display = restoreDisplay;
							} else {
								// Get nonempty value(s) by temporarily forcing visibility
								showHide([elem], true);
								restoreDisplay = elem.style.display || restoreDisplay;
								display = jQuery.css(elem, "display");
								showHide([elem]);
							}
						} // Animate inline elements as inline-block


						if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
							if (jQuery.css(elem, "float") === "none") {
								// Restore the original display value at the end of pure show/hide animations
								if (!propTween) {
									anim.done(function () {
										style.display = restoreDisplay;
									});

									if (restoreDisplay == null) {
										display = style.display;
										restoreDisplay = display === "none" ? "" : display;
									}
								}

								style.display = "inline-block";
							}
						}
					}

					if (opts.overflow) {
						style.overflow = "hidden";
						anim.always(function () {
							style.overflow = opts.overflow[0];
							style.overflowX = opts.overflow[1];
							style.overflowY = opts.overflow[2];
						});
					} // Implement show/hide animations


					propTween = false;

					for (prop in orig) {
						// General show/hide setup for this element animation
						if (!propTween) {
							if (dataShow) {
								if ("hidden" in dataShow) {
									hidden = dataShow.hidden;
								}
							} else {
								dataShow = dataPriv.access(elem, "fxshow", {
									display: restoreDisplay
								});
							} // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


							if (toggle) {
								dataShow.hidden = !hidden;
							} // Show elements before animating them


							if (hidden) {
								showHide([elem], true);
							}
							/* eslint-disable no-loop-func */


							anim.done(function () {
								/* eslint-enable no-loop-func */
								// The final step of a "hide" animation is actually hiding the element
								if (!hidden) {
									showHide([elem]);
								}

								dataPriv.remove(elem, "fxshow");

								for (prop in orig) {
									jQuery.style(elem, prop, orig[prop]);
								}
							});
						} // Per-property setup


						propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

						if (!(prop in dataShow)) {
							dataShow[prop] = propTween.start;

							if (hidden) {
								propTween.end = propTween.start;
								propTween.start = 0;
							}
						}
					}
				}

				function propFilter(props, specialEasing) {
					var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

					for (index in props) {
						name = camelCase(index);
						easing = specialEasing[name];
						value = props[index];

						if (Array.isArray(value)) {
							easing = value[1];
							value = props[index] = value[0];
						}

						if (index !== name) {
							props[name] = value;
							delete props[index];
						}

						hooks = jQuery.cssHooks[name];

						if (hooks && "expand" in hooks) {
							value = hooks.expand(value);
							delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
							// Reusing 'index' because we have the correct "name"

							for (index in value) {
								if (!(index in props)) {
									props[index] = value[index];
									specialEasing[index] = easing;
								}
							}
						} else {
							specialEasing[name] = easing;
						}
					}
				}

				function Animation(elem, properties, options) {
					var result,
						stopped,
						index = 0,
						length = Animation.prefilters.length,
						deferred = jQuery.Deferred().always(function () {
							// Don't match elem in the :animated selector
							delete tick.elem;
						}),
						tick = function tick() {
							if (stopped) {
								return false;
							}

							var currentTime = fxNow || createFxNow(),
								remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
								// Support: Android 2.3 only
								// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
								temp = remaining / animation.duration || 0,
								percent = 1 - temp,
								index = 0,
								length = animation.tweens.length;

							for (; index < length; index++) {
								animation.tweens[index].run(percent);
							}

							deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

							if (percent < 1 && length) {
								return remaining;
							} // If this was an empty animation, synthesize a final progress notification


							if (!length) {
								deferred.notifyWith(elem, [animation, 1, 0]);
							} // Resolve the animation and report its conclusion


							deferred.resolveWith(elem, [animation]);
							return false;
						},
						animation = deferred.promise({
							elem: elem,
							props: jQuery.extend({}, properties),
							opts: jQuery.extend(true, {
								specialEasing: {},
								easing: jQuery.easing._default
							}, options),
							originalProperties: properties,
							originalOptions: options,
							startTime: fxNow || createFxNow(),
							duration: options.duration,
							tweens: [],
							createTween: function createTween(prop, end) {
								var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
								animation.tweens.push(tween);
								return tween;
							},
							stop: function stop(gotoEnd) {
								var index = 0,
									// If we are going to the end, we want to run all the tweens
									// otherwise we skip this part
									length = gotoEnd ? animation.tweens.length : 0;

								if (stopped) {
									return this;
								}

								stopped = true;

								for (; index < length; index++) {
									animation.tweens[index].run(1);
								} // Resolve when we played the last frame; otherwise, reject


								if (gotoEnd) {
									deferred.notifyWith(elem, [animation, 1, 0]);
									deferred.resolveWith(elem, [animation, gotoEnd]);
								} else {
									deferred.rejectWith(elem, [animation, gotoEnd]);
								}

								return this;
							}
						}),
						props = animation.props;

					propFilter(props, animation.opts.specialEasing);

					for (; index < length; index++) {
						result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

						if (result) {
							if (isFunction(result.stop)) {
								jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
							}

							return result;
						}
					}

					jQuery.map(props, createTween, animation);

					if (isFunction(animation.opts.start)) {
						animation.opts.start.call(elem, animation);
					} // Attach callbacks from options


					animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
					jQuery.fx.timer(jQuery.extend(tick, {
						elem: elem,
						anim: animation,
						queue: animation.opts.queue
					}));
					return animation;
				}

				jQuery.Animation = jQuery.extend(Animation, {
					tweeners: {
						"*": [function (prop, value) {
							var tween = this.createTween(prop, value);
							adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
							return tween;
						}]
					},
					tweener: function tweener(props, callback) {
						if (isFunction(props)) {
							callback = props;
							props = ["*"];
						} else {
							props = props.match(rnothtmlwhite);
						}

						var prop,
							index = 0,
							length = props.length;

						for (; index < length; index++) {
							prop = props[index];
							Animation.tweeners[prop] = Animation.tweeners[prop] || [];
							Animation.tweeners[prop].unshift(callback);
						}
					},
					prefilters: [defaultPrefilter],
					prefilter: function prefilter(callback, prepend) {
						if (prepend) {
							Animation.prefilters.unshift(callback);
						} else {
							Animation.prefilters.push(callback);
						}
					}
				});

				jQuery.speed = function (speed, easing, fn) {
					var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
						complete: fn || !fn && easing || isFunction(speed) && speed,
						duration: speed,
						easing: fn && easing || easing && !isFunction(easing) && easing
					}; // Go to the end state if fx are off

					if (jQuery.fx.off) {
						opt.duration = 0;
					} else {
						if (typeof opt.duration !== "number") {
							if (opt.duration in jQuery.fx.speeds) {
								opt.duration = jQuery.fx.speeds[opt.duration];
							} else {
								opt.duration = jQuery.fx.speeds._default;
							}
						}
					} // Normalize opt.queue - true/undefined/null -> "fx"


					if (opt.queue == null || opt.queue === true) {
						opt.queue = "fx";
					} // Queueing


					opt.old = opt.complete;

					opt.complete = function () {
						if (isFunction(opt.old)) {
							opt.old.call(this);
						}

						if (opt.queue) {
							jQuery.dequeue(this, opt.queue);
						}
					};

					return opt;
				};

				jQuery.fn.extend({
					fadeTo: function fadeTo(speed, to, easing, callback) {
						// Show any hidden elements after setting opacity to 0
						return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
							.end().animate({
								opacity: to
							}, speed, easing, callback);
					},
					animate: function animate(prop, speed, easing, callback) {
						var empty = jQuery.isEmptyObject(prop),
							optall = jQuery.speed(speed, easing, callback),
							doAnimation = function doAnimation() {
								// Operate on a copy of prop so per-property easing won't be lost
								var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

								if (empty || dataPriv.get(this, "finish")) {
									anim.stop(true);
								}
							};

						doAnimation.finish = doAnimation;
						return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
					},
					stop: function stop(type, clearQueue, gotoEnd) {
						var stopQueue = function stopQueue(hooks) {
							var stop = hooks.stop;
							delete hooks.stop;
							stop(gotoEnd);
						};

						if (typeof type !== "string") {
							gotoEnd = clearQueue;
							clearQueue = type;
							type = undefined;
						}

						if (clearQueue) {
							this.queue(type || "fx", []);
						}

						return this.each(function () {
							var dequeue = true,
								index = type != null && type + "queueHooks",
								timers = jQuery.timers,
								data = dataPriv.get(this);

							if (index) {
								if (data[index] && data[index].stop) {
									stopQueue(data[index]);
								}
							} else {
								for (index in data) {
									if (data[index] && data[index].stop && rrun.test(index)) {
										stopQueue(data[index]);
									}
								}
							}

							for (index = timers.length; index--;) {
								if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
									timers[index].anim.stop(gotoEnd);
									dequeue = false;
									timers.splice(index, 1);
								}
							} // Start the next in the queue if the last step wasn't forced.
							// Timers currently will call their complete callbacks, which
							// will dequeue but only if they were gotoEnd.


							if (dequeue || !gotoEnd) {
								jQuery.dequeue(this, type);
							}
						});
					},
					finish: function finish(type) {
						if (type !== false) {
							type = type || "fx";
						}

						return this.each(function () {
							var index,
								data = dataPriv.get(this),
								queue = data[type + "queue"],
								hooks = data[type + "queueHooks"],
								timers = jQuery.timers,
								length = queue ? queue.length : 0; // Enable finishing flag on private data

							data.finish = true; // Empty the queue first

							jQuery.queue(this, type, []);

							if (hooks && hooks.stop) {
								hooks.stop.call(this, true);
							} // Look for any active animations, and finish them


							for (index = timers.length; index--;) {
								if (timers[index].elem === this && timers[index].queue === type) {
									timers[index].anim.stop(true);
									timers.splice(index, 1);
								}
							} // Look for any animations in the old queue and finish them


							for (index = 0; index < length; index++) {
								if (queue[index] && queue[index].finish) {
									queue[index].finish.call(this);
								}
							} // Turn off finishing flag


							delete data.finish;
						});
					}
				});
				jQuery.each(["toggle", "show", "hide"], function (_i, name) {
					var cssFn = jQuery.fn[name];

					jQuery.fn[name] = function (speed, easing, callback) {
						return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
					};
				}); // Generate shortcuts for custom animations

				jQuery.each({
					slideDown: genFx("show"),
					slideUp: genFx("hide"),
					slideToggle: genFx("toggle"),
					fadeIn: {
						opacity: "show"
					},
					fadeOut: {
						opacity: "hide"
					},
					fadeToggle: {
						opacity: "toggle"
					}
				}, function (name, props) {
					jQuery.fn[name] = function (speed, easing, callback) {
						return this.animate(props, speed, easing, callback);
					};
				});
				jQuery.timers = [];

				jQuery.fx.tick = function () {
					var timer,
						i = 0,
						timers = jQuery.timers;
					fxNow = Date.now();

					for (; i < timers.length; i++) {
						timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

						if (!timer() && timers[i] === timer) {
							timers.splice(i--, 1);
						}
					}

					if (!timers.length) {
						jQuery.fx.stop();
					}

					fxNow = undefined;
				};

				jQuery.fx.timer = function (timer) {
					jQuery.timers.push(timer);
					jQuery.fx.start();
				};

				jQuery.fx.interval = 13;

				jQuery.fx.start = function () {
					if (inProgress) {
						return;
					}

					inProgress = true;
					schedule();
				};

				jQuery.fx.stop = function () {
					inProgress = null;
				};

				jQuery.fx.speeds = {
					slow: 600,
					fast: 200,
					// Default speed
					_default: 400
				}; // Based off of the plugin by Clint Helfers, with permission.
				// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

				jQuery.fn.delay = function (time, type) {
					time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
					type = type || "fx";
					return this.queue(type, function (next, hooks) {
						var timeout = window.setTimeout(next, time);

						hooks.stop = function () {
							window.clearTimeout(timeout);
						};
					});
				};

				(function () {
					var input = document.createElement("input"),
						select = document.createElement("select"),
						opt = select.appendChild(document.createElement("option"));
					input.type = "checkbox"; // Support: Android <=4.3 only
					// Default value for a checkbox should be "on"

					support.checkOn = input.value !== ""; // Support: IE <=11 only
					// Must access selectedIndex to make default options select

					support.optSelected = opt.selected; // Support: IE <=11 only
					// An input loses its value after becoming a radio

					input = document.createElement("input");
					input.value = "t";
					input.type = "radio";
					support.radioValue = input.value === "t";
				})();

				var boolHook,
					attrHandle = jQuery.expr.attrHandle;
				jQuery.fn.extend({
					attr: function attr(name, value) {
						return access(this, jQuery.attr, name, value, arguments.length > 1);
					},
					removeAttr: function removeAttr(name) {
						return this.each(function () {
							jQuery.removeAttr(this, name);
						});
					}
				});
				jQuery.extend({
					attr: function attr(elem, name, value) {
						var ret,
							hooks,
							nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						} // Fallback to prop when attributes are not supported


						if (typeof elem.getAttribute === "undefined") {
							return jQuery.prop(elem, name, value);
						} // Attribute hooks are determined by the lowercase version
						// Grab necessary hook if one is defined


						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
							hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
						}

						if (value !== undefined) {
							if (value === null) {
								jQuery.removeAttr(elem, name);
								return;
							}

							if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}

							elem.setAttribute(name, value + "");
							return value;
						}

						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}

						ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

						return ret == null ? undefined : ret;
					},
					attrHooks: {
						type: {
							set: function set(elem, value) {
								if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
									var val = elem.value;
									elem.setAttribute("type", value);

									if (val) {
										elem.value = val;
									}

									return value;
								}
							}
						}
					},
					removeAttr: function removeAttr(elem, value) {
						var name,
							i = 0,
							// Attribute names can contain non-HTML whitespace characters
							// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
							attrNames = value && value.match(rnothtmlwhite);

						if (attrNames && elem.nodeType === 1) {
							while (name = attrNames[i++]) {
								elem.removeAttribute(name);
							}
						}
					}
				}); // Hooks for boolean attributes

				boolHook = {
					set: function set(elem, value, name) {
						if (value === false) {
							// Remove boolean attributes when set to false
							jQuery.removeAttr(elem, name);
						} else {
							elem.setAttribute(name, name);
						}

						return name;
					}
				};
				jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
					var getter = attrHandle[name] || jQuery.find.attr;

					attrHandle[name] = function (elem, name, isXML) {
						var ret,
							handle,
							lowercaseName = name.toLowerCase();

						if (!isXML) {
							// Avoid an infinite loop by temporarily removing this function from the getter
							handle = attrHandle[lowercaseName];
							attrHandle[lowercaseName] = ret;
							ret = getter(elem, name, isXML) != null ? lowercaseName : null;
							attrHandle[lowercaseName] = handle;
						}

						return ret;
					};
				});
				var rfocusable = /^(?:input|select|textarea|button)$/i,
					rclickable = /^(?:a|area)$/i;
				jQuery.fn.extend({
					prop: function prop(name, value) {
						return access(this, jQuery.prop, name, value, arguments.length > 1);
					},
					removeProp: function removeProp(name) {
						return this.each(function () {
							delete this[jQuery.propFix[name] || name];
						});
					}
				});
				jQuery.extend({
					prop: function prop(elem, name, value) {
						var ret,
							hooks,
							nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						}

						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
							// Fix name and attach hooks
							name = jQuery.propFix[name] || name;
							hooks = jQuery.propHooks[name];
						}

						if (value !== undefined) {
							if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}

							return elem[name] = value;
						}

						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}

						return elem[name];
					},
					propHooks: {
						tabIndex: {
							get: function get(elem) {
								// Support: IE <=9 - 11 only
								// elem.tabIndex doesn't always return the
								// correct value when it hasn't been explicitly set
								// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
								// Use proper attribute retrieval(#12072)
								var tabindex = jQuery.find.attr(elem, "tabindex");

								if (tabindex) {
									return parseInt(tabindex, 10);
								}

								if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
									return 0;
								}

								return -1;
							}
						}
					},
					propFix: {
						"for": "htmlFor",
						"class": "className"
					}
				}); // Support: IE <=11 only
				// Accessing the selectedIndex property
				// forces the browser to respect setting selected
				// on the option
				// The getter ensures a default option is selected
				// when in an optgroup
				// eslint rule "no-unused-expressions" is disabled for this code
				// since it considers such accessions noop

				if (!support.optSelected) {
					jQuery.propHooks.selected = {
						get: function get(elem) {
							/* eslint no-unused-expressions: "off" */
							var parent = elem.parentNode;

							if (parent && parent.parentNode) {
								parent.parentNode.selectedIndex;
							}

							return null;
						},
						set: function set(elem) {
							/* eslint no-unused-expressions: "off" */
							var parent = elem.parentNode;

							if (parent) {
								parent.selectedIndex;

								if (parent.parentNode) {
									parent.parentNode.selectedIndex;
								}
							}
						}
					};
				}

				jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
					jQuery.propFix[this.toLowerCase()] = this;
				}); // Strip and collapse whitespace according to HTML spec
				// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

				function stripAndCollapse(value) {
					var tokens = value.match(rnothtmlwhite) || [];
					return tokens.join(" ");
				}

				function getClass(elem) {
					return elem.getAttribute && elem.getAttribute("class") || "";
				}

				function classesToArray(value) {
					if (Array.isArray(value)) {
						return value;
					}

					if (typeof value === "string") {
						return value.match(rnothtmlwhite) || [];
					}

					return [];
				}

				jQuery.fn.extend({
					addClass: function addClass(value) {
						var classes,
							elem,
							cur,
							curValue,
							clazz,
							j,
							finalValue,
							i = 0;

						if (isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).addClass(value.call(this, j, getClass(this)));
							});
						}

						classes = classesToArray(value);

						if (classes.length) {
							while (elem = this[i++]) {
								curValue = getClass(elem);
								cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

								if (cur) {
									j = 0;

									while (clazz = classes[j++]) {
										if (cur.indexOf(" " + clazz + " ") < 0) {
											cur += clazz + " ";
										}
									} // Only assign if different to avoid unneeded rendering.


									finalValue = stripAndCollapse(cur);

									if (curValue !== finalValue) {
										elem.setAttribute("class", finalValue);
									}
								}
							}
						}

						return this;
					},
					removeClass: function removeClass(value) {
						var classes,
							elem,
							cur,
							curValue,
							clazz,
							j,
							finalValue,
							i = 0;

						if (isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).removeClass(value.call(this, j, getClass(this)));
							});
						}

						if (!arguments.length) {
							return this.attr("class", "");
						}

						classes = classesToArray(value);

						if (classes.length) {
							while (elem = this[i++]) {
								curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

								cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

								if (cur) {
									j = 0;

									while (clazz = classes[j++]) {
										// Remove *all* instances
										while (cur.indexOf(" " + clazz + " ") > -1) {
											cur = cur.replace(" " + clazz + " ", " ");
										}
									} // Only assign if different to avoid unneeded rendering.


									finalValue = stripAndCollapse(cur);

									if (curValue !== finalValue) {
										elem.setAttribute("class", finalValue);
									}
								}
							}
						}

						return this;
					},
					toggleClass: function toggleClass(value, stateVal) {
						var type = _typeof(value),
							isValidValue = type === "string" || Array.isArray(value);

						if (typeof stateVal === "boolean" && isValidValue) {
							return stateVal ? this.addClass(value) : this.removeClass(value);
						}

						if (isFunction(value)) {
							return this.each(function (i) {
								jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
							});
						}

						return this.each(function () {
							var className, i, self, classNames;

							if (isValidValue) {
								// Toggle individual class names
								i = 0;
								self = jQuery(this);
								classNames = classesToArray(value);

								while (className = classNames[i++]) {
									// Check each className given, space separated list
									if (self.hasClass(className)) {
										self.removeClass(className);
									} else {
										self.addClass(className);
									}
								} // Toggle whole class name

							} else if (value === undefined || type === "boolean") {
								className = getClass(this);

								if (className) {
									// Store className if set
									dataPriv.set(this, "__className__", className);
								} // If the element has a class name or if we're passed `false`,
								// then remove the whole classname (if there was one, the above saved it).
								// Otherwise bring back whatever was previously saved (if anything),
								// falling back to the empty string if nothing was stored.


								if (this.setAttribute) {
									this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
								}
							}
						});
					},
					hasClass: function hasClass(selector) {
						var className,
							elem,
							i = 0;
						className = " " + selector + " ";

						while (elem = this[i++]) {
							if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
								return true;
							}
						}

						return false;
					}
				});
				var rreturn = /\r/g;
				jQuery.fn.extend({
					val: function val(value) {
						var hooks,
							ret,
							valueIsFunction,
							elem = this[0];

						if (!arguments.length) {
							if (elem) {
								hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

								if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
									return ret;
								}

								ret = elem.value; // Handle most common string cases

								if (typeof ret === "string") {
									return ret.replace(rreturn, "");
								} // Handle cases where value is null/undef or number


								return ret == null ? "" : ret;
							}

							return;
						}

						valueIsFunction = isFunction(value);
						return this.each(function (i) {
							var val;

							if (this.nodeType !== 1) {
								return;
							}

							if (valueIsFunction) {
								val = value.call(this, i, jQuery(this).val());
							} else {
								val = value;
							} // Treat null/undefined as ""; convert numbers to string


							if (val == null) {
								val = "";
							} else if (typeof val === "number") {
								val += "";
							} else if (Array.isArray(val)) {
								val = jQuery.map(val, function (value) {
									return value == null ? "" : value + "";
								});
							}

							hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

							if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
								this.value = val;
							}
						});
					}
				});
				jQuery.extend({
					valHooks: {
						option: {
							get: function get(elem) {
								var val = jQuery.find.attr(elem, "value");
								return val != null ? val : // Support: IE <=10 - 11 only
									// option.text throws exceptions (#14686, #14858)
									// Strip and collapse whitespace
									// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
									stripAndCollapse(jQuery.text(elem));
							}
						},
						select: {
							get: function get(elem) {
								var value,
									option,
									i,
									options = elem.options,
									index = elem.selectedIndex,
									one = elem.type === "select-one",
									values = one ? null : [],
									max = one ? index + 1 : options.length;

								if (index < 0) {
									i = max;
								} else {
									i = one ? index : 0;
								} // Loop through all the selected options


								for (; i < max; i++) {
									option = options[i]; // Support: IE <=9 only
									// IE8-9 doesn't update selected after form reset (#2551)

									if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
										!option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
										// Get the specific value for the option
										value = jQuery(option).val(); // We don't need an array for one selects

										if (one) {
											return value;
										} // Multi-Selects return an array


										values.push(value);
									}
								}

								return values;
							},
							set: function set(elem, value) {
								var optionSet,
									option,
									options = elem.options,
									values = jQuery.makeArray(value),
									i = options.length;

								while (i--) {
									option = options[i];
									/* eslint-disable no-cond-assign */

									if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
										optionSet = true;
									}
									/* eslint-enable no-cond-assign */

								} // Force browsers to behave consistently when non-matching value is set


								if (!optionSet) {
									elem.selectedIndex = -1;
								}

								return values;
							}
						}
					}
				}); // Radios and checkboxes getter/setter

				jQuery.each(["radio", "checkbox"], function () {
					jQuery.valHooks[this] = {
						set: function set(elem, value) {
							if (Array.isArray(value)) {
								return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
							}
						}
					};

					if (!support.checkOn) {
						jQuery.valHooks[this].get = function (elem) {
							return elem.getAttribute("value") === null ? "on" : elem.value;
						};
					}
				}); // Return jQuery for attributes-only inclusion

				support.focusin = "onfocusin" in window;

				var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
					stopPropagationCallback = function stopPropagationCallback(e) {
						e.stopPropagation();
					};

				jQuery.extend(jQuery.event, {
					trigger: function trigger(event, data, elem, onlyHandlers) {
						var i,
							cur,
							tmp,
							bubbleType,
							ontype,
							handle,
							special,
							lastElement,
							eventPath = [elem || document],
							type = hasOwn.call(event, "type") ? event.type : event,
							namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
						cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

						if (elem.nodeType === 3 || elem.nodeType === 8) {
							return;
						} // focus/blur morphs to focusin/out; ensure we're not firing them right now


						if (rfocusMorph.test(type + jQuery.event.triggered)) {
							return;
						}

						if (type.indexOf(".") > -1) {
							// Namespaced trigger; create a regexp to match event type in handle()
							namespaces = type.split(".");
							type = namespaces.shift();
							namespaces.sort();
						}

						ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

						event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

						event.isTrigger = onlyHandlers ? 2 : 3;
						event.namespace = namespaces.join(".");
						event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

						event.result = undefined;

						if (!event.target) {
							event.target = elem;
						} // Clone any incoming data and prepend the event, creating the handler arg list


						data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

						special = jQuery.event.special[type] || {};

						if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
							return;
						} // Determine event propagation path in advance, per W3C events spec (#9951)
						// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


						if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
							bubbleType = special.delegateType || type;

							if (!rfocusMorph.test(bubbleType + type)) {
								cur = cur.parentNode;
							}

							for (; cur; cur = cur.parentNode) {
								eventPath.push(cur);
								tmp = cur;
							} // Only add window if we got to document (e.g., not plain obj or detached DOM)


							if (tmp === (elem.ownerDocument || document)) {
								eventPath.push(tmp.defaultView || tmp.parentWindow || window);
							}
						} // Fire handlers on the event path


						i = 0;

						while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
							lastElement = cur;
							event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

							handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

							if (handle) {
								handle.apply(cur, data);
							} // Native handler


							handle = ontype && cur[ontype];

							if (handle && handle.apply && acceptData(cur)) {
								event.result = handle.apply(cur, data);

								if (event.result === false) {
									event.preventDefault();
								}
							}
						}

						event.type = type; // If nobody prevented the default action, do it now

						if (!onlyHandlers && !event.isDefaultPrevented()) {
							if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
								// Call a native DOM method on the target with the same name as the event.
								// Don't do default actions on window, that's where global variables be (#6170)
								if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
									// Don't re-trigger an onFOO event when we call its FOO() method
									tmp = elem[ontype];

									if (tmp) {
										elem[ontype] = null;
									} // Prevent re-triggering of the same event, since we already bubbled it above


									jQuery.event.triggered = type;

									if (event.isPropagationStopped()) {
										lastElement.addEventListener(type, stopPropagationCallback);
									}

									elem[type]();

									if (event.isPropagationStopped()) {
										lastElement.removeEventListener(type, stopPropagationCallback);
									}

									jQuery.event.triggered = undefined;

									if (tmp) {
										elem[ontype] = tmp;
									}
								}
							}
						}

						return event.result;
					},
					// Piggyback on a donor event to simulate a different one
					// Used only for `focus(in | out)` events
					simulate: function simulate(type, elem, event) {
						var e = jQuery.extend(new jQuery.Event(), event, {
							type: type,
							isSimulated: true
						});
						jQuery.event.trigger(e, null, elem);
					}
				});
				jQuery.fn.extend({
					trigger: function trigger(type, data) {
						return this.each(function () {
							jQuery.event.trigger(type, data, this);
						});
					},
					triggerHandler: function triggerHandler(type, data) {
						var elem = this[0];

						if (elem) {
							return jQuery.event.trigger(type, data, elem, true);
						}
					}
				}); // Support: Firefox <=44
				// Firefox doesn't have focus(in | out) events
				// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
				//
				// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
				// focus(in | out) events fire after focus & blur events,
				// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
				// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

				if (!support.focusin) {
					jQuery.each({
						focus: "focusin",
						blur: "focusout"
					}, function (orig, fix) {
						// Attach a single capturing handler on the document while someone wants focusin/focusout
						var handler = function handler(event) {
							jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
						};

						jQuery.event.special[fix] = {
							setup: function setup() {
								// Handle: regular nodes (via `this.ownerDocument`), window
								// (via `this.document`) & document (via `this`).
								var doc = this.ownerDocument || this.document || this,
									attaches = dataPriv.access(doc, fix);

								if (!attaches) {
									doc.addEventListener(orig, handler, true);
								}

								dataPriv.access(doc, fix, (attaches || 0) + 1);
							},
							teardown: function teardown() {
								var doc = this.ownerDocument || this.document || this,
									attaches = dataPriv.access(doc, fix) - 1;

								if (!attaches) {
									doc.removeEventListener(orig, handler, true);
									dataPriv.remove(doc, fix);
								} else {
									dataPriv.access(doc, fix, attaches);
								}
							}
						};
					});
				}

				var location = window.location;
				var nonce = {
					guid: Date.now()
				};
				var rquery = /\?/; // Cross-browser xml parsing

				jQuery.parseXML = function (data) {
					var xml;

					if (!data || typeof data !== "string") {
						return null;
					} // Support: IE 9 - 11 only
					// IE throws on parseFromString with invalid input.


					try {
						xml = new window.DOMParser().parseFromString(data, "text/xml");
					} catch (e) {
						xml = undefined;
					}

					if (!xml || xml.getElementsByTagName("parsererror").length) {
						jQuery.error("Invalid XML: " + data);
					}

					return xml;
				};

				var rbracket = /\[\]$/,
					rCRLF = /\r?\n/g,
					rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
					rsubmittable = /^(?:input|select|textarea|keygen)/i;

				function buildParams(prefix, obj, traditional, add) {
					var name;

					if (Array.isArray(obj)) {
						// Serialize array item.
						jQuery.each(obj, function (i, v) {
							if (traditional || rbracket.test(prefix)) {
								// Treat each array item as a scalar.
								add(prefix, v);
							} else {
								// Item is non-scalar (array or object), encode its numeric index.
								buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
							}
						});
					} else if (!traditional && toType(obj) === "object") {
						// Serialize object item.
						for (name in obj) {
							buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
						}
					} else {
						// Serialize scalar item.
						add(prefix, obj);
					}
				} // Serialize an array of form elements or a set of
				// key/values into a query string


				jQuery.param = function (a, traditional) {
					var prefix,
						s = [],
						add = function add(key, valueOrFunction) {
							// If value is a function, invoke it and use its return value
							var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
							s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
						};

					if (a == null) {
						return "";
					} // If an array was passed in, assume that it is an array of form elements.


					if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
						// Serialize the form elements
						jQuery.each(a, function () {
							add(this.name, this.value);
						});
					} else {
						// If traditional, encode the "old" way (the way 1.3.2 or older
						// did it), otherwise encode params recursively.
						for (prefix in a) {
							buildParams(prefix, a[prefix], traditional, add);
						}
					} // Return the resulting serialization


					return s.join("&");
				};

				jQuery.fn.extend({
					serialize: function serialize() {
						return jQuery.param(this.serializeArray());
					},
					serializeArray: function serializeArray() {
						return this.map(function () {
							// Can add propHook for "elements" to filter or add form elements
							var elements = jQuery.prop(this, "elements");
							return elements ? jQuery.makeArray(elements) : this;
						}).filter(function () {
							var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

							return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
						}).map(function (_i, elem) {
							var val = jQuery(this).val();

							if (val == null) {
								return null;
							}

							if (Array.isArray(val)) {
								return jQuery.map(val, function (val) {
									return {
										name: elem.name,
										value: val.replace(rCRLF, "\r\n")
									};
								});
							}

							return {
								name: elem.name,
								value: val.replace(rCRLF, "\r\n")
							};
						}).get();
					}
				});
				var r20 = /%20/g,
					rhash = /#.*$/,
					rantiCache = /([?&])_=[^&]*/,
					rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
					// #7653, #8125, #8152: local protocol detection
					rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
					rnoContent = /^(?:GET|HEAD)$/,
					rprotocol = /^\/\//,

					/* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
					prefilters = {},

					/* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
					transports = {},
					// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
					allTypes = "*/".concat("*"),
					// Anchor tag for parsing the document origin
					originAnchor = document.createElement("a");
				originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

				function addToPrefiltersOrTransports(structure) {
					// dataTypeExpression is optional and defaults to "*"
					return function (dataTypeExpression, func) {
						if (typeof dataTypeExpression !== "string") {
							func = dataTypeExpression;
							dataTypeExpression = "*";
						}

						var dataType,
							i = 0,
							dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

						if (isFunction(func)) {
							// For each dataType in the dataTypeExpression
							while (dataType = dataTypes[i++]) {
								// Prepend if requested
								if (dataType[0] === "+") {
									dataType = dataType.slice(1) || "*";
									(structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
								} else {
									(structure[dataType] = structure[dataType] || []).push(func);
								}
							}
						}
					};
				} // Base inspection function for prefilters and transports


				function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
					var inspected = {},
						seekingTransport = structure === transports;

					function inspect(dataType) {
						var selected;
						inspected[dataType] = true;
						jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
							var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

							if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
								options.dataTypes.unshift(dataTypeOrTransport);
								inspect(dataTypeOrTransport);
								return false;
							} else if (seekingTransport) {
								return !(selected = dataTypeOrTransport);
							}
						});
						return selected;
					}

					return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
				} // A special extend for ajax options
				// that takes "flat" options (not to be deep extended)
				// Fixes #9887


				function ajaxExtend(target, src) {
					var key,
						deep,
						flatOptions = jQuery.ajaxSettings.flatOptions || {};

					for (key in src) {
						if (src[key] !== undefined) {
							(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
						}
					}

					if (deep) {
						jQuery.extend(true, target, deep);
					}

					return target;
				}

				/* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


				function ajaxHandleResponses(s, jqXHR, responses) {
					var ct,
						type,
						finalDataType,
						firstDataType,
						contents = s.contents,
						dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

					while (dataTypes[0] === "*") {
						dataTypes.shift();

						if (ct === undefined) {
							ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
						}
					} // Check if we're dealing with a known content-type


					if (ct) {
						for (type in contents) {
							if (contents[type] && contents[type].test(ct)) {
								dataTypes.unshift(type);
								break;
							}
						}
					} // Check to see if we have a response for the expected dataType


					if (dataTypes[0] in responses) {
						finalDataType = dataTypes[0];
					} else {
						// Try convertible dataTypes
						for (type in responses) {
							if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
								finalDataType = type;
								break;
							}

							if (!firstDataType) {
								firstDataType = type;
							}
						} // Or just use first one


						finalDataType = finalDataType || firstDataType;
					} // If we found a dataType
					// We add the dataType to the list if needed
					// and return the corresponding response


					if (finalDataType) {
						if (finalDataType !== dataTypes[0]) {
							dataTypes.unshift(finalDataType);
						}

						return responses[finalDataType];
					}
				}

				/* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


				function ajaxConvert(s, response, jqXHR, isSuccess) {
					var conv2,
						current,
						conv,
						tmp,
						prev,
						converters = {},
						// Work with a copy of dataTypes in case we need to modify it for conversion
						dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

					if (dataTypes[1]) {
						for (conv in s.converters) {
							converters[conv.toLowerCase()] = s.converters[conv];
						}
					}

					current = dataTypes.shift(); // Convert to each sequential dataType

					while (current) {
						if (s.responseFields[current]) {
							jqXHR[s.responseFields[current]] = response;
						} // Apply the dataFilter if provided


						if (!prev && isSuccess && s.dataFilter) {
							response = s.dataFilter(response, s.dataType);
						}

						prev = current;
						current = dataTypes.shift();

						if (current) {
							// There's only work to do if current dataType is non-auto
							if (current === "*") {
								current = prev; // Convert response if prev dataType is non-auto and differs from current
							} else if (prev !== "*" && prev !== current) {
								// Seek a direct converter
								conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

								if (!conv) {
									for (conv2 in converters) {
										// If conv2 outputs current
										tmp = conv2.split(" ");

										if (tmp[1] === current) {
											// If prev can be converted to accepted input
											conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

											if (conv) {
												// Condense equivalence converters
												if (conv === true) {
													conv = converters[conv2]; // Otherwise, insert the intermediate dataType
												} else if (converters[conv2] !== true) {
													current = tmp[0];
													dataTypes.unshift(tmp[1]);
												}

												break;
											}
										}
									}
								} // Apply converter (if not an equivalence)


								if (conv !== true) {
									// Unless errors are allowed to bubble, catch and return them
									if (conv && s["throws"]) {
										response = conv(response);
									} else {
										try {
											response = conv(response);
										} catch (e) {
											return {
												state: "parsererror",
												error: conv ? e : "No conversion from " + prev + " to " + current
											};
										}
									}
								}
							}
						}
					}

					return {
						state: "success",
						data: response
					};
				}

				jQuery.extend({
					// Counter for holding the number of active queries
					active: 0,
					// Last-Modified header cache for next request
					lastModified: {},
					etag: {},
					ajaxSettings: {
						url: location.href,
						type: "GET",
						isLocal: rlocalProtocol.test(location.protocol),
						global: true,
						processData: true,
						async: true,
						contentType: "application/x-www-form-urlencoded; charset=UTF-8",

						/*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
						accepts: {
							"*": allTypes,
							text: "text/plain",
							html: "text/html",
							xml: "application/xml, text/xml",
							json: "application/json, text/javascript"
						},
						contents: {
							xml: /\bxml\b/,
							html: /\bhtml/,
							json: /\bjson\b/
						},
						responseFields: {
							xml: "responseXML",
							text: "responseText",
							json: "responseJSON"
						},
						// Data converters
						// Keys separate source (or catchall "*") and destination types with a single space
						converters: {
							// Convert anything to text
							"* text": String,
							// Text to html (true = no transformation)
							"text html": true,
							// Evaluate text as a json expression
							"text json": JSON.parse,
							// Parse text as xml
							"text xml": jQuery.parseXML
						},
						// For options that shouldn't be deep extended:
						// you can add your own custom options here if
						// and when you create one that shouldn't be
						// deep extended (see ajaxExtend)
						flatOptions: {
							url: true,
							context: true
						}
					},
					// Creates a full fledged settings object into target
					// with both ajaxSettings and settings fields.
					// If target is omitted, writes into ajaxSettings.
					ajaxSetup: function ajaxSetup(target, settings) {
						return settings ? // Building a settings object
							ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
							ajaxExtend(jQuery.ajaxSettings, target);
					},
					ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
					ajaxTransport: addToPrefiltersOrTransports(transports),
					// Main method
					ajax: function ajax(url, options) {
						// If url is an object, simulate pre-1.5 signature
						if (_typeof(url) === "object") {
							options = url;
							url = undefined;
						} // Force options to be an object


						options = options || {};

						var transport,
							// URL without anti-cache param
							cacheURL,
							// Response headers
							responseHeadersString,
							responseHeaders,
							// timeout handle
							timeoutTimer,
							// Url cleanup var
							urlAnchor,
							// Request state (becomes false upon send and true upon completion)
							completed,
							// To know if global events are to be dispatched
							fireGlobals,
							// Loop variable
							i,
							// uncached part of the url
							uncached,
							// Create the final options object
							s = jQuery.ajaxSetup({}, options),
							// Callbacks context
							callbackContext = s.context || s,
							// Context for global events is callbackContext if it is a DOM node or jQuery collection
							globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
							// Deferreds
							deferred = jQuery.Deferred(),
							completeDeferred = jQuery.Callbacks("once memory"),
							// Status-dependent callbacks
							_statusCode = s.statusCode || {},
							// Headers (they are sent all at once)
							requestHeaders = {},
							requestHeadersNames = {},
							// Default abort message
							strAbort = "canceled",
							// Fake xhr
							jqXHR = {
								readyState: 0,
								// Builds headers hashtable if needed
								getResponseHeader: function getResponseHeader(key) {
									var match;

									if (completed) {
										if (!responseHeaders) {
											responseHeaders = {};

											while (match = rheaders.exec(responseHeadersString)) {
												responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
											}
										}

										match = responseHeaders[key.toLowerCase() + " "];
									}

									return match == null ? null : match.join(", ");
								},
								// Raw string
								getAllResponseHeaders: function getAllResponseHeaders() {
									return completed ? responseHeadersString : null;
								},
								// Caches the header
								setRequestHeader: function setRequestHeader(name, value) {
									if (completed == null) {
										name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
										requestHeaders[name] = value;
									}

									return this;
								},
								// Overrides response content-type header
								overrideMimeType: function overrideMimeType(type) {
									if (completed == null) {
										s.mimeType = type;
									}

									return this;
								},
								// Status-dependent callbacks
								statusCode: function statusCode(map) {
									var code;

									if (map) {
										if (completed) {
											// Execute the appropriate callbacks
											jqXHR.always(map[jqXHR.status]);
										} else {
											// Lazy-add the new callbacks in a way that preserves old ones
											for (code in map) {
												_statusCode[code] = [_statusCode[code], map[code]];
											}
										}
									}

									return this;
								},
								// Cancel the request
								abort: function abort(statusText) {
									var finalText = statusText || strAbort;

									if (transport) {
										transport.abort(finalText);
									}

									done(0, finalText);
									return this;
								}
							}; // Attach deferreds


						deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
						// Handle falsy url in the settings object (#10093: consistency with old signature)
						// We also use the url parameter if available

						s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

						s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

						s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

						if (s.crossDomain == null) {
							urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
							// IE throws exception on accessing the href property if url is malformed,
							// e.g. http://example.com:80x/

							try {
								urlAnchor.href = s.url; // Support: IE <=8 - 11 only
								// Anchor's host property isn't correctly set when s.url is relative

								urlAnchor.href = urlAnchor.href;
								s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
							} catch (e) {
								// If there is an error parsing the URL, assume it is crossDomain,
								// it can be rejected by the transport if it is invalid
								s.crossDomain = true;
							}
						} // Convert data if not already a string


						if (s.data && s.processData && typeof s.data !== "string") {
							s.data = jQuery.param(s.data, s.traditional);
						} // Apply prefilters


						inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

						if (completed) {
							return jqXHR;
						} // We can fire global events as of now if asked to
						// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


						fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

						if (fireGlobals && jQuery.active++ === 0) {
							jQuery.event.trigger("ajaxStart");
						} // Uppercase the type


						s.type = s.type.toUpperCase(); // Determine if request has content

						s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
						// and/or If-None-Match header later on
						// Remove hash to simplify url manipulation

						cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

						if (!s.hasContent) {
							// Remember the hash so we can put it back
							uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

							if (s.data && (s.processData || typeof s.data === "string")) {
								cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

								delete s.data;
							} // Add or update anti-cache param if needed


							if (s.cache === false) {
								cacheURL = cacheURL.replace(rantiCache, "$1");
								uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
							} // Put hash and anti-cache on the URL that will be requested (gh-1732)


							s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
						} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
							s.data = s.data.replace(r20, "+");
						} // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


						if (s.ifModified) {
							if (jQuery.lastModified[cacheURL]) {
								jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
							}

							if (jQuery.etag[cacheURL]) {
								jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
							}
						} // Set the correct header, if data is being sent


						if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
							jqXHR.setRequestHeader("Content-Type", s.contentType);
						} // Set the Accepts header for the server, depending on the dataType


						jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

						for (i in s.headers) {
							jqXHR.setRequestHeader(i, s.headers[i]);
						} // Allow custom headers/mimetypes and early abort


						if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
							// Abort if not done already and return
							return jqXHR.abort();
						} // Aborting is no longer a cancellation


						strAbort = "abort"; // Install callbacks on deferreds

						completeDeferred.add(s.complete);
						jqXHR.done(s.success);
						jqXHR.fail(s.error); // Get transport

						transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

						if (!transport) {
							done(-1, "No Transport");
						} else {
							jqXHR.readyState = 1; // Send global event

							if (fireGlobals) {
								globalEventContext.trigger("ajaxSend", [jqXHR, s]);
							} // If request was aborted inside ajaxSend, stop there


							if (completed) {
								return jqXHR;
							} // Timeout


							if (s.async && s.timeout > 0) {
								timeoutTimer = window.setTimeout(function () {
									jqXHR.abort("timeout");
								}, s.timeout);
							}

							try {
								completed = false;
								transport.send(requestHeaders, done);
							} catch (e) {
								// Rethrow post-completion exceptions
								if (completed) {
									throw e;
								} // Propagate others as results


								done(-1, e);
							}
						} // Callback for when everything is done


						function done(status, nativeStatusText, responses, headers) {
							var isSuccess,
								success,
								error,
								response,
								modified,
								statusText = nativeStatusText; // Ignore repeat invocations

							if (completed) {
								return;
							}

							completed = true; // Clear timeout if it exists

							if (timeoutTimer) {
								window.clearTimeout(timeoutTimer);
							} // Dereference transport for early garbage collection
							// (no matter how long the jqXHR object will be used)


							transport = undefined; // Cache response headers

							responseHeadersString = headers || ""; // Set readyState

							jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

							isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

							if (responses) {
								response = ajaxHandleResponses(s, jqXHR, responses);
							} // Use a noop converter for missing script


							if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
								s.converters["text script"] = function () {
								};
							} // Convert no matter what (that way responseXXX fields are always set)


							response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

							if (isSuccess) {
								// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
								if (s.ifModified) {
									modified = jqXHR.getResponseHeader("Last-Modified");

									if (modified) {
										jQuery.lastModified[cacheURL] = modified;
									}

									modified = jqXHR.getResponseHeader("etag");

									if (modified) {
										jQuery.etag[cacheURL] = modified;
									}
								} // if no content


								if (status === 204 || s.type === "HEAD") {
									statusText = "nocontent"; // if not modified
								} else if (status === 304) {
									statusText = "notmodified"; // If we have data, let's convert it
								} else {
									statusText = response.state;
									success = response.data;
									error = response.error;
									isSuccess = !error;
								}
							} else {
								// Extract error from statusText and normalize for non-aborts
								error = statusText;

								if (status || !statusText) {
									statusText = "error";

									if (status < 0) {
										status = 0;
									}
								}
							} // Set data for the fake xhr object


							jqXHR.status = status;
							jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

							if (isSuccess) {
								deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
							} else {
								deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
							} // Status-dependent callbacks


							jqXHR.statusCode(_statusCode);
							_statusCode = undefined;

							if (fireGlobals) {
								globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
							} // Complete


							completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

							if (fireGlobals) {
								globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

								if (!--jQuery.active) {
									jQuery.event.trigger("ajaxStop");
								}
							}
						}

						return jqXHR;
					},
					getJSON: function getJSON(url, data, callback) {
						return jQuery.get(url, data, callback, "json");
					},
					getScript: function getScript(url, callback) {
						return jQuery.get(url, undefined, callback, "script");
					}
				});
				jQuery.each(["get", "post"], function (_i, method) {
					jQuery[method] = function (url, data, callback, type) {
						// Shift arguments if data argument was omitted
						if (isFunction(data)) {
							type = type || callback;
							callback = data;
							data = undefined;
						} // The url can be an options object (which then must have .url)


						return jQuery.ajax(jQuery.extend({
							url: url,
							type: method,
							dataType: type,
							data: data,
							success: callback
						}, jQuery.isPlainObject(url) && url));
					};
				});
				jQuery.ajaxPrefilter(function (s) {
					var i;

					for (i in s.headers) {
						if (i.toLowerCase() === "content-type") {
							s.contentType = s.headers[i] || "";
						}
					}
				});

				jQuery._evalUrl = function (url, options, doc) {
					return jQuery.ajax({
						url: url,
						// Make this explicit, since user can override this through ajaxSetup (#11264)
						type: "GET",
						dataType: "script",
						cache: true,
						async: false,
						global: false,
						// Only evaluate the response if it is successful (gh-4126)
						// dataFilter is not invoked for failure responses, so using it instead
						// of the default converter is kludgy but it works.
						converters: {
							"text script": function textScript() {
							}
						},
						dataFilter: function dataFilter(response) {
							jQuery.globalEval(response, options, doc);
						}
					});
				};

				jQuery.fn.extend({
					wrapAll: function wrapAll(html) {
						var wrap;

						if (this[0]) {
							if (isFunction(html)) {
								html = html.call(this[0]);
							} // The elements to wrap the target around


							wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

							if (this[0].parentNode) {
								wrap.insertBefore(this[0]);
							}

							wrap.map(function () {
								var elem = this;

								while (elem.firstElementChild) {
									elem = elem.firstElementChild;
								}

								return elem;
							}).append(this);
						}

						return this;
					},
					wrapInner: function wrapInner(html) {
						if (isFunction(html)) {
							return this.each(function (i) {
								jQuery(this).wrapInner(html.call(this, i));
							});
						}

						return this.each(function () {
							var self = jQuery(this),
								contents = self.contents();

							if (contents.length) {
								contents.wrapAll(html);
							} else {
								self.append(html);
							}
						});
					},
					wrap: function wrap(html) {
						var htmlIsFunction = isFunction(html);
						return this.each(function (i) {
							jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
						});
					},
					unwrap: function unwrap(selector) {
						this.parent(selector).not("body").each(function () {
							jQuery(this).replaceWith(this.childNodes);
						});
						return this;
					}
				});

				jQuery.expr.pseudos.hidden = function (elem) {
					return !jQuery.expr.pseudos.visible(elem);
				};

				jQuery.expr.pseudos.visible = function (elem) {
					return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
				};

				jQuery.ajaxSettings.xhr = function () {
					try {
						return new window.XMLHttpRequest();
					} catch (e) {
					}
				};

				var xhrSuccessStatus = {
						// File protocol always yields status code 0, assume 200
						0: 200,
						// Support: IE <=9 only
						// #1450: sometimes IE returns 1223 when it should be 204
						1223: 204
					},
					xhrSupported = jQuery.ajaxSettings.xhr();
				support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
				support.ajax = xhrSupported = !!xhrSupported;
				jQuery.ajaxTransport(function (options) {
					var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


					if (support.cors || xhrSupported && !options.crossDomain) {
						return {
							send: function send(headers, complete) {
								var i,
									xhr = options.xhr();
								xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

								if (options.xhrFields) {
									for (i in options.xhrFields) {
										xhr[i] = options.xhrFields[i];
									}
								} // Override mime type if needed


								if (options.mimeType && xhr.overrideMimeType) {
									xhr.overrideMimeType(options.mimeType);
								} // X-Requested-With header
								// For cross-domain requests, seeing as conditions for a preflight are
								// akin to a jigsaw puzzle, we simply never set it to be sure.
								// (it can always be set on a per-request basis or even using ajaxSetup)
								// For same-domain requests, won't change header if already provided.


								if (!options.crossDomain && !headers["X-Requested-With"]) {
									headers["X-Requested-With"] = "XMLHttpRequest";
								} // Set headers


								for (i in headers) {
									xhr.setRequestHeader(i, headers[i]);
								} // Callback


								_callback = function callback(type) {
									return function () {
										if (_callback) {
											_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

											if (type === "abort") {
												xhr.abort();
											} else if (type === "error") {
												// Support: IE <=9 only
												// On a manual native abort, IE9 throws
												// errors on any property access that is not readyState
												if (typeof xhr.status !== "number") {
													complete(0, "error");
												} else {
													complete( // File: protocol always yields status 0; see #8605, #14207
														xhr.status, xhr.statusText);
												}
											} else {
												complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
													// IE9 has no XHR2 but throws on binary (trac-11426)
													// For XHR2 non-text, let the caller handle it (gh-2498)
													(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
														binary: xhr.response
													} : {
														text: xhr.responseText
													}, xhr.getAllResponseHeaders());
											}
										}
									};
								}; // Listen to events


								xhr.onload = _callback();
								errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
								// Use onreadystatechange to replace onabort
								// to handle uncaught aborts

								if (xhr.onabort !== undefined) {
									xhr.onabort = errorCallback;
								} else {
									xhr.onreadystatechange = function () {
										// Check readyState before timeout as it changes
										if (xhr.readyState === 4) {
											// Allow onerror to be called first,
											// but that will not handle a native abort
											// Also, save errorCallback to a variable
											// as xhr.onerror cannot be accessed
											window.setTimeout(function () {
												if (_callback) {
													errorCallback();
												}
											});
										}
									};
								} // Create the abort callback


								_callback = _callback("abort");

								try {
									// Do send the request (this may raise an exception)
									xhr.send(options.hasContent && options.data || null);
								} catch (e) {
									// #14683: Only rethrow if this hasn't been notified as an error yet
									if (_callback) {
										throw e;
									}
								}
							},
							abort: function abort() {
								if (_callback) {
									_callback();
								}
							}
						};
					}
				}); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

				jQuery.ajaxPrefilter(function (s) {
					if (s.crossDomain) {
						s.contents.script = false;
					}
				}); // Install script dataType

				jQuery.ajaxSetup({
					accepts: {
						script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
					},
					contents: {
						script: /\b(?:java|ecma)script\b/
					},
					converters: {
						"text script": function textScript(text) {
							jQuery.globalEval(text);
							return text;
						}
					}
				}); // Handle cache's special case and crossDomain

				jQuery.ajaxPrefilter("script", function (s) {
					if (s.cache === undefined) {
						s.cache = false;
					}

					if (s.crossDomain) {
						s.type = "GET";
					}
				}); // Bind script tag hack transport

				jQuery.ajaxTransport("script", function (s) {
					// This transport only deals with cross domain or forced-by-attrs requests
					if (s.crossDomain || s.scriptAttrs) {
						var script, _callback2;

						return {
							send: function send(_, complete) {
								script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
									charset: s.scriptCharset,
									src: s.url
								}).on("load error", _callback2 = function callback(evt) {
									script.remove();
									_callback2 = null;

									if (evt) {
										complete(evt.type === "error" ? 404 : 200, evt.type);
									}
								}); // Use native DOM manipulation to avoid our domManip AJAX trickery

								document.head.appendChild(script[0]);
							},
							abort: function abort() {
								if (_callback2) {
									_callback2();
								}
							}
						};
					}
				});
				var oldCallbacks = [],
					rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

				jQuery.ajaxSetup({
					jsonp: "callback",
					jsonpCallback: function jsonpCallback() {
						var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
						this[callback] = true;
						return callback;
					}
				}); // Detect, normalize options and install callbacks for jsonp requests

				jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
					var callbackName,
						overwritten,
						responseContainer,
						jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

					if (jsonProp || s.dataTypes[0] === "jsonp") {
						// Get callback name, remembering preexisting value associated with it
						callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

						if (jsonProp) {
							s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
						} else if (s.jsonp !== false) {
							s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
						} // Use data converter to retrieve json after script execution


						s.converters["script json"] = function () {
							if (!responseContainer) {
								jQuery.error(callbackName + " was not called");
							}

							return responseContainer[0];
						}; // Force json dataType


						s.dataTypes[0] = "json"; // Install callback

						overwritten = window[callbackName];

						window[callbackName] = function () {
							responseContainer = arguments;
						}; // Clean-up function (fires after converters)


						jqXHR.always(function () {
							// If previous value didn't exist - remove it
							if (overwritten === undefined) {
								jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
							} else {
								window[callbackName] = overwritten;
							} // Save back as free


							if (s[callbackName]) {
								// Make sure that re-using the options doesn't screw things around
								s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

								oldCallbacks.push(callbackName);
							} // Call if it was a function and we have a response


							if (responseContainer && isFunction(overwritten)) {
								overwritten(responseContainer[0]);
							}

							responseContainer = overwritten = undefined;
						}); // Delegate to script

						return "script";
					}
				}); // Support: Safari 8 only
				// In Safari 8 documents created via document.implementation.createHTMLDocument
				// collapse sibling forms: the second one becomes a child of the first one.
				// Because of that, this security measure has to be disabled in Safari 8.
				// https://bugs.webkit.org/show_bug.cgi?id=137337

				support.createHTMLDocument = function () {
					var body = document.implementation.createHTMLDocument("").body;
					body.innerHTML = "<form></form><form></form>";
					return body.childNodes.length === 2;
				}(); // Argument "data" should be string of html
				// context (optional): If specified, the fragment will be created in this context,
				// defaults to document
				// keepScripts (optional): If true, will include scripts passed in the html string


				jQuery.parseHTML = function (data, context, keepScripts) {
					if (typeof data !== "string") {
						return [];
					}

					if (typeof context === "boolean") {
						keepScripts = context;
						context = false;
					}

					var base, parsed, scripts;

					if (!context) {
						// Stop scripts or inline event handlers from being executed immediately
						// by using document.implementation
						if (support.createHTMLDocument) {
							context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
							// so any parsed elements with URLs
							// are based on the document's URL (gh-2965)

							base = context.createElement("base");
							base.href = document.location.href;
							context.head.appendChild(base);
						} else {
							context = document;
						}
					}

					parsed = rsingleTag.exec(data);
					scripts = !keepScripts && []; // Single tag

					if (parsed) {
						return [context.createElement(parsed[1])];
					}

					parsed = buildFragment([data], context, scripts);

					if (scripts && scripts.length) {
						jQuery(scripts).remove();
					}

					return jQuery.merge([], parsed.childNodes);
				};
				/**
				 * Load a url into a page
				 */


				jQuery.fn.load = function (url, params, callback) {
					var selector,
						type,
						response,
						self = this,
						off = url.indexOf(" ");

					if (off > -1) {
						selector = stripAndCollapse(url.slice(off));
						url = url.slice(0, off);
					} // If it's a function


					if (isFunction(params)) {
						// We assume that it's the callback
						callback = params;
						params = undefined; // Otherwise, build a param string
					} else if (params && _typeof(params) === "object") {
						type = "POST";
					} // If we have elements to modify, make the request


					if (self.length > 0) {
						jQuery.ajax({
							url: url,
							// If "type" variable is undefined, then "GET" method will be used.
							// Make value of this field explicit since
							// user can override it through ajaxSetup method
							type: type || "GET",
							dataType: "html",
							data: params
						}).done(function (responseText) {
							// Save response for use in complete callback
							response = arguments;
							self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
								// Exclude scripts to avoid IE 'Permission Denied' errors
								jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
								responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
							// but they are ignored because response was set above.
							// If it fails, this function gets "jqXHR", "status", "error"
						}).always(callback && function (jqXHR, status) {
							self.each(function () {
								callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
							});
						});
					}

					return this;
				};

				jQuery.expr.pseudos.animated = function (elem) {
					return jQuery.grep(jQuery.timers, function (fn) {
						return elem === fn.elem;
					}).length;
				};

				jQuery.offset = {
					setOffset: function setOffset(elem, options, i) {
						var curPosition,
							curLeft,
							curCSSTop,
							curTop,
							curOffset,
							curCSSLeft,
							calculatePosition,
							position = jQuery.css(elem, "position"),
							curElem = jQuery(elem),
							props = {}; // Set position first, in-case top/left are set even on static elem

						if (position === "static") {
							elem.style.position = "relative";
						}

						curOffset = curElem.offset();
						curCSSTop = jQuery.css(elem, "top");
						curCSSLeft = jQuery.css(elem, "left");
						calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
						// top or left is auto and position is either absolute or fixed

						if (calculatePosition) {
							curPosition = curElem.position();
							curTop = curPosition.top;
							curLeft = curPosition.left;
						} else {
							curTop = parseFloat(curCSSTop) || 0;
							curLeft = parseFloat(curCSSLeft) || 0;
						}

						if (isFunction(options)) {
							// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
							options = options.call(elem, i, jQuery.extend({}, curOffset));
						}

						if (options.top != null) {
							props.top = options.top - curOffset.top + curTop;
						}

						if (options.left != null) {
							props.left = options.left - curOffset.left + curLeft;
						}

						if ("using" in options) {
							options.using.call(elem, props);
						} else {
							if (typeof props.top === "number") {
								props.top += "px";
							}

							if (typeof props.left === "number") {
								props.left += "px";
							}

							curElem.css(props);
						}
					}
				};
				jQuery.fn.extend({
					// offset() relates an element's border box to the document origin
					offset: function offset(options) {
						// Preserve chaining for setter
						if (arguments.length) {
							return options === undefined ? this : this.each(function (i) {
								jQuery.offset.setOffset(this, options, i);
							});
						}

						var rect,
							win,
							elem = this[0];

						if (!elem) {
							return;
						} // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
						// Support: IE <=11 only
						// Running getBoundingClientRect on a
						// disconnected node in IE throws an error


						if (!elem.getClientRects().length) {
							return {
								top: 0,
								left: 0
							};
						} // Get document-relative position by adding viewport scroll to viewport-relative gBCR


						rect = elem.getBoundingClientRect();
						win = elem.ownerDocument.defaultView;
						return {
							top: rect.top + win.pageYOffset,
							left: rect.left + win.pageXOffset
						};
					},
					// position() relates an element's margin box to its offset parent's padding box
					// This corresponds to the behavior of CSS absolute positioning
					position: function position() {
						if (!this[0]) {
							return;
						}

						var offsetParent,
							offset,
							doc,
							elem = this[0],
							parentOffset = {
								top: 0,
								left: 0
							}; // position:fixed elements are offset from the viewport, which itself always has zero offset

						if (jQuery.css(elem, "position") === "fixed") {
							// Assume position:fixed implies availability of getBoundingClientRect
							offset = elem.getBoundingClientRect();
						} else {
							offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
							// when a statically positioned element is identified

							doc = elem.ownerDocument;
							offsetParent = elem.offsetParent || doc.documentElement;

							while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
								offsetParent = offsetParent.parentNode;
							}

							if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
								// Incorporate borders into its offset, since they are outside its content origin
								parentOffset = jQuery(offsetParent).offset();
								parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
								parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
							}
						} // Subtract parent offsets and element margins


						return {
							top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
							left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
						};
					},
					// This method will return documentElement in the following cases:
					// 1) For the element inside the iframe without offsetParent, this method will return
					//    documentElement of the parent window
					// 2) For the hidden or detached element
					// 3) For body or html element, i.e. in case of the html node - it will return itself
					//
					// but those exceptions were never presented as a real life use-cases
					// and might be considered as more preferable results.
					//
					// This logic, however, is not guaranteed and can change at any point in the future
					offsetParent: function offsetParent() {
						return this.map(function () {
							var offsetParent = this.offsetParent;

							while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
								offsetParent = offsetParent.offsetParent;
							}

							return offsetParent || documentElement;
						});
					}
				}); // Create scrollLeft and scrollTop methods

				jQuery.each({
					scrollLeft: "pageXOffset",
					scrollTop: "pageYOffset"
				}, function (method, prop) {
					var top = "pageYOffset" === prop;

					jQuery.fn[method] = function (val) {
						return access(this, function (elem, method, val) {
							// Coalesce documents and windows
							var win;

							if (isWindow(elem)) {
								win = elem;
							} else if (elem.nodeType === 9) {
								win = elem.defaultView;
							}

							if (val === undefined) {
								return win ? win[prop] : elem[method];
							}

							if (win) {
								win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
							} else {
								elem[method] = val;
							}
						}, method, val, arguments.length);
					};
				}); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
				// Add the top/left cssHooks using jQuery.fn.position
				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
				// getComputedStyle returns percent when specified for top/left/bottom/right;
				// rather than make the css module depend on the offset module, just check for it here

				jQuery.each(["top", "left"], function (_i, prop) {
					jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
						if (computed) {
							computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

							return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
						}
					});
				}); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

				jQuery.each({
					Height: "height",
					Width: "width"
				}, function (name, type) {
					jQuery.each({
						padding: "inner" + name,
						content: type,
						"": "outer" + name
					}, function (defaultExtra, funcName) {
						// Margin is only for outerHeight, outerWidth
						jQuery.fn[funcName] = function (margin, value) {
							var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
								extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
							return access(this, function (elem, type, value) {
								var doc;

								if (isWindow(elem)) {
									// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
									return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
								} // Get document width or height


								if (elem.nodeType === 9) {
									doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
									// whichever is greatest

									return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
								}

								return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
									jQuery.css(elem, type, extra) : // Set width or height on the element
									jQuery.style(elem, type, value, extra);
							}, type, chainable ? margin : undefined, chainable);
						};
					});
				});
				jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
					jQuery.fn[type] = function (fn) {
						return this.on(type, fn);
					};
				});
				jQuery.fn.extend({
					bind: function bind(types, data, fn) {
						return this.on(types, null, data, fn);
					},
					unbind: function unbind(types, fn) {
						return this.off(types, null, fn);
					},
					delegate: function delegate(selector, types, data, fn) {
						return this.on(types, selector, data, fn);
					},
					undelegate: function undelegate(selector, types, fn) {
						// ( namespace ) or ( selector, types [, fn] )
						return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
					},
					hover: function hover(fnOver, fnOut) {
						return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
					}
				});
				jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
					// Handle event binding
					jQuery.fn[name] = function (data, fn) {
						return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
					};
				}); // Support: Android <=4.0 only
				// Make sure we trim BOM and NBSP

				var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
				// arguments.
				// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
				// However, it is not slated for removal any time soon

				jQuery.proxy = function (fn, context) {
					var tmp, args, proxy;

					if (typeof context === "string") {
						tmp = fn[context];
						context = fn;
						fn = tmp;
					} // Quick check to determine if target is callable, in the spec
					// this throws a TypeError, but we will just return undefined.


					if (!isFunction(fn)) {
						return undefined;
					} // Simulated bind


					args = _slice.call(arguments, 2);

					proxy = function proxy() {
						return fn.apply(context || this, args.concat(_slice.call(arguments)));
					}; // Set the guid of unique handler to the same of original handler, so it can be removed


					proxy.guid = fn.guid = fn.guid || jQuery.guid++;
					return proxy;
				};

				jQuery.holdReady = function (hold) {
					if (hold) {
						jQuery.readyWait++;
					} else {
						jQuery.ready(true);
					}
				};

				jQuery.isArray = Array.isArray;
				jQuery.parseJSON = JSON.parse;
				jQuery.nodeName = nodeName;
				jQuery.isFunction = isFunction;
				jQuery.isWindow = isWindow;
				jQuery.camelCase = camelCase;
				jQuery.type = toType;
				jQuery.now = Date.now;

				jQuery.isNumeric = function (obj) {
					// As of jQuery 3.0, isNumeric is limited to
					// strings and numbers (primitives or objects)
					// that can be coerced to finite numbers (gh-2662)
					var type = jQuery.type(obj);
					return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
						// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
						// subtraction forces infinities to NaN
						!isNaN(obj - parseFloat(obj));
				};

				jQuery.trim = function (text) {
					return text == null ? "" : (text + "").replace(rtrim, "");
				}; // Register as a named AMD module, since jQuery can be concatenated with other
				// files that may use define, but not via a proper concatenation script that
				// understands anonymous AMD modules. A named AMD is safest and most robust
				// way to register. Lowercase jquery is used because AMD module names are
				// derived from file names, and jQuery is normally delivered in a lowercase
				// file name. Do this after creating the global so that if an AMD module wants
				// to call noConflict to hide this version of jQuery, it will work.
				// Note that for maximum portability, libraries that are not jQuery should
				// declare themselves as anonymous modules, and avoid setting a global if an
				// AMD loader is present. jQuery is a special case. For more information, see
				// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


				if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
						return jQuery;
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				}

				var // Map over jQuery in case of overwrite
					_jQuery = window.jQuery,
					// Map over the $ in case of overwrite
					_$ = window.$;

				jQuery.noConflict = function (deep) {
					if (window.$ === jQuery) {
						window.$ = _$;
					}

					if (deep && window.jQuery === jQuery) {
						window.jQuery = _jQuery;
					}

					return jQuery;
				}; // Expose jQuery and $ identifiers, even in AMD
				// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
				// and CommonJS for browser emulators (#13566)


				if (typeof noGlobal === "undefined") {
					window.jQuery = window.$ = jQuery;
				}

				return jQuery;
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(6)(module)))

		/***/
	}),
	/* 1 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function ($, jQuery) {/* harmony export (binding) */
			__webpack_require__.d(__webpack_exports__, "a", function () {
				return carouselById;
			});
			/* harmony export (binding) */
			__webpack_require__.d(__webpack_exports__, "c", function () {
				return mobilePredNextButtons;
			});
			/* harmony export (binding) */
			__webpack_require__.d(__webpack_exports__, "b", function () {
				return desctopPredNextButtons;
			});
			/* harmony import */
			var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
			/* harmony import */
			var bootstrap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap__WEBPACK_IMPORTED_MODULE_0__);

			function carouselById(carousel, carouselNav, vertical) {
				$(carousel).not('.slick-initialized').slick({
					initialSlide: 0,
					dots: false,
					infinite: false,
					arrows: false,
					slidesToShow: 1,
					slidesToScroll: 1,
					rows: 0,
					centerMode: true,
					mobileFirst: false,
					adaptiveHeight: true,
					asNavFor: carouselNav,
					responsive: [{
						breakpoint: 992,
						settings: {
							arrows: false,
							slidesToShow: 1,
							centerMode: true,
							variableWidth: false,
							dots: false,
							infinite: false
						}
					}]
				});
				$(carouselNav).not('.slick-initialized').slick({
					slidesToShow: 5,
					infinite: true,
					slidesToScroll: 1,
					asNavFor: carousel,
					vertical: vertical,
					dots: false,
					centerMode: true,
					focusOnSelect: true,
					arrows: false,
					responsive: [{
						breakpoint: 992,
						settings: {
							slidesToShow: 3,
							centerMode: true,
							dots: false,
							infinite: true
						}
					}]
				});
			}

			function mobilePredNextButtons(container, buttonPrev, buttonNext, maxWidth) {
				var contentWidth = container.width();
				console.log(contentWidth);
				console.log(maxWidth); //maxWidth+30 - because there is a moment when the last letter of the last link is hidden, but the arrows
				//doesn't shows

				if (contentWidth > 992 || contentWidth >= maxWidth + 30) {
					buttonPrev.css('display', 'none');
					buttonNext.css('display', 'none');
				}

				jQuery.fn.scrollCenter = function (elem, speed) {
					var active = jQuery(this).find(elem),
						activeWidth = active.width() / 2,
						pos = active.position().left + activeWidth,
						elpos = jQuery(this).scrollLeft(),
						elW = jQuery(this).width();
					pos = pos + elpos - elW / 2; // for center position if you want adjust then change this

					jQuery(this).animate({
						scrollLeft: pos
					}, speed == undefined ? 1000 : speed);
					return this;
				};

				if ($(container).find('.home-mobile-buttons-block__link').hasClass('active')) {
					$(container).scrollCenter('.active', 300);
				}

				$(window).on({
					resize: function resize() {
						contentWidth = container.width();

						if (contentWidth > 992 || contentWidth >= maxWidth) {
							buttonPrev.css('display', 'none');
							buttonNext.css('display', 'none');
						}
					}
				}); // on scroll element account nav

				$(container).on('scroll', function (e) {
					// $(container).on('touchmove', function(e) {
					var $elem = $(container),
						newScrollLeft = $elem.scrollLeft(),
						width = $elem.outerWidth(),
						scrollWidth = $elem.get(0).scrollWidth;
					$(buttonPrev).css('display', 'flex');
					$(buttonNext).css('display', 'flex'); // alert(`${scrollWidth}, ${newScrollLeft}, ${width}`);

					if (scrollWidth - Math.round(newScrollLeft) - 1 <= width) {
						$(buttonPrev).css('display', 'flex');
						$(buttonNext).css('display', 'none');
					}

					if (newScrollLeft <= 1) {
						$(buttonPrev).css('display', 'none');
						$(buttonNext).css('display', 'flex');
					}
				}); //click next button

				$(buttonNext).on('click', function (e) {
					e.preventDefault();

					if (!$(this).data('lockedAt') || +new Date() - $(this).data('lockedAt') > 300) {
						var leftPos = $(container).scrollLeft();
						$(buttonPrev).css('display', 'flex');
						$(container).animate({
							// scrollLeft: leftPos + 200
							scrollLeft: leftPos + Math.round(contentWidth / 2)
						}, 800);
					}

					$(this).data('lockedAt', +new Date());
				}); // click preview button

				$(buttonPrev).on('click', function (e) {
					e.preventDefault();

					if (!$(this).data('lockedAt') || +new Date() - $(this).data('lockedAt') > 300) {
						var leftPos = $(container).scrollLeft();
						$(buttonNext).css('display', 'flex');
						$(container).animate({
							// scrollLeft: leftPos - 200
							scrollLeft: leftPos - Math.round(contentWidth / 2)
						}, 800);
					}

					$(this).data('lockedAt', +new Date());
				});
			}

			function desctopPredNextButtons(container, buttonPrev, buttonNext) {
				var contentWidth = container.width();

				if (contentWidth < 992) {
					buttonPrev.css('display', 'none');
					buttonNext.css('display', 'none');
				}

				jQuery.fn.scrollCenter = function (elem, speed) {
					var active = jQuery(this).find(elem),
						activeWidth = active.width() / 2,
						pos = active.position().left + activeWidth,
						elpos = jQuery(this).scrollLeft(),
						elW = jQuery(this).width();
					pos = pos + elpos - elW / 2; // for center position if you want adjust then change this

					jQuery(this).animate({
						scrollLeft: pos
					}, speed == undefined ? 1000 : speed);
					return this;
				};

				if ($(container).find('.home-mobile-buttons-block__link').hasClass('active')) {
					$(container).scrollCenter('.active', 300);
				}

				$(window).on({
					resize: function resize() {
						contentWidth = container.width();

						if (contentWidth < 992) {
							buttonPrev.css('display', 'none');
							buttonNext.css('display', 'none');
						}
					}
				}); // on scroll element account nav

				$(container).on('scroll', function (e) {
					// $(container).on('touchmove', function(e) {
					var $elem = $(container),
						newScrollLeft = $elem.scrollLeft(),
						width = $elem.outerWidth(),
						scrollWidth = $elem.get(0).scrollWidth;
					$(buttonPrev).css('display', 'flex');
					$(buttonNext).css('display', 'flex');

					if (scrollWidth - Math.round(newScrollLeft) - 1 <= width) {
						$(buttonPrev).css('display', 'flex');
						$(buttonNext).css('display', 'none');
					}

					if (newScrollLeft <= 1) {
						$(buttonPrev).css('display', 'none');
						$(buttonNext).css('display', 'flex');
					}
				}); //click next button

				$(buttonNext).on('click', function (e) {
					e.preventDefault();

					if (!$(this).data('lockedAt') || +new Date() - $(this).data('lockedAt') > 300) {
						var leftPos = $(container).scrollLeft();
						$(buttonPrev).css('display', 'flex');
						$(container).animate({
							scrollLeft: leftPos + 200 // scrollLeft: leftPos + Math.round(contentWidth/2)

						}, 800);
					}

					$(this).data('lockedAt', +new Date());
				}); // click preview button

				$(buttonPrev).on('click', function (e) {
					e.preventDefault();

					if (!$(this).data('lockedAt') || +new Date() - $(this).data('lockedAt') > 300) {
						var leftPos = $(container).scrollLeft();
						$(buttonNext).css('display', 'flex');
						$(container).animate({
							scrollLeft: leftPos - 200 // scrollLeft: leftPos - Math.round(contentWidth/2)

						}, 800);
					}

					$(this).data('lockedAt', +new Date());
				});
			}

			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0), __webpack_require__(0)))

		/***/
	}),
	/* 2 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/
		(function (factory) {
			if (true) {
				// AMD. Register as an anonymous module.
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
						(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(function ($) {
			var widgetUuid = 0;
			var widgetSlice = Array.prototype.slice;

			$.cleanData = function (orig) {
				return function (elems) {
					var events, elem, i;

					for (i = 0; (elem = elems[i]) != null; i++) {
						try {
							// Only trigger remove when necessary to save time
							events = $._data(elem, "events");

							if (events && events.remove) {
								$(elem).triggerHandler("remove");
							} // Http://bugs.jquery.com/ticket/8235

						} catch (e) {
						}
					}

					orig(elems);
				};
			}($.cleanData);

			$.widget = function (name, base, prototype) {
				var existingConstructor, constructor, basePrototype; // ProxiedPrototype allows the provided prototype to remain unmodified
				// so that it can be used as a mixin for multiple widgets (#8876)

				var proxiedPrototype = {};
				var namespace = name.split(".")[0];
				name = name.split(".")[1];
				var fullName = namespace + "-" + name;

				if (!prototype) {
					prototype = base;
					base = $.Widget;
				}

				if ($.isArray(prototype)) {
					prototype = $.extend.apply(null, [{}].concat(prototype));
				} // Create selector for plugin


				$.expr[":"][fullName.toLowerCase()] = function (elem) {
					return !!$.data(elem, fullName);
				};

				$[namespace] = $[namespace] || {};
				existingConstructor = $[namespace][name];

				constructor = $[namespace][name] = function (options, element) {
					// Allow instantiation without "new" keyword
					if (!this._createWidget) {
						return new constructor(options, element);
					} // Allow instantiation without initializing for simple inheritance
					// must use "new" keyword (the code above always passes args)


					if (arguments.length) {
						this._createWidget(options, element);
					}
				}; // Extend with the existing constructor to carry over any static properties


				$.extend(constructor, existingConstructor, {
					version: prototype.version,
					// Copy the object used to create the prototype in case we need to
					// redefine the widget later
					_proto: $.extend({}, prototype),
					// Track widgets that inherit from this widget in case this widget is
					// redefined after a widget inherits from it
					_childConstructors: []
				});
				basePrototype = new base(); // We need to make the options hash a property directly on the new instance
				// otherwise we'll modify the options hash on the prototype that we're
				// inheriting from

				basePrototype.options = $.widget.extend({}, basePrototype.options);
				$.each(prototype, function (prop, value) {
					if (!$.isFunction(value)) {
						proxiedPrototype[prop] = value;
						return;
					}

					proxiedPrototype[prop] = function () {
						function _super() {
							return base.prototype[prop].apply(this, arguments);
						}

						function _superApply(args) {
							return base.prototype[prop].apply(this, args);
						}

						return function () {
							var __super = this._super;
							var __superApply = this._superApply;
							var returnValue;
							this._super = _super;
							this._superApply = _superApply;
							returnValue = value.apply(this, arguments);
							this._super = __super;
							this._superApply = __superApply;
							return returnValue;
						};
					}();
				});
				constructor.prototype = $.widget.extend(basePrototype, {
					// TODO: remove support for widgetEventPrefix
					// always use the name + a colon as the prefix, e.g., draggable:start
					// don't prefix for widgets that aren't DOM-based
					widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
				}, proxiedPrototype, {
					constructor: constructor,
					namespace: namespace,
					widgetName: name,
					widgetFullName: fullName
				}); // If this widget is being redefined then we need to find all widgets that
				// are inheriting from it and redefine all of them so that they inherit from
				// the new version of this widget. We're essentially trying to replace one
				// level in the prototype chain.

				if (existingConstructor) {
					$.each(existingConstructor._childConstructors, function (i, child) {
						var childPrototype = child.prototype; // Redefine the child widget using the same prototype that was
						// originally used, but inherit from the new version of the base

						$.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
					}); // Remove the list of existing child constructors from the old constructor
					// so the old child constructors can be garbage collected

					delete existingConstructor._childConstructors;
				} else {
					base._childConstructors.push(constructor);
				}

				$.widget.bridge(name, constructor);
				return constructor;
			};

			$.widget.extend = function (target) {
				var input = widgetSlice.call(arguments, 1);
				var inputIndex = 0;
				var inputLength = input.length;
				var key;
				var value;

				for (; inputIndex < inputLength; inputIndex++) {
					for (key in input[inputIndex]) {
						value = input[inputIndex][key];

						if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
							// Clone objects
							if ($.isPlainObject(value)) {
								target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects
									$.widget.extend({}, value); // Copy everything else by reference
							} else {
								target[key] = value;
							}
						}
					}
				}

				return target;
			};

			$.widget.bridge = function (name, object) {
				var fullName = object.prototype.widgetFullName || name;

				$.fn[name] = function (options) {
					var isMethodCall = typeof options === "string";
					var args = widgetSlice.call(arguments, 1);
					var returnValue = this;

					if (isMethodCall) {
						// If this is an empty collection, we need to have the instance method
						// return undefined instead of the jQuery instance
						if (!this.length && options === "instance") {
							returnValue = undefined;
						} else {
							this.each(function () {
								var methodValue;
								var instance = $.data(this, fullName);

								if (options === "instance") {
									returnValue = instance;
									return false;
								}

								if (!instance) {
									return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
								}

								if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
									return $.error("no such method '" + options + "' for " + name + " widget instance");
								}

								methodValue = instance[options].apply(instance, args);

								if (methodValue !== instance && methodValue !== undefined) {
									returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
									return false;
								}
							});
						}
					} else {
						// Allow multiple hashes to be passed on init
						if (args.length) {
							options = $.widget.extend.apply(null, [options].concat(args));
						}

						this.each(function () {
							var instance = $.data(this, fullName);

							if (instance) {
								instance.option(options || {});

								if (instance._init) {
									instance._init();
								}
							} else {
								$.data(this, fullName, new object(options, this));
							}
						});
					}

					return returnValue;
				};
			};

			$.Widget = function ()
				/* options, element */ {
			};

			$.Widget._childConstructors = [];
			$.Widget.prototype = {
				widgetName: "widget",
				widgetEventPrefix: "",
				defaultElement: "<div>",
				options: {
					classes: {},
					disabled: false,
					// Callbacks
					create: null
				},
				_createWidget: function _createWidget(options, element) {
					element = $(element || this.defaultElement || this)[0];
					this.element = $(element);
					this.uuid = widgetUuid++;
					this.eventNamespace = "." + this.widgetName + this.uuid;
					this.bindings = $();
					this.hoverable = $();
					this.focusable = $();
					this.classesElementLookup = {};

					if (element !== this) {
						$.data(element, this.widgetFullName, this);

						this._on(true, this.element, {
							remove: function remove(event) {
								if (event.target === element) {
									this.destroy();
								}
							}
						});

						this.document = $(element.style ? // Element within the document
							element.ownerDocument : // Element is window or document
							element.document || element);
						this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
					}

					this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

					this._create();

					if (this.options.disabled) {
						this._setOptionDisabled(this.options.disabled);
					}

					this._trigger("create", null, this._getCreateEventData());

					this._init();
				},
				_getCreateOptions: function _getCreateOptions() {
					return {};
				},
				_getCreateEventData: $.noop,
				_create: $.noop,
				_init: $.noop,
				destroy: function destroy() {
					var that = this;

					this._destroy();

					$.each(this.classesElementLookup, function (key, value) {
						that._removeClass(value, key);
					}); // We can probably remove the unbind calls in 2.0
					// all event bindings should go through this._on()

					this.element.off(this.eventNamespace).removeData(this.widgetFullName);
					this.widget().off(this.eventNamespace).removeAttr("aria-disabled"); // Clean up events and states

					this.bindings.off(this.eventNamespace);
				},
				_destroy: $.noop,
				widget: function widget() {
					return this.element;
				},
				option: function option(key, value) {
					var options = key;
					var parts;
					var curOption;
					var i;

					if (arguments.length === 0) {
						// Don't return a reference to the internal hash
						return $.widget.extend({}, this.options);
					}

					if (typeof key === "string") {
						// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
						options = {};
						parts = key.split(".");
						key = parts.shift();

						if (parts.length) {
							curOption = options[key] = $.widget.extend({}, this.options[key]);

							for (i = 0; i < parts.length - 1; i++) {
								curOption[parts[i]] = curOption[parts[i]] || {};
								curOption = curOption[parts[i]];
							}

							key = parts.pop();

							if (arguments.length === 1) {
								return curOption[key] === undefined ? null : curOption[key];
							}

							curOption[key] = value;
						} else {
							if (arguments.length === 1) {
								return this.options[key] === undefined ? null : this.options[key];
							}

							options[key] = value;
						}
					}

					this._setOptions(options);

					return this;
				},
				_setOptions: function _setOptions(options) {
					var key;

					for (key in options) {
						this._setOption(key, options[key]);
					}

					return this;
				},
				_setOption: function _setOption(key, value) {
					if (key === "classes") {
						this._setOptionClasses(value);
					}

					this.options[key] = value;

					if (key === "disabled") {
						this._setOptionDisabled(value);
					}

					return this;
				},
				_setOptionClasses: function _setOptionClasses(value) {
					var classKey, elements, currentElements;

					for (classKey in value) {
						currentElements = this.classesElementLookup[classKey];

						if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
							continue;
						} // We are doing this to create a new jQuery object because the _removeClass() call
						// on the next line is going to destroy the reference to the current elements being
						// tracked. We need to save a copy of this collection so that we can add the new classes
						// below.


						elements = $(currentElements.get());

						this._removeClass(currentElements, classKey); // We don't use _addClass() here, because that uses this.options.classes
						// for generating the string of classes. We want to use the value passed in from
						// _setOption(), this is the new value of the classes option which was passed to
						// _setOption(). We pass this value directly to _classes().


						elements.addClass(this._classes({
							element: elements,
							keys: classKey,
							classes: value,
							add: true
						}));
					}
				},
				_setOptionDisabled: function _setOptionDisabled(value) {
					this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value); // If the widget is becoming disabled, then nothing is interactive


					if (value) {
						this._removeClass(this.hoverable, null, "ui-state-hover");

						this._removeClass(this.focusable, null, "ui-state-focus");
					}
				},
				enable: function enable() {
					return this._setOptions({
						disabled: false
					});
				},
				disable: function disable() {
					return this._setOptions({
						disabled: true
					});
				},
				_classes: function _classes(options) {
					var full = [];
					var that = this;
					options = $.extend({
						element: this.element,
						classes: this.options.classes || {}
					}, options);

					function processClassString(classes, checkOption) {
						var current, i;

						for (i = 0; i < classes.length; i++) {
							current = that.classesElementLookup[classes[i]] || $();

							if (options.add) {
								current = $($.unique(current.get().concat(options.element.get())));
							} else {
								current = $(current.not(options.element).get());
							}

							that.classesElementLookup[classes[i]] = current;
							full.push(classes[i]);

							if (checkOption && options.classes[classes[i]]) {
								full.push(options.classes[classes[i]]);
							}
						}
					}

					this._on(options.element, {
						"remove": "_untrackClassesElement"
					});

					if (options.keys) {
						processClassString(options.keys.match(/\S+/g) || [], true);
					}

					if (options.extra) {
						processClassString(options.extra.match(/\S+/g) || []);
					}

					return full.join(" ");
				},
				_untrackClassesElement: function _untrackClassesElement(event) {
					var that = this;
					$.each(that.classesElementLookup, function (key, value) {
						if ($.inArray(event.target, value) !== -1) {
							that.classesElementLookup[key] = $(value.not(event.target).get());
						}
					});
				},
				_removeClass: function _removeClass(element, keys, extra) {
					return this._toggleClass(element, keys, extra, false);
				},
				_addClass: function _addClass(element, keys, extra) {
					return this._toggleClass(element, keys, extra, true);
				},
				_toggleClass: function _toggleClass(element, keys, extra, add) {
					add = typeof add === "boolean" ? add : extra;
					var shift = typeof element === "string" || element === null,
						options = {
							extra: shift ? keys : extra,
							keys: shift ? element : keys,
							element: shift ? this.element : element,
							add: add
						};
					options.element.toggleClass(this._classes(options), add);
					return this;
				},
				_on: function _on(suppressDisabledCheck, element, handlers) {
					var delegateElement;
					var instance = this; // No suppressDisabledCheck flag, shuffle arguments

					if (typeof suppressDisabledCheck !== "boolean") {
						handlers = element;
						element = suppressDisabledCheck;
						suppressDisabledCheck = false;
					} // No element argument, shuffle and use this.element


					if (!handlers) {
						handlers = element;
						element = this.element;
						delegateElement = this.widget();
					} else {
						element = delegateElement = $(element);
						this.bindings = this.bindings.add(element);
					}

					$.each(handlers, function (event, handler) {
						function handlerProxy() {
							// Allow widgets to customize the disabled handling
							// - disabled as an array instead of boolean
							// - disabled class as method for disabling individual parts
							if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
								return;
							}

							return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
						} // Copy the guid so direct unbinding works


						if (typeof handler !== "string") {
							handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
						}

						var match = event.match(/^([\w:-]*)\s*(.*)$/);
						var eventName = match[1] + instance.eventNamespace;
						var selector = match[2];

						if (selector) {
							delegateElement.on(eventName, selector, handlerProxy);
						} else {
							element.on(eventName, handlerProxy);
						}
					});
				},
				_off: function _off(element, eventName) {
					eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
					element.off(eventName).off(eventName); // Clear the stack to avoid memory leaks (#10056)

					this.bindings = $(this.bindings.not(element).get());
					this.focusable = $(this.focusable.not(element).get());
					this.hoverable = $(this.hoverable.not(element).get());
				},
				_delay: function _delay(handler, delay) {
					function handlerProxy() {
						return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
					}

					var instance = this;
					return setTimeout(handlerProxy, delay || 0);
				},
				_hoverable: function _hoverable(element) {
					this.hoverable = this.hoverable.add(element);

					this._on(element, {
						mouseenter: function mouseenter(event) {
							this._addClass($(event.currentTarget), null, "ui-state-hover");
						},
						mouseleave: function mouseleave(event) {
							this._removeClass($(event.currentTarget), null, "ui-state-hover");
						}
					});
				},
				_focusable: function _focusable(element) {
					this.focusable = this.focusable.add(element);

					this._on(element, {
						focusin: function focusin(event) {
							this._addClass($(event.currentTarget), null, "ui-state-focus");
						},
						focusout: function focusout(event) {
							this._removeClass($(event.currentTarget), null, "ui-state-focus");
						}
					});
				},
				_trigger: function _trigger(type, event, data) {
					var prop, orig;
					var callback = this.options[type];
					data = data || {};
					event = $.Event(event);
					event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); // The original event may come from any element
					// so we need to reset the target on the new event

					event.target = this.element[0]; // Copy original event properties over to the new event

					orig = event.originalEvent;

					if (orig) {
						for (prop in orig) {
							if (!(prop in event)) {
								event[prop] = orig[prop];
							}
						}
					}

					this.element.trigger(event, data);
					return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
				}
			};
			$.each({
				show: "fadeIn",
				hide: "fadeOut"
			}, function (method, defaultEffect) {
				$.Widget.prototype["_" + method] = function (element, options, callback) {
					if (typeof options === "string") {
						options = {
							effect: options
						};
					}

					var hasOptions;
					var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
					options = options || {};

					if (typeof options === "number") {
						options = {
							duration: options
						};
					}

					hasOptions = !$.isEmptyObject(options);
					options.complete = callback;

					if (options.delay) {
						element.delay(options.delay);
					}

					if (hasOptions && $.effects && $.effects.effect[effectName]) {
						element[method](options);
					} else if (effectName !== method && element[effectName]) {
						element[effectName](options.duration, options.easing, callback);
					} else {
						element.queue(function (next) {
							$(this)[method]();

							if (callback) {
								callback.call(element[0]);
							}

							next();
						});
					}
				};
			});
			return $.widget;
		});

		/***/
	}),
	/* 3 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*!
  * Bootstrap v4.6.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
		(function (global, factory) {
			(false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(0), __webpack_require__(4)) : true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(0), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
			__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
		})(this, function (exports, $, Popper) {
			'use strict';

			function _interopDefaultLegacy(e) {
				return e && _typeof(e) === 'object' && 'default' in e ? e : {
					'default': e
				};
			}

			var $__default = /*#__PURE__*/_interopDefaultLegacy($);

			var Popper__default = /*#__PURE__*/_interopDefaultLegacy(Popper);

			function _defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];
					descriptor.enumerable = descriptor.enumerable || false;
					descriptor.configurable = true;
					if ("value" in descriptor) descriptor.writable = true;
					Object.defineProperty(target, descriptor.key, descriptor);
				}
			}

			function _createClass(Constructor, protoProps, staticProps) {
				if (protoProps) _defineProperties(Constructor.prototype, protoProps);
				if (staticProps) _defineProperties(Constructor, staticProps);
				return Constructor;
			}

			function _extends() {
				_extends = Object.assign || function (target) {
					for (var i = 1; i < arguments.length; i++) {
						var source = arguments[i];

						for (var key in source) {
							if (Object.prototype.hasOwnProperty.call(source, key)) {
								target[key] = source[key];
							}
						}
					}

					return target;
				};

				return _extends.apply(this, arguments);
			}

			function _inheritsLoose(subClass, superClass) {
				subClass.prototype = Object.create(superClass.prototype);
				subClass.prototype.constructor = subClass;
				subClass.__proto__ = superClass;
			}

			/**
			 * --------------------------------------------------------------------------
			 * Bootstrap (v4.6.0): util.js
			 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
			 * --------------------------------------------------------------------------
			 */

			/**
			 * ------------------------------------------------------------------------
			 * Private TransitionEnd Helpers
			 * ------------------------------------------------------------------------
			 */


			var TRANSITION_END = 'transitionend';
			var MAX_UID = 1000000;
			var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

			function toType(obj) {
				if (obj === null || typeof obj === 'undefined') {
					return "" + obj;
				}

				return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
			}

			function getSpecialTransitionEndEvent() {
				return {
					bindType: TRANSITION_END,
					delegateType: TRANSITION_END,
					handle: function handle(event) {
						if ($__default['default'](event.target).is(this)) {
							return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
						}

						return undefined;
					}
				};
			}

			function transitionEndEmulator(duration) {
				var _this = this;

				var called = false;
				$__default['default'](this).one(Util.TRANSITION_END, function () {
					called = true;
				});
				setTimeout(function () {
					if (!called) {
						Util.triggerTransitionEnd(_this);
					}
				}, duration);
				return this;
			}

			function setTransitionEndSupport() {
				$__default['default'].fn.emulateTransitionEnd = transitionEndEmulator;
				$__default['default'].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
			}

			/**
			 * --------------------------------------------------------------------------
			 * Public Util Api
			 * --------------------------------------------------------------------------
			 */


			var Util = {
				TRANSITION_END: 'bsTransitionEnd',
				getUID: function getUID(prefix) {
					do {
						prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
					} while (document.getElementById(prefix));

					return prefix;
				},
				getSelectorFromElement: function getSelectorFromElement(element) {
					var selector = element.getAttribute('data-target');

					if (!selector || selector === '#') {
						var hrefAttr = element.getAttribute('href');
						selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
					}

					try {
						return document.querySelector(selector) ? selector : null;
					} catch (_) {
						return null;
					}
				},
				getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
					if (!element) {
						return 0;
					} // Get transition-duration of the element


					var transitionDuration = $__default['default'](element).css('transition-duration');
					var transitionDelay = $__default['default'](element).css('transition-delay');
					var floatTransitionDuration = parseFloat(transitionDuration);
					var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

					if (!floatTransitionDuration && !floatTransitionDelay) {
						return 0;
					} // If multiple durations are defined, take the first


					transitionDuration = transitionDuration.split(',')[0];
					transitionDelay = transitionDelay.split(',')[0];
					return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
				},
				reflow: function reflow(element) {
					return element.offsetHeight;
				},
				triggerTransitionEnd: function triggerTransitionEnd(element) {
					$__default['default'](element).trigger(TRANSITION_END);
				},
				supportsTransitionEnd: function supportsTransitionEnd() {
					return Boolean(TRANSITION_END);
				},
				isElement: function isElement(obj) {
					return (obj[0] || obj).nodeType;
				},
				typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
					for (var property in configTypes) {
						if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
							var expectedTypes = configTypes[property];
							var value = config[property];
							var valueType = value && Util.isElement(value) ? 'element' : toType(value);

							if (!new RegExp(expectedTypes).test(valueType)) {
								throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
							}
						}
					}
				},
				findShadowRoot: function findShadowRoot(element) {
					if (!document.documentElement.attachShadow) {
						return null;
					} // Can find the shadow root otherwise it'll return the document


					if (typeof element.getRootNode === 'function') {
						var root = element.getRootNode();
						return root instanceof ShadowRoot ? root : null;
					}

					if (element instanceof ShadowRoot) {
						return element;
					} // when we don't find a shadow root


					if (!element.parentNode) {
						return null;
					}

					return Util.findShadowRoot(element.parentNode);
				},
				jQueryDetection: function jQueryDetection() {
					if (typeof $__default['default'] === 'undefined') {
						throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
					}

					var version = $__default['default'].fn.jquery.split(' ')[0].split('.');
					var minMajor = 1;
					var ltMajor = 2;
					var minMinor = 9;
					var minPatch = 1;
					var maxMajor = 4;

					if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
						throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
					}
				}
			};
			Util.jQueryDetection();
			setTransitionEndSupport();
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */

			var NAME = 'alert';
			var VERSION = '4.6.0';
			var DATA_KEY = 'bs.alert';
			var EVENT_KEY = "." + DATA_KEY;
			var DATA_API_KEY = '.data-api';
			var JQUERY_NO_CONFLICT = $__default['default'].fn[NAME];
			var SELECTOR_DISMISS = '[data-dismiss="alert"]';
			var EVENT_CLOSE = "close" + EVENT_KEY;
			var EVENT_CLOSED = "closed" + EVENT_KEY;
			var EVENT_CLICK_DATA_API = "click" + EVENT_KEY + DATA_API_KEY;
			var CLASS_NAME_ALERT = 'alert';
			var CLASS_NAME_FADE = 'fade';
			var CLASS_NAME_SHOW = 'show';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Alert = /*#__PURE__*/function () {
				function Alert(element) {
					this._element = element;
				} // Getters


				var _proto = Alert.prototype; // Public

				_proto.close = function close(element) {
					var rootElement = this._element;

					if (element) {
						rootElement = this._getRootElement(element);
					}

					var customEvent = this._triggerCloseEvent(rootElement);

					if (customEvent.isDefaultPrevented()) {
						return;
					}

					this._removeElement(rootElement);
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY);
					this._element = null;
				} // Private
				;

				_proto._getRootElement = function _getRootElement(element) {
					var selector = Util.getSelectorFromElement(element);
					var parent = false;

					if (selector) {
						parent = document.querySelector(selector);
					}

					if (!parent) {
						parent = $__default['default'](element).closest("." + CLASS_NAME_ALERT)[0];
					}

					return parent;
				};

				_proto._triggerCloseEvent = function _triggerCloseEvent(element) {
					var closeEvent = $__default['default'].Event(EVENT_CLOSE);
					$__default['default'](element).trigger(closeEvent);
					return closeEvent;
				};

				_proto._removeElement = function _removeElement(element) {
					var _this = this;

					$__default['default'](element).removeClass(CLASS_NAME_SHOW);

					if (!$__default['default'](element).hasClass(CLASS_NAME_FADE)) {
						this._destroyElement(element);

						return;
					}

					var transitionDuration = Util.getTransitionDurationFromElement(element);
					$__default['default'](element).one(Util.TRANSITION_END, function (event) {
						return _this._destroyElement(element, event);
					}).emulateTransitionEnd(transitionDuration);
				};

				_proto._destroyElement = function _destroyElement(element) {
					$__default['default'](element).detach().trigger(EVENT_CLOSED).remove();
				} // Static
				;

				Alert._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var $element = $__default['default'](this);
						var data = $element.data(DATA_KEY);

						if (!data) {
							data = new Alert(this);
							$element.data(DATA_KEY, data);
						}

						if (config === 'close') {
							data[config](this);
						}
					});
				};

				Alert._handleDismiss = function _handleDismiss(alertInstance) {
					return function (event) {
						if (event) {
							event.preventDefault();
						}

						alertInstance.close(this);
					};
				};

				_createClass(Alert, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION;
					}
				}]);

				return Alert;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME] = Alert._jQueryInterface;
			$__default['default'].fn[NAME].Constructor = Alert;

			$__default['default'].fn[NAME].noConflict = function () {
				$__default['default'].fn[NAME] = JQUERY_NO_CONFLICT;
				return Alert._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$1 = 'button';
			var VERSION$1 = '4.6.0';
			var DATA_KEY$1 = 'bs.button';
			var EVENT_KEY$1 = "." + DATA_KEY$1;
			var DATA_API_KEY$1 = '.data-api';
			var JQUERY_NO_CONFLICT$1 = $__default['default'].fn[NAME$1];
			var CLASS_NAME_ACTIVE = 'active';
			var CLASS_NAME_BUTTON = 'btn';
			var CLASS_NAME_FOCUS = 'focus';
			var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^="button"]';
			var SELECTOR_DATA_TOGGLES = '[data-toggle="buttons"]';
			var SELECTOR_DATA_TOGGLE = '[data-toggle="button"]';
			var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle="buttons"] .btn';
			var SELECTOR_INPUT = 'input:not([type="hidden"])';
			var SELECTOR_ACTIVE = '.active';
			var SELECTOR_BUTTON = '.btn';
			var EVENT_CLICK_DATA_API$1 = "click" + EVENT_KEY$1 + DATA_API_KEY$1;
			var EVENT_FOCUS_BLUR_DATA_API = "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1);
			var EVENT_LOAD_DATA_API = "load" + EVENT_KEY$1 + DATA_API_KEY$1;
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Button = /*#__PURE__*/function () {
				function Button(element) {
					this._element = element;
					this.shouldAvoidTriggerChange = false;
				} // Getters


				var _proto = Button.prototype; // Public

				_proto.toggle = function toggle() {
					var triggerChangeEvent = true;
					var addAriaPressed = true;
					var rootElement = $__default['default'](this._element).closest(SELECTOR_DATA_TOGGLES)[0];

					if (rootElement) {
						var input = this._element.querySelector(SELECTOR_INPUT);

						if (input) {
							if (input.type === 'radio') {
								if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
									triggerChangeEvent = false;
								} else {
									var activeElement = rootElement.querySelector(SELECTOR_ACTIVE);

									if (activeElement) {
										$__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE);
									}
								}
							}

							if (triggerChangeEvent) {
								// if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input
								if (input.type === 'checkbox' || input.type === 'radio') {
									input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE);
								}

								if (!this.shouldAvoidTriggerChange) {
									$__default['default'](input).trigger('change');
								}
							}

							input.focus();
							addAriaPressed = false;
						}
					}

					if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {
						if (addAriaPressed) {
							this._element.setAttribute('aria-pressed', !this._element.classList.contains(CLASS_NAME_ACTIVE));
						}

						if (triggerChangeEvent) {
							$__default['default'](this._element).toggleClass(CLASS_NAME_ACTIVE);
						}
					}
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY$1);
					this._element = null;
				} // Static
				;

				Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {
					return this.each(function () {
						var $element = $__default['default'](this);
						var data = $element.data(DATA_KEY$1);

						if (!data) {
							data = new Button(this);
							$element.data(DATA_KEY$1, data);
						}

						data.shouldAvoidTriggerChange = avoidTriggerChange;

						if (config === 'toggle') {
							data[config]();
						}
					});
				};

				_createClass(Button, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$1;
					}
				}]);

				return Button;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE_CARROT, function (event) {
				var button = event.target;
				var initialButton = button;

				if (!$__default['default'](button).hasClass(CLASS_NAME_BUTTON)) {
					button = $__default['default'](button).closest(SELECTOR_BUTTON)[0];
				}

				if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {
					event.preventDefault(); // work around Firefox bug #1540995
				} else {
					var inputBtn = button.querySelector(SELECTOR_INPUT);

					if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {
						event.preventDefault(); // work around Firefox bug #1540995

						return;
					}

					if (initialButton.tagName === 'INPUT' || button.tagName !== 'LABEL') {
						Button._jQueryInterface.call($__default['default'](button), 'toggle', initialButton.tagName === 'INPUT');
					}
				}
			}).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {
				var button = $__default['default'](event.target).closest(SELECTOR_BUTTON)[0];
				$__default['default'](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));
			});
			$__default['default'](window).on(EVENT_LOAD_DATA_API, function () {
				// ensure correct active class is set to match the controls' actual values/states
				// find all checkboxes/readio buttons inside data-toggle groups
				var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));

				for (var i = 0, len = buttons.length; i < len; i++) {
					var button = buttons[i];
					var input = button.querySelector(SELECTOR_INPUT);

					if (input.checked || input.hasAttribute('checked')) {
						button.classList.add(CLASS_NAME_ACTIVE);
					} else {
						button.classList.remove(CLASS_NAME_ACTIVE);
					}
				} // find all button toggles


				buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));

				for (var _i = 0, _len = buttons.length; _i < _len; _i++) {
					var _button = buttons[_i];

					if (_button.getAttribute('aria-pressed') === 'true') {
						_button.classList.add(CLASS_NAME_ACTIVE);
					} else {
						_button.classList.remove(CLASS_NAME_ACTIVE);
					}
				}
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$1] = Button._jQueryInterface;
			$__default['default'].fn[NAME$1].Constructor = Button;

			$__default['default'].fn[NAME$1].noConflict = function () {
				$__default['default'].fn[NAME$1] = JQUERY_NO_CONFLICT$1;
				return Button._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$2 = 'carousel';
			var VERSION$2 = '4.6.0';
			var DATA_KEY$2 = 'bs.carousel';
			var EVENT_KEY$2 = "." + DATA_KEY$2;
			var DATA_API_KEY$2 = '.data-api';
			var JQUERY_NO_CONFLICT$2 = $__default['default'].fn[NAME$2];
			var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

			var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

			var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

			var SWIPE_THRESHOLD = 40;
			var Default = {
				interval: 5000,
				keyboard: true,
				slide: false,
				pause: 'hover',
				wrap: true,
				touch: true
			};
			var DefaultType = {
				interval: '(number|boolean)',
				keyboard: 'boolean',
				slide: '(boolean|string)',
				pause: '(string|boolean)',
				wrap: 'boolean',
				touch: 'boolean'
			};
			var DIRECTION_NEXT = 'next';
			var DIRECTION_PREV = 'prev';
			var DIRECTION_LEFT = 'left';
			var DIRECTION_RIGHT = 'right';
			var EVENT_SLIDE = "slide" + EVENT_KEY$2;
			var EVENT_SLID = "slid" + EVENT_KEY$2;
			var EVENT_KEYDOWN = "keydown" + EVENT_KEY$2;
			var EVENT_MOUSEENTER = "mouseenter" + EVENT_KEY$2;
			var EVENT_MOUSELEAVE = "mouseleave" + EVENT_KEY$2;
			var EVENT_TOUCHSTART = "touchstart" + EVENT_KEY$2;
			var EVENT_TOUCHMOVE = "touchmove" + EVENT_KEY$2;
			var EVENT_TOUCHEND = "touchend" + EVENT_KEY$2;
			var EVENT_POINTERDOWN = "pointerdown" + EVENT_KEY$2;
			var EVENT_POINTERUP = "pointerup" + EVENT_KEY$2;
			var EVENT_DRAG_START = "dragstart" + EVENT_KEY$2;
			var EVENT_LOAD_DATA_API$1 = "load" + EVENT_KEY$2 + DATA_API_KEY$2;
			var EVENT_CLICK_DATA_API$2 = "click" + EVENT_KEY$2 + DATA_API_KEY$2;
			var CLASS_NAME_CAROUSEL = 'carousel';
			var CLASS_NAME_ACTIVE$1 = 'active';
			var CLASS_NAME_SLIDE = 'slide';
			var CLASS_NAME_RIGHT = 'carousel-item-right';
			var CLASS_NAME_LEFT = 'carousel-item-left';
			var CLASS_NAME_NEXT = 'carousel-item-next';
			var CLASS_NAME_PREV = 'carousel-item-prev';
			var CLASS_NAME_POINTER_EVENT = 'pointer-event';
			var SELECTOR_ACTIVE$1 = '.active';
			var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
			var SELECTOR_ITEM = '.carousel-item';
			var SELECTOR_ITEM_IMG = '.carousel-item img';
			var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
			var SELECTOR_INDICATORS = '.carousel-indicators';
			var SELECTOR_DATA_SLIDE = '[data-slide], [data-slide-to]';
			var SELECTOR_DATA_RIDE = '[data-ride="carousel"]';
			var PointerType = {
				TOUCH: 'touch',
				PEN: 'pen'
			};
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Carousel = /*#__PURE__*/function () {
				function Carousel(element, config) {
					this._items = null;
					this._interval = null;
					this._activeElement = null;
					this._isPaused = false;
					this._isSliding = false;
					this.touchTimeout = null;
					this.touchStartX = 0;
					this.touchDeltaX = 0;
					this._config = this._getConfig(config);
					this._element = element;
					this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);
					this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
					this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

					this._addEventListeners();
				} // Getters


				var _proto = Carousel.prototype; // Public

				_proto.next = function next() {
					if (!this._isSliding) {
						this._slide(DIRECTION_NEXT);
					}
				};

				_proto.nextWhenVisible = function nextWhenVisible() {
					var $element = $__default['default'](this._element); // Don't call next when the page isn't visible
					// or the carousel or its parent isn't visible

					if (!document.hidden && $element.is(':visible') && $element.css('visibility') !== 'hidden') {
						this.next();
					}
				};

				_proto.prev = function prev() {
					if (!this._isSliding) {
						this._slide(DIRECTION_PREV);
					}
				};

				_proto.pause = function pause(event) {
					if (!event) {
						this._isPaused = true;
					}

					if (this._element.querySelector(SELECTOR_NEXT_PREV)) {
						Util.triggerTransitionEnd(this._element);
						this.cycle(true);
					}

					clearInterval(this._interval);
					this._interval = null;
				};

				_proto.cycle = function cycle(event) {
					if (!event) {
						this._isPaused = false;
					}

					if (this._interval) {
						clearInterval(this._interval);
						this._interval = null;
					}

					if (this._config.interval && !this._isPaused) {
						this._updateInterval();

						this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
					}
				};

				_proto.to = function to(index) {
					var _this = this;

					this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);

					var activeIndex = this._getItemIndex(this._activeElement);

					if (index > this._items.length - 1 || index < 0) {
						return;
					}

					if (this._isSliding) {
						$__default['default'](this._element).one(EVENT_SLID, function () {
							return _this.to(index);
						});
						return;
					}

					if (activeIndex === index) {
						this.pause();
						this.cycle();
						return;
					}

					var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;

					this._slide(direction, this._items[index]);
				};

				_proto.dispose = function dispose() {
					$__default['default'](this._element).off(EVENT_KEY$2);
					$__default['default'].removeData(this._element, DATA_KEY$2);
					this._items = null;
					this._config = null;
					this._element = null;
					this._interval = null;
					this._isPaused = null;
					this._isSliding = null;
					this._activeElement = null;
					this._indicatorsElement = null;
				} // Private
				;

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, Default, config);
					Util.typeCheckConfig(NAME$2, config, DefaultType);
					return config;
				};

				_proto._handleSwipe = function _handleSwipe() {
					var absDeltax = Math.abs(this.touchDeltaX);

					if (absDeltax <= SWIPE_THRESHOLD) {
						return;
					}

					var direction = absDeltax / this.touchDeltaX;
					this.touchDeltaX = 0; // swipe left

					if (direction > 0) {
						this.prev();
					} // swipe right


					if (direction < 0) {
						this.next();
					}
				};

				_proto._addEventListeners = function _addEventListeners() {
					var _this2 = this;

					if (this._config.keyboard) {
						$__default['default'](this._element).on(EVENT_KEYDOWN, function (event) {
							return _this2._keydown(event);
						});
					}

					if (this._config.pause === 'hover') {
						$__default['default'](this._element).on(EVENT_MOUSEENTER, function (event) {
							return _this2.pause(event);
						}).on(EVENT_MOUSELEAVE, function (event) {
							return _this2.cycle(event);
						});
					}

					if (this._config.touch) {
						this._addTouchEventListeners();
					}
				};

				_proto._addTouchEventListeners = function _addTouchEventListeners() {
					var _this3 = this;

					if (!this._touchSupported) {
						return;
					}

					var start = function start(event) {
						if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
							_this3.touchStartX = event.originalEvent.clientX;
						} else if (!_this3._pointerEvent) {
							_this3.touchStartX = event.originalEvent.touches[0].clientX;
						}
					};

					var move = function move(event) {
						// ensure swiping with one touch and not pinching
						if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
							_this3.touchDeltaX = 0;
						} else {
							_this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
						}
					};

					var end = function end(event) {
						if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
							_this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
						}

						_this3._handleSwipe();

						if (_this3._config.pause === 'hover') {
							// If it's a touch-enabled device, mouseenter/leave are fired as
							// part of the mouse compatibility events on first tap - the carousel
							// would stop cycling until user tapped out of it;
							// here, we listen for touchend, explicitly pause the carousel
							// (as if it's the second time we tap on it, mouseenter compat event
							// is NOT fired) and after a timeout (to allow for mouse compatibility
							// events to fire) we explicitly restart cycling
							_this3.pause();

							if (_this3.touchTimeout) {
								clearTimeout(_this3.touchTimeout);
							}

							_this3.touchTimeout = setTimeout(function (event) {
								return _this3.cycle(event);
							}, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
						}
					};

					$__default['default'](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {
						return e.preventDefault();
					});

					if (this._pointerEvent) {
						$__default['default'](this._element).on(EVENT_POINTERDOWN, function (event) {
							return start(event);
						});
						$__default['default'](this._element).on(EVENT_POINTERUP, function (event) {
							return end(event);
						});

						this._element.classList.add(CLASS_NAME_POINTER_EVENT);
					} else {
						$__default['default'](this._element).on(EVENT_TOUCHSTART, function (event) {
							return start(event);
						});
						$__default['default'](this._element).on(EVENT_TOUCHMOVE, function (event) {
							return move(event);
						});
						$__default['default'](this._element).on(EVENT_TOUCHEND, function (event) {
							return end(event);
						});
					}
				};

				_proto._keydown = function _keydown(event) {
					if (/input|textarea/i.test(event.target.tagName)) {
						return;
					}

					switch (event.which) {
						case ARROW_LEFT_KEYCODE:
							event.preventDefault();
							this.prev();
							break;

						case ARROW_RIGHT_KEYCODE:
							event.preventDefault();
							this.next();
							break;
					}
				};

				_proto._getItemIndex = function _getItemIndex(element) {
					this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];
					return this._items.indexOf(element);
				};

				_proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
					var isNextDirection = direction === DIRECTION_NEXT;
					var isPrevDirection = direction === DIRECTION_PREV;

					var activeIndex = this._getItemIndex(activeElement);

					var lastItemIndex = this._items.length - 1;
					var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

					if (isGoingToWrap && !this._config.wrap) {
						return activeElement;
					}

					var delta = direction === DIRECTION_PREV ? -1 : 1;
					var itemIndex = (activeIndex + delta) % this._items.length;
					return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
				};

				_proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
					var targetIndex = this._getItemIndex(relatedTarget);

					var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));

					var slideEvent = $__default['default'].Event(EVENT_SLIDE, {
						relatedTarget: relatedTarget,
						direction: eventDirectionName,
						from: fromIndex,
						to: targetIndex
					});
					$__default['default'](this._element).trigger(slideEvent);
					return slideEvent;
				};

				_proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
					if (this._indicatorsElement) {
						var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));
						$__default['default'](indicators).removeClass(CLASS_NAME_ACTIVE$1);

						var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

						if (nextIndicator) {
							$__default['default'](nextIndicator).addClass(CLASS_NAME_ACTIVE$1);
						}
					}
				};

				_proto._updateInterval = function _updateInterval() {
					var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);

					if (!element) {
						return;
					}

					var elementInterval = parseInt(element.getAttribute('data-interval'), 10);

					if (elementInterval) {
						this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
						this._config.interval = elementInterval;
					} else {
						this._config.interval = this._config.defaultInterval || this._config.interval;
					}
				};

				_proto._slide = function _slide(direction, element) {
					var _this4 = this;

					var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);

					var activeElementIndex = this._getItemIndex(activeElement);

					var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

					var nextElementIndex = this._getItemIndex(nextElement);

					var isCycling = Boolean(this._interval);
					var directionalClassName;
					var orderClassName;
					var eventDirectionName;

					if (direction === DIRECTION_NEXT) {
						directionalClassName = CLASS_NAME_LEFT;
						orderClassName = CLASS_NAME_NEXT;
						eventDirectionName = DIRECTION_LEFT;
					} else {
						directionalClassName = CLASS_NAME_RIGHT;
						orderClassName = CLASS_NAME_PREV;
						eventDirectionName = DIRECTION_RIGHT;
					}

					if (nextElement && $__default['default'](nextElement).hasClass(CLASS_NAME_ACTIVE$1)) {
						this._isSliding = false;
						return;
					}

					var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

					if (slideEvent.isDefaultPrevented()) {
						return;
					}

					if (!activeElement || !nextElement) {
						// Some weirdness is happening, so we bail
						return;
					}

					this._isSliding = true;

					if (isCycling) {
						this.pause();
					}

					this._setActiveIndicatorElement(nextElement);

					this._activeElement = nextElement;
					var slidEvent = $__default['default'].Event(EVENT_SLID, {
						relatedTarget: nextElement,
						direction: eventDirectionName,
						from: activeElementIndex,
						to: nextElementIndex
					});

					if ($__default['default'](this._element).hasClass(CLASS_NAME_SLIDE)) {
						$__default['default'](nextElement).addClass(orderClassName);
						Util.reflow(nextElement);
						$__default['default'](activeElement).addClass(directionalClassName);
						$__default['default'](nextElement).addClass(directionalClassName);
						var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
						$__default['default'](activeElement).one(Util.TRANSITION_END, function () {
							$__default['default'](nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(CLASS_NAME_ACTIVE$1);
							$__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1 + " " + orderClassName + " " + directionalClassName);
							_this4._isSliding = false;
							setTimeout(function () {
								return $__default['default'](_this4._element).trigger(slidEvent);
							}, 0);
						}).emulateTransitionEnd(transitionDuration);
					} else {
						$__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1);
						$__default['default'](nextElement).addClass(CLASS_NAME_ACTIVE$1);
						this._isSliding = false;
						$__default['default'](this._element).trigger(slidEvent);
					}

					if (isCycling) {
						this.cycle();
					}
				} // Static
				;

				Carousel._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var data = $__default['default'](this).data(DATA_KEY$2);

						var _config = _extends({}, Default, $__default['default'](this).data());

						if (_typeof(config) === 'object') {
							_config = _extends({}, _config, config);
						}

						var action = typeof config === 'string' ? config : _config.slide;

						if (!data) {
							data = new Carousel(this, _config);
							$__default['default'](this).data(DATA_KEY$2, data);
						}

						if (typeof config === 'number') {
							data.to(config);
						} else if (typeof action === 'string') {
							if (typeof data[action] === 'undefined') {
								throw new TypeError("No method named \"" + action + "\"");
							}

							data[action]();
						} else if (_config.interval && _config.ride) {
							data.pause();
							data.cycle();
						}
					});
				};

				Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
					var selector = Util.getSelectorFromElement(this);

					if (!selector) {
						return;
					}

					var target = $__default['default'](selector)[0];

					if (!target || !$__default['default'](target).hasClass(CLASS_NAME_CAROUSEL)) {
						return;
					}

					var config = _extends({}, $__default['default'](target).data(), $__default['default'](this).data());

					var slideIndex = this.getAttribute('data-slide-to');

					if (slideIndex) {
						config.interval = false;
					}

					Carousel._jQueryInterface.call($__default['default'](target), config);

					if (slideIndex) {
						$__default['default'](target).data(DATA_KEY$2).to(slideIndex);
					}

					event.preventDefault();
				};

				_createClass(Carousel, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$2;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default;
					}
				}]);

				return Carousel;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);
			$__default['default'](window).on(EVENT_LOAD_DATA_API$1, function () {
				var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));

				for (var i = 0, len = carousels.length; i < len; i++) {
					var $carousel = $__default['default'](carousels[i]);

					Carousel._jQueryInterface.call($carousel, $carousel.data());
				}
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$2] = Carousel._jQueryInterface;
			$__default['default'].fn[NAME$2].Constructor = Carousel;

			$__default['default'].fn[NAME$2].noConflict = function () {
				$__default['default'].fn[NAME$2] = JQUERY_NO_CONFLICT$2;
				return Carousel._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$3 = 'collapse';
			var VERSION$3 = '4.6.0';
			var DATA_KEY$3 = 'bs.collapse';
			var EVENT_KEY$3 = "." + DATA_KEY$3;
			var DATA_API_KEY$3 = '.data-api';
			var JQUERY_NO_CONFLICT$3 = $__default['default'].fn[NAME$3];
			var Default$1 = {
				toggle: true,
				parent: ''
			};
			var DefaultType$1 = {
				toggle: 'boolean',
				parent: '(string|element)'
			};
			var EVENT_SHOW = "show" + EVENT_KEY$3;
			var EVENT_SHOWN = "shown" + EVENT_KEY$3;
			var EVENT_HIDE = "hide" + EVENT_KEY$3;
			var EVENT_HIDDEN = "hidden" + EVENT_KEY$3;
			var EVENT_CLICK_DATA_API$3 = "click" + EVENT_KEY$3 + DATA_API_KEY$3;
			var CLASS_NAME_SHOW$1 = 'show';
			var CLASS_NAME_COLLAPSE = 'collapse';
			var CLASS_NAME_COLLAPSING = 'collapsing';
			var CLASS_NAME_COLLAPSED = 'collapsed';
			var DIMENSION_WIDTH = 'width';
			var DIMENSION_HEIGHT = 'height';
			var SELECTOR_ACTIVES = '.show, .collapsing';
			var SELECTOR_DATA_TOGGLE$1 = '[data-toggle="collapse"]';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Collapse = /*#__PURE__*/function () {
				function Collapse(element, config) {
					this._isTransitioning = false;
					this._element = element;
					this._config = this._getConfig(config);
					this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
					var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$1));

					for (var i = 0, len = toggleList.length; i < len; i++) {
						var elem = toggleList[i];
						var selector = Util.getSelectorFromElement(elem);
						var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
							return foundElem === element;
						});

						if (selector !== null && filterElement.length > 0) {
							this._selector = selector;

							this._triggerArray.push(elem);
						}
					}

					this._parent = this._config.parent ? this._getParent() : null;

					if (!this._config.parent) {
						this._addAriaAndCollapsedClass(this._element, this._triggerArray);
					}

					if (this._config.toggle) {
						this.toggle();
					}
				} // Getters


				var _proto = Collapse.prototype; // Public

				_proto.toggle = function toggle() {
					if ($__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {
						this.hide();
					} else {
						this.show();
					}
				};

				_proto.show = function show() {
					var _this = this;

					if (this._isTransitioning || $__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {
						return;
					}

					var actives;
					var activesData;

					if (this._parent) {
						actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {
							if (typeof _this._config.parent === 'string') {
								return elem.getAttribute('data-parent') === _this._config.parent;
							}

							return elem.classList.contains(CLASS_NAME_COLLAPSE);
						});

						if (actives.length === 0) {
							actives = null;
						}
					}

					if (actives) {
						activesData = $__default['default'](actives).not(this._selector).data(DATA_KEY$3);

						if (activesData && activesData._isTransitioning) {
							return;
						}
					}

					var startEvent = $__default['default'].Event(EVENT_SHOW);
					$__default['default'](this._element).trigger(startEvent);

					if (startEvent.isDefaultPrevented()) {
						return;
					}

					if (actives) {
						Collapse._jQueryInterface.call($__default['default'](actives).not(this._selector), 'hide');

						if (!activesData) {
							$__default['default'](actives).data(DATA_KEY$3, null);
						}
					}

					var dimension = this._getDimension();

					$__default['default'](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
					this._element.style[dimension] = 0;

					if (this._triggerArray.length) {
						$__default['default'](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);
					}

					this.setTransitioning(true);

					var complete = function complete() {
						$__default['default'](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$1);
						_this._element.style[dimension] = '';

						_this.setTransitioning(false);

						$__default['default'](_this._element).trigger(EVENT_SHOWN);
					};

					var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
					var scrollSize = "scroll" + capitalizedDimension;
					var transitionDuration = Util.getTransitionDurationFromElement(this._element);
					$__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
					this._element.style[dimension] = this._element[scrollSize] + "px";
				};

				_proto.hide = function hide() {
					var _this2 = this;

					if (this._isTransitioning || !$__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {
						return;
					}

					var startEvent = $__default['default'].Event(EVENT_HIDE);
					$__default['default'](this._element).trigger(startEvent);

					if (startEvent.isDefaultPrevented()) {
						return;
					}

					var dimension = this._getDimension();

					this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
					Util.reflow(this._element);
					$__default['default'](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$1);
					var triggerArrayLength = this._triggerArray.length;

					if (triggerArrayLength > 0) {
						for (var i = 0; i < triggerArrayLength; i++) {
							var trigger = this._triggerArray[i];
							var selector = Util.getSelectorFromElement(trigger);

							if (selector !== null) {
								var $elem = $__default['default']([].slice.call(document.querySelectorAll(selector)));

								if (!$elem.hasClass(CLASS_NAME_SHOW$1)) {
									$__default['default'](trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);
								}
							}
						}
					}

					this.setTransitioning(true);

					var complete = function complete() {
						_this2.setTransitioning(false);

						$__default['default'](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);
					};

					this._element.style[dimension] = '';
					var transitionDuration = Util.getTransitionDurationFromElement(this._element);
					$__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
				};

				_proto.setTransitioning = function setTransitioning(isTransitioning) {
					this._isTransitioning = isTransitioning;
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY$3);
					this._config = null;
					this._parent = null;
					this._element = null;
					this._triggerArray = null;
					this._isTransitioning = null;
				} // Private
				;

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, Default$1, config);
					config.toggle = Boolean(config.toggle); // Coerce string values

					Util.typeCheckConfig(NAME$3, config, DefaultType$1);
					return config;
				};

				_proto._getDimension = function _getDimension() {
					var hasWidth = $__default['default'](this._element).hasClass(DIMENSION_WIDTH);
					return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
				};

				_proto._getParent = function _getParent() {
					var _this3 = this;

					var parent;

					if (Util.isElement(this._config.parent)) {
						parent = this._config.parent; // It's a jQuery object

						if (typeof this._config.parent.jquery !== 'undefined') {
							parent = this._config.parent[0];
						}
					} else {
						parent = document.querySelector(this._config.parent);
					}

					var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
					var children = [].slice.call(parent.querySelectorAll(selector));
					$__default['default'](children).each(function (i, element) {
						_this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
					});
					return parent;
				};

				_proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
					var isOpen = $__default['default'](element).hasClass(CLASS_NAME_SHOW$1);

					if (triggerArray.length) {
						$__default['default'](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
					}
				} // Static
				;

				Collapse._getTargetFromElement = function _getTargetFromElement(element) {
					var selector = Util.getSelectorFromElement(element);
					return selector ? document.querySelector(selector) : null;
				};

				Collapse._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var $element = $__default['default'](this);
						var data = $element.data(DATA_KEY$3);

						var _config = _extends({}, Default$1, $element.data(), _typeof(config) === 'object' && config ? config : {});

						if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {
							_config.toggle = false;
						}

						if (!data) {
							data = new Collapse(this, _config);
							$element.data(DATA_KEY$3, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				_createClass(Collapse, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$3;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$1;
					}
				}]);

				return Collapse;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$1, function (event) {
				// preventDefault only for <a> elements (which change the URL) not inside the collapsible element
				if (event.currentTarget.tagName === 'A') {
					event.preventDefault();
				}

				var $trigger = $__default['default'](this);
				var selector = Util.getSelectorFromElement(this);
				var selectors = [].slice.call(document.querySelectorAll(selector));
				$__default['default'](selectors).each(function () {
					var $target = $__default['default'](this);
					var data = $target.data(DATA_KEY$3);
					var config = data ? 'toggle' : $trigger.data();

					Collapse._jQueryInterface.call($target, config);
				});
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$3] = Collapse._jQueryInterface;
			$__default['default'].fn[NAME$3].Constructor = Collapse;

			$__default['default'].fn[NAME$3].noConflict = function () {
				$__default['default'].fn[NAME$3] = JQUERY_NO_CONFLICT$3;
				return Collapse._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$4 = 'dropdown';
			var VERSION$4 = '4.6.0';
			var DATA_KEY$4 = 'bs.dropdown';
			var EVENT_KEY$4 = "." + DATA_KEY$4;
			var DATA_API_KEY$4 = '.data-api';
			var JQUERY_NO_CONFLICT$4 = $__default['default'].fn[NAME$4];
			var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

			var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

			var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

			var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

			var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

			var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

			var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
			var EVENT_HIDE$1 = "hide" + EVENT_KEY$4;
			var EVENT_HIDDEN$1 = "hidden" + EVENT_KEY$4;
			var EVENT_SHOW$1 = "show" + EVENT_KEY$4;
			var EVENT_SHOWN$1 = "shown" + EVENT_KEY$4;
			var EVENT_CLICK = "click" + EVENT_KEY$4;
			var EVENT_CLICK_DATA_API$4 = "click" + EVENT_KEY$4 + DATA_API_KEY$4;
			var EVENT_KEYDOWN_DATA_API = "keydown" + EVENT_KEY$4 + DATA_API_KEY$4;
			var EVENT_KEYUP_DATA_API = "keyup" + EVENT_KEY$4 + DATA_API_KEY$4;
			var CLASS_NAME_DISABLED = 'disabled';
			var CLASS_NAME_SHOW$2 = 'show';
			var CLASS_NAME_DROPUP = 'dropup';
			var CLASS_NAME_DROPRIGHT = 'dropright';
			var CLASS_NAME_DROPLEFT = 'dropleft';
			var CLASS_NAME_MENURIGHT = 'dropdown-menu-right';
			var CLASS_NAME_POSITION_STATIC = 'position-static';
			var SELECTOR_DATA_TOGGLE$2 = '[data-toggle="dropdown"]';
			var SELECTOR_FORM_CHILD = '.dropdown form';
			var SELECTOR_MENU = '.dropdown-menu';
			var SELECTOR_NAVBAR_NAV = '.navbar-nav';
			var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
			var PLACEMENT_TOP = 'top-start';
			var PLACEMENT_TOPEND = 'top-end';
			var PLACEMENT_BOTTOM = 'bottom-start';
			var PLACEMENT_BOTTOMEND = 'bottom-end';
			var PLACEMENT_RIGHT = 'right-start';
			var PLACEMENT_LEFT = 'left-start';
			var Default$2 = {
				offset: 0,
				flip: true,
				boundary: 'scrollParent',
				reference: 'toggle',
				display: 'dynamic',
				popperConfig: null
			};
			var DefaultType$2 = {
				offset: '(number|string|function)',
				flip: 'boolean',
				boundary: '(string|element)',
				reference: '(string|element)',
				display: 'string',
				popperConfig: '(null|object)'
			};
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Dropdown = /*#__PURE__*/function () {
				function Dropdown(element, config) {
					this._element = element;
					this._popper = null;
					this._config = this._getConfig(config);
					this._menu = this._getMenuElement();
					this._inNavbar = this._detectNavbar();

					this._addEventListeners();
				} // Getters


				var _proto = Dropdown.prototype; // Public

				_proto.toggle = function toggle() {
					if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED)) {
						return;
					}

					var isActive = $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2);

					Dropdown._clearMenus();

					if (isActive) {
						return;
					}

					this.show(true);
				};

				_proto.show = function show(usePopper) {
					if (usePopper === void 0) {
						usePopper = false;
					}

					if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {
						return;
					}

					var relatedTarget = {
						relatedTarget: this._element
					};
					var showEvent = $__default['default'].Event(EVENT_SHOW$1, relatedTarget);

					var parent = Dropdown._getParentFromElement(this._element);

					$__default['default'](parent).trigger(showEvent);

					if (showEvent.isDefaultPrevented()) {
						return;
					} // Totally disable Popper for Dropdowns in Navbar


					if (!this._inNavbar && usePopper) {
						/**
						 * Check for Popper dependency
						 * Popper - https://popper.js.org
						 */
						if (typeof Popper__default['default'] === 'undefined') {
							throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
						}

						var referenceElement = this._element;

						if (this._config.reference === 'parent') {
							referenceElement = parent;
						} else if (Util.isElement(this._config.reference)) {
							referenceElement = this._config.reference; // Check if it's jQuery element

							if (typeof this._config.reference.jquery !== 'undefined') {
								referenceElement = this._config.reference[0];
							}
						} // If boundary is not `scrollParent`, then set position to `static`
						// to allow the menu to "escape" the scroll parent's boundaries
						// https://github.com/twbs/bootstrap/issues/24251


						if (this._config.boundary !== 'scrollParent') {
							$__default['default'](parent).addClass(CLASS_NAME_POSITION_STATIC);
						}

						this._popper = new Popper__default['default'](referenceElement, this._menu, this._getPopperConfig());
					} // If this is a touch-enabled device we add extra
					// empty mouseover listeners to the body's immediate children;
					// only needed because of broken event delegation on iOS
					// https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


					if ('ontouchstart' in document.documentElement && $__default['default'](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {
						$__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);
					}

					this._element.focus();

					this._element.setAttribute('aria-expanded', true);

					$__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);
					$__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_SHOWN$1, relatedTarget));
				};

				_proto.hide = function hide() {
					if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || !$__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {
						return;
					}

					var relatedTarget = {
						relatedTarget: this._element
					};
					var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);

					var parent = Dropdown._getParentFromElement(this._element);

					$__default['default'](parent).trigger(hideEvent);

					if (hideEvent.isDefaultPrevented()) {
						return;
					}

					if (this._popper) {
						this._popper.destroy();
					}

					$__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);
					$__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY$4);
					$__default['default'](this._element).off(EVENT_KEY$4);
					this._element = null;
					this._menu = null;

					if (this._popper !== null) {
						this._popper.destroy();

						this._popper = null;
					}
				};

				_proto.update = function update() {
					this._inNavbar = this._detectNavbar();

					if (this._popper !== null) {
						this._popper.scheduleUpdate();
					}
				} // Private
				;

				_proto._addEventListeners = function _addEventListeners() {
					var _this = this;

					$__default['default'](this._element).on(EVENT_CLICK, function (event) {
						event.preventDefault();
						event.stopPropagation();

						_this.toggle();
					});
				};

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, this.constructor.Default, $__default['default'](this._element).data(), config);
					Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
					return config;
				};

				_proto._getMenuElement = function _getMenuElement() {
					if (!this._menu) {
						var parent = Dropdown._getParentFromElement(this._element);

						if (parent) {
							this._menu = parent.querySelector(SELECTOR_MENU);
						}
					}

					return this._menu;
				};

				_proto._getPlacement = function _getPlacement() {
					var $parentDropdown = $__default['default'](this._element.parentNode);
					var placement = PLACEMENT_BOTTOM; // Handle dropup

					if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {
						placement = $__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;
					} else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {
						placement = PLACEMENT_RIGHT;
					} else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {
						placement = PLACEMENT_LEFT;
					} else if ($__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {
						placement = PLACEMENT_BOTTOMEND;
					}

					return placement;
				};

				_proto._detectNavbar = function _detectNavbar() {
					return $__default['default'](this._element).closest('.navbar').length > 0;
				};

				_proto._getOffset = function _getOffset() {
					var _this2 = this;

					var offset = {};

					if (typeof this._config.offset === 'function') {
						offset.fn = function (data) {
							data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});
							return data;
						};
					} else {
						offset.offset = this._config.offset;
					}

					return offset;
				};

				_proto._getPopperConfig = function _getPopperConfig() {
					var popperConfig = {
						placement: this._getPlacement(),
						modifiers: {
							offset: this._getOffset(),
							flip: {
								enabled: this._config.flip
							},
							preventOverflow: {
								boundariesElement: this._config.boundary
							}
						}
					}; // Disable Popper if we have a static display

					if (this._config.display === 'static') {
						popperConfig.modifiers.applyStyle = {
							enabled: false
						};
					}

					return _extends({}, popperConfig, this._config.popperConfig);
				} // Static
				;

				Dropdown._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var data = $__default['default'](this).data(DATA_KEY$4);

						var _config = _typeof(config) === 'object' ? config : null;

						if (!data) {
							data = new Dropdown(this, _config);
							$__default['default'](this).data(DATA_KEY$4, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				Dropdown._clearMenus = function _clearMenus(event) {
					if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
						return;
					}

					var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));

					for (var i = 0, len = toggles.length; i < len; i++) {
						var parent = Dropdown._getParentFromElement(toggles[i]);

						var context = $__default['default'](toggles[i]).data(DATA_KEY$4);
						var relatedTarget = {
							relatedTarget: toggles[i]
						};

						if (event && event.type === 'click') {
							relatedTarget.clickEvent = event;
						}

						if (!context) {
							continue;
						}

						var dropdownMenu = context._menu;

						if (!$__default['default'](parent).hasClass(CLASS_NAME_SHOW$2)) {
							continue;
						}

						if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $__default['default'].contains(parent, event.target)) {
							continue;
						}

						var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);
						$__default['default'](parent).trigger(hideEvent);

						if (hideEvent.isDefaultPrevented()) {
							continue;
						} // If this is a touch-enabled device we remove the extra
						// empty mouseover listeners we added for iOS support


						if ('ontouchstart' in document.documentElement) {
							$__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);
						}

						toggles[i].setAttribute('aria-expanded', 'false');

						if (context._popper) {
							context._popper.destroy();
						}

						$__default['default'](dropdownMenu).removeClass(CLASS_NAME_SHOW$2);
						$__default['default'](parent).removeClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));
					}
				};

				Dropdown._getParentFromElement = function _getParentFromElement(element) {
					var parent;
					var selector = Util.getSelectorFromElement(element);

					if (selector) {
						parent = document.querySelector(selector);
					}

					return parent || element.parentNode;
				} // eslint-disable-next-line complexity
				;

				Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
					// If not input/textarea:
					//  - And not a key in REGEXP_KEYDOWN => not a dropdown command
					// If input/textarea:
					//  - If space key => not a dropdown command
					//  - If key is other than escape
					//    - If key is not up or down => not a dropdown command
					//    - If trigger inside the menu => not a dropdown command
					if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default['default'](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
						return;
					}

					if (this.disabled || $__default['default'](this).hasClass(CLASS_NAME_DISABLED)) {
						return;
					}

					var parent = Dropdown._getParentFromElement(this);

					var isActive = $__default['default'](parent).hasClass(CLASS_NAME_SHOW$2);

					if (!isActive && event.which === ESCAPE_KEYCODE) {
						return;
					}

					event.preventDefault();
					event.stopPropagation();

					if (!isActive || event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE) {
						if (event.which === ESCAPE_KEYCODE) {
							$__default['default'](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger('focus');
						}

						$__default['default'](this).trigger('click');
						return;
					}

					var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {
						return $__default['default'](item).is(':visible');
					});

					if (items.length === 0) {
						return;
					}

					var index = items.indexOf(event.target);

					if (event.which === ARROW_UP_KEYCODE && index > 0) {
						// Up
						index--;
					}

					if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
						// Down
						index++;
					}

					if (index < 0) {
						index = 0;
					}

					items[index].focus();
				};

				_createClass(Dropdown, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$4;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$2;
					}
				}, {
					key: "DefaultType",
					get: function get() {
						return DefaultType$2;
					}
				}]);

				return Dropdown;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$4 + " " + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$2, function (event) {
				event.preventDefault();
				event.stopPropagation();

				Dropdown._jQueryInterface.call($__default['default'](this), 'toggle');
			}).on(EVENT_CLICK_DATA_API$4, SELECTOR_FORM_CHILD, function (e) {
				e.stopPropagation();
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$4] = Dropdown._jQueryInterface;
			$__default['default'].fn[NAME$4].Constructor = Dropdown;

			$__default['default'].fn[NAME$4].noConflict = function () {
				$__default['default'].fn[NAME$4] = JQUERY_NO_CONFLICT$4;
				return Dropdown._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$5 = 'modal';
			var VERSION$5 = '4.6.0';
			var DATA_KEY$5 = 'bs.modal';
			var EVENT_KEY$5 = "." + DATA_KEY$5;
			var DATA_API_KEY$5 = '.data-api';
			var JQUERY_NO_CONFLICT$5 = $__default['default'].fn[NAME$5];
			var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

			var Default$3 = {
				backdrop: true,
				keyboard: true,
				focus: true,
				show: true
			};
			var DefaultType$3 = {
				backdrop: '(boolean|string)',
				keyboard: 'boolean',
				focus: 'boolean',
				show: 'boolean'
			};
			var EVENT_HIDE$2 = "hide" + EVENT_KEY$5;
			var EVENT_HIDE_PREVENTED = "hidePrevented" + EVENT_KEY$5;
			var EVENT_HIDDEN$2 = "hidden" + EVENT_KEY$5;
			var EVENT_SHOW$2 = "show" + EVENT_KEY$5;
			var EVENT_SHOWN$2 = "shown" + EVENT_KEY$5;
			var EVENT_FOCUSIN = "focusin" + EVENT_KEY$5;
			var EVENT_RESIZE = "resize" + EVENT_KEY$5;
			var EVENT_CLICK_DISMISS = "click.dismiss" + EVENT_KEY$5;
			var EVENT_KEYDOWN_DISMISS = "keydown.dismiss" + EVENT_KEY$5;
			var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss" + EVENT_KEY$5;
			var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss" + EVENT_KEY$5;
			var EVENT_CLICK_DATA_API$5 = "click" + EVENT_KEY$5 + DATA_API_KEY$5;
			var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';
			var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';
			var CLASS_NAME_BACKDROP = 'modal-backdrop';
			var CLASS_NAME_OPEN = 'modal-open';
			var CLASS_NAME_FADE$1 = 'fade';
			var CLASS_NAME_SHOW$3 = 'show';
			var CLASS_NAME_STATIC = 'modal-static';
			var SELECTOR_DIALOG = '.modal-dialog';
			var SELECTOR_MODAL_BODY = '.modal-body';
			var SELECTOR_DATA_TOGGLE$3 = '[data-toggle="modal"]';
			var SELECTOR_DATA_DISMISS = '[data-dismiss="modal"]';
			var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
			var SELECTOR_STICKY_CONTENT = '.sticky-top';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Modal = /*#__PURE__*/function () {
				function Modal(element, config) {
					this._config = this._getConfig(config);
					this._element = element;
					this._dialog = element.querySelector(SELECTOR_DIALOG);
					this._backdrop = null;
					this._isShown = false;
					this._isBodyOverflowing = false;
					this._ignoreBackdropClick = false;
					this._isTransitioning = false;
					this._scrollbarWidth = 0;
				} // Getters


				var _proto = Modal.prototype; // Public

				_proto.toggle = function toggle(relatedTarget) {
					return this._isShown ? this.hide() : this.show(relatedTarget);
				};

				_proto.show = function show(relatedTarget) {
					var _this = this;

					if (this._isShown || this._isTransitioning) {
						return;
					}

					if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {
						this._isTransitioning = true;
					}

					var showEvent = $__default['default'].Event(EVENT_SHOW$2, {
						relatedTarget: relatedTarget
					});
					$__default['default'](this._element).trigger(showEvent);

					if (this._isShown || showEvent.isDefaultPrevented()) {
						return;
					}

					this._isShown = true;

					this._checkScrollbar();

					this._setScrollbar();

					this._adjustDialog();

					this._setEscapeEvent();

					this._setResizeEvent();

					$__default['default'](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {
						return _this.hide(event);
					});
					$__default['default'](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {
						$__default['default'](_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {
							if ($__default['default'](event.target).is(_this._element)) {
								_this._ignoreBackdropClick = true;
							}
						});
					});

					this._showBackdrop(function () {
						return _this._showElement(relatedTarget);
					});
				};

				_proto.hide = function hide(event) {
					var _this2 = this;

					if (event) {
						event.preventDefault();
					}

					if (!this._isShown || this._isTransitioning) {
						return;
					}

					var hideEvent = $__default['default'].Event(EVENT_HIDE$2);
					$__default['default'](this._element).trigger(hideEvent);

					if (!this._isShown || hideEvent.isDefaultPrevented()) {
						return;
					}

					this._isShown = false;
					var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);

					if (transition) {
						this._isTransitioning = true;
					}

					this._setEscapeEvent();

					this._setResizeEvent();

					$__default['default'](document).off(EVENT_FOCUSIN);
					$__default['default'](this._element).removeClass(CLASS_NAME_SHOW$3);
					$__default['default'](this._element).off(EVENT_CLICK_DISMISS);
					$__default['default'](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);

					if (transition) {
						var transitionDuration = Util.getTransitionDurationFromElement(this._element);
						$__default['default'](this._element).one(Util.TRANSITION_END, function (event) {
							return _this2._hideModal(event);
						}).emulateTransitionEnd(transitionDuration);
					} else {
						this._hideModal();
					}
				};

				_proto.dispose = function dispose() {
					[window, this._element, this._dialog].forEach(function (htmlElement) {
						return $__default['default'](htmlElement).off(EVENT_KEY$5);
					});
					/**
					 * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`
					 * Do not move `document` in `htmlElements` array
					 * It will remove `EVENT_CLICK_DATA_API` event that should remain
					 */

					$__default['default'](document).off(EVENT_FOCUSIN);
					$__default['default'].removeData(this._element, DATA_KEY$5);
					this._config = null;
					this._element = null;
					this._dialog = null;
					this._backdrop = null;
					this._isShown = null;
					this._isBodyOverflowing = null;
					this._ignoreBackdropClick = null;
					this._isTransitioning = null;
					this._scrollbarWidth = null;
				};

				_proto.handleUpdate = function handleUpdate() {
					this._adjustDialog();
				} // Private
				;

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, Default$3, config);
					Util.typeCheckConfig(NAME$5, config, DefaultType$3);
					return config;
				};

				_proto._triggerBackdropTransition = function _triggerBackdropTransition() {
					var _this3 = this;

					var hideEventPrevented = $__default['default'].Event(EVENT_HIDE_PREVENTED);
					$__default['default'](this._element).trigger(hideEventPrevented);

					if (hideEventPrevented.isDefaultPrevented()) {
						return;
					}

					var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

					if (!isModalOverflowing) {
						this._element.style.overflowY = 'hidden';
					}

					this._element.classList.add(CLASS_NAME_STATIC);

					var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);
					$__default['default'](this._element).off(Util.TRANSITION_END);
					$__default['default'](this._element).one(Util.TRANSITION_END, function () {
						_this3._element.classList.remove(CLASS_NAME_STATIC);

						if (!isModalOverflowing) {
							$__default['default'](_this3._element).one(Util.TRANSITION_END, function () {
								_this3._element.style.overflowY = '';
							}).emulateTransitionEnd(_this3._element, modalTransitionDuration);
						}
					}).emulateTransitionEnd(modalTransitionDuration);

					this._element.focus();
				};

				_proto._showElement = function _showElement(relatedTarget) {
					var _this4 = this;

					var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);
					var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;

					if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
						// Don't move modal's DOM position
						document.body.appendChild(this._element);
					}

					this._element.style.display = 'block';

					this._element.removeAttribute('aria-hidden');

					this._element.setAttribute('aria-modal', true);

					this._element.setAttribute('role', 'dialog');

					if ($__default['default'](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
						modalBody.scrollTop = 0;
					} else {
						this._element.scrollTop = 0;
					}

					if (transition) {
						Util.reflow(this._element);
					}

					$__default['default'](this._element).addClass(CLASS_NAME_SHOW$3);

					if (this._config.focus) {
						this._enforceFocus();
					}

					var shownEvent = $__default['default'].Event(EVENT_SHOWN$2, {
						relatedTarget: relatedTarget
					});

					var transitionComplete = function transitionComplete() {
						if (_this4._config.focus) {
							_this4._element.focus();
						}

						_this4._isTransitioning = false;
						$__default['default'](_this4._element).trigger(shownEvent);
					};

					if (transition) {
						var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
						$__default['default'](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
					} else {
						transitionComplete();
					}
				};

				_proto._enforceFocus = function _enforceFocus() {
					var _this5 = this;

					$__default['default'](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop
						.on(EVENT_FOCUSIN, function (event) {
							if (document !== event.target && _this5._element !== event.target && $__default['default'](_this5._element).has(event.target).length === 0) {
								_this5._element.focus();
							}
						});
				};

				_proto._setEscapeEvent = function _setEscapeEvent() {
					var _this6 = this;

					if (this._isShown) {
						$__default['default'](this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {
							if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {
								event.preventDefault();

								_this6.hide();
							} else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {
								_this6._triggerBackdropTransition();
							}
						});
					} else if (!this._isShown) {
						$__default['default'](this._element).off(EVENT_KEYDOWN_DISMISS);
					}
				};

				_proto._setResizeEvent = function _setResizeEvent() {
					var _this7 = this;

					if (this._isShown) {
						$__default['default'](window).on(EVENT_RESIZE, function (event) {
							return _this7.handleUpdate(event);
						});
					} else {
						$__default['default'](window).off(EVENT_RESIZE);
					}
				};

				_proto._hideModal = function _hideModal() {
					var _this8 = this;

					this._element.style.display = 'none';

					this._element.setAttribute('aria-hidden', true);

					this._element.removeAttribute('aria-modal');

					this._element.removeAttribute('role');

					this._isTransitioning = false;

					this._showBackdrop(function () {
						$__default['default'](document.body).removeClass(CLASS_NAME_OPEN);

						_this8._resetAdjustments();

						_this8._resetScrollbar();

						$__default['default'](_this8._element).trigger(EVENT_HIDDEN$2);
					});
				};

				_proto._removeBackdrop = function _removeBackdrop() {
					if (this._backdrop) {
						$__default['default'](this._backdrop).remove();
						this._backdrop = null;
					}
				};

				_proto._showBackdrop = function _showBackdrop(callback) {
					var _this9 = this;

					var animate = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1) ? CLASS_NAME_FADE$1 : '';

					if (this._isShown && this._config.backdrop) {
						this._backdrop = document.createElement('div');
						this._backdrop.className = CLASS_NAME_BACKDROP;

						if (animate) {
							this._backdrop.classList.add(animate);
						}

						$__default['default'](this._backdrop).appendTo(document.body);
						$__default['default'](this._element).on(EVENT_CLICK_DISMISS, function (event) {
							if (_this9._ignoreBackdropClick) {
								_this9._ignoreBackdropClick = false;
								return;
							}

							if (event.target !== event.currentTarget) {
								return;
							}

							if (_this9._config.backdrop === 'static') {
								_this9._triggerBackdropTransition();
							} else {
								_this9.hide();
							}
						});

						if (animate) {
							Util.reflow(this._backdrop);
						}

						$__default['default'](this._backdrop).addClass(CLASS_NAME_SHOW$3);

						if (!callback) {
							return;
						}

						if (!animate) {
							callback();
							return;
						}

						var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
						$__default['default'](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
					} else if (!this._isShown && this._backdrop) {
						$__default['default'](this._backdrop).removeClass(CLASS_NAME_SHOW$3);

						var callbackRemove = function callbackRemove() {
							_this9._removeBackdrop();

							if (callback) {
								callback();
							}
						};

						if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {
							var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

							$__default['default'](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
						} else {
							callbackRemove();
						}
					} else if (callback) {
						callback();
					}
				} // ----------------------------------------------------------------------
				// the following methods are used to handle overflowing modals
				// todo (fat): these should probably be refactored out of modal.js
				// ----------------------------------------------------------------------
				;

				_proto._adjustDialog = function _adjustDialog() {
					var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

					if (!this._isBodyOverflowing && isModalOverflowing) {
						this._element.style.paddingLeft = this._scrollbarWidth + "px";
					}

					if (this._isBodyOverflowing && !isModalOverflowing) {
						this._element.style.paddingRight = this._scrollbarWidth + "px";
					}
				};

				_proto._resetAdjustments = function _resetAdjustments() {
					this._element.style.paddingLeft = '';
					this._element.style.paddingRight = '';
				};

				_proto._checkScrollbar = function _checkScrollbar() {
					var rect = document.body.getBoundingClientRect();
					this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
					this._scrollbarWidth = this._getScrollbarWidth();
				};

				_proto._setScrollbar = function _setScrollbar() {
					var _this10 = this;

					if (this._isBodyOverflowing) {
						// Note: DOMNode.style.paddingRight returns the actual value or '' if not set
						//   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
						var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
						var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding

						$__default['default'](fixedContent).each(function (index, element) {
							var actualPadding = element.style.paddingRight;
							var calculatedPadding = $__default['default'](element).css('padding-right');
							$__default['default'](element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + "px");
						}); // Adjust sticky content margin

						$__default['default'](stickyContent).each(function (index, element) {
							var actualMargin = element.style.marginRight;
							var calculatedMargin = $__default['default'](element).css('margin-right');
							$__default['default'](element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
						}); // Adjust body padding

						var actualPadding = document.body.style.paddingRight;
						var calculatedPadding = $__default['default'](document.body).css('padding-right');
						$__default['default'](document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
					}

					$__default['default'](document.body).addClass(CLASS_NAME_OPEN);
				};

				_proto._resetScrollbar = function _resetScrollbar() {
					// Restore fixed content padding
					var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
					$__default['default'](fixedContent).each(function (index, element) {
						var padding = $__default['default'](element).data('padding-right');
						$__default['default'](element).removeData('padding-right');
						element.style.paddingRight = padding ? padding : '';
					}); // Restore sticky content

					var elements = [].slice.call(document.querySelectorAll("" + SELECTOR_STICKY_CONTENT));
					$__default['default'](elements).each(function (index, element) {
						var margin = $__default['default'](element).data('margin-right');

						if (typeof margin !== 'undefined') {
							$__default['default'](element).css('margin-right', margin).removeData('margin-right');
						}
					}); // Restore body padding

					var padding = $__default['default'](document.body).data('padding-right');
					$__default['default'](document.body).removeData('padding-right');
					document.body.style.paddingRight = padding ? padding : '';
				};

				_proto._getScrollbarWidth = function _getScrollbarWidth() {
					// thx d.walsh
					var scrollDiv = document.createElement('div');
					scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
					document.body.appendChild(scrollDiv);
					var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
					document.body.removeChild(scrollDiv);
					return scrollbarWidth;
				} // Static
				;

				Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
					return this.each(function () {
						var data = $__default['default'](this).data(DATA_KEY$5);

						var _config = _extends({}, Default$3, $__default['default'](this).data(), _typeof(config) === 'object' && config ? config : {});

						if (!data) {
							data = new Modal(this, _config);
							$__default['default'](this).data(DATA_KEY$5, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config](relatedTarget);
						} else if (_config.show) {
							data.show(relatedTarget);
						}
					});
				};

				_createClass(Modal, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$5;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$3;
					}
				}]);

				return Modal;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE$3, function (event) {
				var _this11 = this;

				var target;
				var selector = Util.getSelectorFromElement(this);

				if (selector) {
					target = document.querySelector(selector);
				}

				var config = $__default['default'](target).data(DATA_KEY$5) ? 'toggle' : _extends({}, $__default['default'](target).data(), $__default['default'](this).data());

				if (this.tagName === 'A' || this.tagName === 'AREA') {
					event.preventDefault();
				}

				var $target = $__default['default'](target).one(EVENT_SHOW$2, function (showEvent) {
					if (showEvent.isDefaultPrevented()) {
						// Only register focus restorer if modal will actually get shown
						return;
					}

					$target.one(EVENT_HIDDEN$2, function () {
						if ($__default['default'](_this11).is(':visible')) {
							_this11.focus();
						}
					});
				});

				Modal._jQueryInterface.call($__default['default'](target), config, this);
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$5] = Modal._jQueryInterface;
			$__default['default'].fn[NAME$5].Constructor = Modal;

			$__default['default'].fn[NAME$5].noConflict = function () {
				$__default['default'].fn[NAME$5] = JQUERY_NO_CONFLICT$5;
				return Modal._jQueryInterface;
			};
			/**
			 * --------------------------------------------------------------------------
			 * Bootstrap (v4.6.0): tools/sanitizer.js
			 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
			 * --------------------------------------------------------------------------
			 */


			var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
			var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
			var DefaultWhitelist = {
				// Global attributes allowed on any supplied element below.
				'*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
				a: ['target', 'href', 'title', 'rel'],
				area: [],
				b: [],
				br: [],
				col: [],
				code: [],
				div: [],
				em: [],
				hr: [],
				h1: [],
				h2: [],
				h3: [],
				h4: [],
				h5: [],
				h6: [],
				i: [],
				img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
				li: [],
				ol: [],
				p: [],
				pre: [],
				s: [],
				small: [],
				span: [],
				sub: [],
				sup: [],
				strong: [],
				u: [],
				ul: []
			};
			/**
			 * A pattern that recognizes a commonly useful subset of URLs that are safe.
			 *
			 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
			 */

			var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi;
			/**
			 * A pattern that matches safe data URLs. Only matches image, video and audio types.
			 *
			 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
			 */

			var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

			function allowedAttribute(attr, allowedAttributeList) {
				var attrName = attr.nodeName.toLowerCase();

				if (allowedAttributeList.indexOf(attrName) !== -1) {
					if (uriAttrs.indexOf(attrName) !== -1) {
						return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
					}

					return true;
				}

				var regExp = allowedAttributeList.filter(function (attrRegex) {
					return attrRegex instanceof RegExp;
				}); // Check if a regular expression validates the attribute.

				for (var i = 0, len = regExp.length; i < len; i++) {
					if (attrName.match(regExp[i])) {
						return true;
					}
				}

				return false;
			}

			function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
				if (unsafeHtml.length === 0) {
					return unsafeHtml;
				}

				if (sanitizeFn && typeof sanitizeFn === 'function') {
					return sanitizeFn(unsafeHtml);
				}

				var domParser = new window.DOMParser();
				var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
				var whitelistKeys = Object.keys(whiteList);
				var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

				var _loop = function _loop(i, len) {
					var el = elements[i];
					var elName = el.nodeName.toLowerCase();

					if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
						el.parentNode.removeChild(el);
						return "continue";
					}

					var attributeList = [].slice.call(el.attributes);
					var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
					attributeList.forEach(function (attr) {
						if (!allowedAttribute(attr, whitelistedAttributes)) {
							el.removeAttribute(attr.nodeName);
						}
					});
				};

				for (var i = 0, len = elements.length; i < len; i++) {
					var _ret = _loop(i);

					if (_ret === "continue") continue;
				}

				return createdDocument.body.innerHTML;
			}

			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$6 = 'tooltip';
			var VERSION$6 = '4.6.0';
			var DATA_KEY$6 = 'bs.tooltip';
			var EVENT_KEY$6 = "." + DATA_KEY$6;
			var JQUERY_NO_CONFLICT$6 = $__default['default'].fn[NAME$6];
			var CLASS_PREFIX = 'bs-tooltip';
			var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
			var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
			var DefaultType$4 = {
				animation: 'boolean',
				template: 'string',
				title: '(string|element|function)',
				trigger: 'string',
				delay: '(number|object)',
				html: 'boolean',
				selector: '(string|boolean)',
				placement: '(string|function)',
				offset: '(number|string|function)',
				container: '(string|element|boolean)',
				fallbackPlacement: '(string|array)',
				boundary: '(string|element)',
				customClass: '(string|function)',
				sanitize: 'boolean',
				sanitizeFn: '(null|function)',
				whiteList: 'object',
				popperConfig: '(null|object)'
			};
			var AttachmentMap = {
				AUTO: 'auto',
				TOP: 'top',
				RIGHT: 'right',
				BOTTOM: 'bottom',
				LEFT: 'left'
			};
			var Default$4 = {
				animation: true,
				template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
				trigger: 'hover focus',
				title: '',
				delay: 0,
				html: false,
				selector: false,
				placement: 'top',
				offset: 0,
				container: false,
				fallbackPlacement: 'flip',
				boundary: 'scrollParent',
				customClass: '',
				sanitize: true,
				sanitizeFn: null,
				whiteList: DefaultWhitelist,
				popperConfig: null
			};
			var HOVER_STATE_SHOW = 'show';
			var HOVER_STATE_OUT = 'out';
			var Event = {
				HIDE: "hide" + EVENT_KEY$6,
				HIDDEN: "hidden" + EVENT_KEY$6,
				SHOW: "show" + EVENT_KEY$6,
				SHOWN: "shown" + EVENT_KEY$6,
				INSERTED: "inserted" + EVENT_KEY$6,
				CLICK: "click" + EVENT_KEY$6,
				FOCUSIN: "focusin" + EVENT_KEY$6,
				FOCUSOUT: "focusout" + EVENT_KEY$6,
				MOUSEENTER: "mouseenter" + EVENT_KEY$6,
				MOUSELEAVE: "mouseleave" + EVENT_KEY$6
			};
			var CLASS_NAME_FADE$2 = 'fade';
			var CLASS_NAME_SHOW$4 = 'show';
			var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
			var SELECTOR_ARROW = '.arrow';
			var TRIGGER_HOVER = 'hover';
			var TRIGGER_FOCUS = 'focus';
			var TRIGGER_CLICK = 'click';
			var TRIGGER_MANUAL = 'manual';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Tooltip = /*#__PURE__*/function () {
				function Tooltip(element, config) {
					if (typeof Popper__default['default'] === 'undefined') {
						throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
					} // private


					this._isEnabled = true;
					this._timeout = 0;
					this._hoverState = '';
					this._activeTrigger = {};
					this._popper = null; // Protected

					this.element = element;
					this.config = this._getConfig(config);
					this.tip = null;

					this._setListeners();
				} // Getters


				var _proto = Tooltip.prototype; // Public

				_proto.enable = function enable() {
					this._isEnabled = true;
				};

				_proto.disable = function disable() {
					this._isEnabled = false;
				};

				_proto.toggleEnabled = function toggleEnabled() {
					this._isEnabled = !this._isEnabled;
				};

				_proto.toggle = function toggle(event) {
					if (!this._isEnabled) {
						return;
					}

					if (event) {
						var dataKey = this.constructor.DATA_KEY;
						var context = $__default['default'](event.currentTarget).data(dataKey);

						if (!context) {
							context = new this.constructor(event.currentTarget, this._getDelegateConfig());
							$__default['default'](event.currentTarget).data(dataKey, context);
						}

						context._activeTrigger.click = !context._activeTrigger.click;

						if (context._isWithActiveTrigger()) {
							context._enter(null, context);
						} else {
							context._leave(null, context);
						}
					} else {
						if ($__default['default'](this.getTipElement()).hasClass(CLASS_NAME_SHOW$4)) {
							this._leave(null, this);

							return;
						}

						this._enter(null, this);
					}
				};

				_proto.dispose = function dispose() {
					clearTimeout(this._timeout);
					$__default['default'].removeData(this.element, this.constructor.DATA_KEY);
					$__default['default'](this.element).off(this.constructor.EVENT_KEY);
					$__default['default'](this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);

					if (this.tip) {
						$__default['default'](this.tip).remove();
					}

					this._isEnabled = null;
					this._timeout = null;
					this._hoverState = null;
					this._activeTrigger = null;

					if (this._popper) {
						this._popper.destroy();
					}

					this._popper = null;
					this.element = null;
					this.config = null;
					this.tip = null;
				};

				_proto.show = function show() {
					var _this = this;

					if ($__default['default'](this.element).css('display') === 'none') {
						throw new Error('Please use show on visible elements');
					}

					var showEvent = $__default['default'].Event(this.constructor.Event.SHOW);

					if (this.isWithContent() && this._isEnabled) {
						$__default['default'](this.element).trigger(showEvent);
						var shadowRoot = Util.findShadowRoot(this.element);
						var isInTheDom = $__default['default'].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

						if (showEvent.isDefaultPrevented() || !isInTheDom) {
							return;
						}

						var tip = this.getTipElement();
						var tipId = Util.getUID(this.constructor.NAME);
						tip.setAttribute('id', tipId);
						this.element.setAttribute('aria-describedby', tipId);
						this.setContent();

						if (this.config.animation) {
							$__default['default'](tip).addClass(CLASS_NAME_FADE$2);
						}

						var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

						var attachment = this._getAttachment(placement);

						this.addAttachmentClass(attachment);

						var container = this._getContainer();

						$__default['default'](tip).data(this.constructor.DATA_KEY, this);

						if (!$__default['default'].contains(this.element.ownerDocument.documentElement, this.tip)) {
							$__default['default'](tip).appendTo(container);
						}

						$__default['default'](this.element).trigger(this.constructor.Event.INSERTED);
						this._popper = new Popper__default['default'](this.element, tip, this._getPopperConfig(attachment));
						$__default['default'](tip).addClass(CLASS_NAME_SHOW$4);
						$__default['default'](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra
						// empty mouseover listeners to the body's immediate children;
						// only needed because of broken event delegation on iOS
						// https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

						if ('ontouchstart' in document.documentElement) {
							$__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);
						}

						var complete = function complete() {
							if (_this.config.animation) {
								_this._fixTransition();
							}

							var prevHoverState = _this._hoverState;
							_this._hoverState = null;
							$__default['default'](_this.element).trigger(_this.constructor.Event.SHOWN);

							if (prevHoverState === HOVER_STATE_OUT) {
								_this._leave(null, _this);
							}
						};

						if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {
							var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
							$__default['default'](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
						} else {
							complete();
						}
					}
				};

				_proto.hide = function hide(callback) {
					var _this2 = this;

					var tip = this.getTipElement();
					var hideEvent = $__default['default'].Event(this.constructor.Event.HIDE);

					var complete = function complete() {
						if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
							tip.parentNode.removeChild(tip);
						}

						_this2._cleanTipClass();

						_this2.element.removeAttribute('aria-describedby');

						$__default['default'](_this2.element).trigger(_this2.constructor.Event.HIDDEN);

						if (_this2._popper !== null) {
							_this2._popper.destroy();
						}

						if (callback) {
							callback();
						}
					};

					$__default['default'](this.element).trigger(hideEvent);

					if (hideEvent.isDefaultPrevented()) {
						return;
					}

					$__default['default'](tip).removeClass(CLASS_NAME_SHOW$4); // If this is a touch-enabled device we remove the extra
					// empty mouseover listeners we added for iOS support

					if ('ontouchstart' in document.documentElement) {
						$__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);
					}

					this._activeTrigger[TRIGGER_CLICK] = false;
					this._activeTrigger[TRIGGER_FOCUS] = false;
					this._activeTrigger[TRIGGER_HOVER] = false;

					if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {
						var transitionDuration = Util.getTransitionDurationFromElement(tip);
						$__default['default'](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
					} else {
						complete();
					}

					this._hoverState = '';
				};

				_proto.update = function update() {
					if (this._popper !== null) {
						this._popper.scheduleUpdate();
					}
				} // Protected
				;

				_proto.isWithContent = function isWithContent() {
					return Boolean(this.getTitle());
				};

				_proto.addAttachmentClass = function addAttachmentClass(attachment) {
					$__default['default'](this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
				};

				_proto.getTipElement = function getTipElement() {
					this.tip = this.tip || $__default['default'](this.config.template)[0];
					return this.tip;
				};

				_proto.setContent = function setContent() {
					var tip = this.getTipElement();
					this.setElementContent($__default['default'](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
					$__default['default'](tip).removeClass(CLASS_NAME_FADE$2 + " " + CLASS_NAME_SHOW$4);
				};

				_proto.setElementContent = function setElementContent($element, content) {
					if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {
						// Content is a DOM node or a jQuery
						if (this.config.html) {
							if (!$__default['default'](content).parent().is($element)) {
								$element.empty().append(content);
							}
						} else {
							$element.text($__default['default'](content).text());
						}

						return;
					}

					if (this.config.html) {
						if (this.config.sanitize) {
							content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
						}

						$element.html(content);
					} else {
						$element.text(content);
					}
				};

				_proto.getTitle = function getTitle() {
					var title = this.element.getAttribute('data-original-title');

					if (!title) {
						title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
					}

					return title;
				} // Private
				;

				_proto._getPopperConfig = function _getPopperConfig(attachment) {
					var _this3 = this;

					var defaultBsConfig = {
						placement: attachment,
						modifiers: {
							offset: this._getOffset(),
							flip: {
								behavior: this.config.fallbackPlacement
							},
							arrow: {
								element: SELECTOR_ARROW
							},
							preventOverflow: {
								boundariesElement: this.config.boundary
							}
						},
						onCreate: function onCreate(data) {
							if (data.originalPlacement !== data.placement) {
								_this3._handlePopperPlacementChange(data);
							}
						},
						onUpdate: function onUpdate(data) {
							return _this3._handlePopperPlacementChange(data);
						}
					};
					return _extends({}, defaultBsConfig, this.config.popperConfig);
				};

				_proto._getOffset = function _getOffset() {
					var _this4 = this;

					var offset = {};

					if (typeof this.config.offset === 'function') {
						offset.fn = function (data) {
							data.offsets = _extends({}, data.offsets, _this4.config.offset(data.offsets, _this4.element) || {});
							return data;
						};
					} else {
						offset.offset = this.config.offset;
					}

					return offset;
				};

				_proto._getContainer = function _getContainer() {
					if (this.config.container === false) {
						return document.body;
					}

					if (Util.isElement(this.config.container)) {
						return $__default['default'](this.config.container);
					}

					return $__default['default'](document).find(this.config.container);
				};

				_proto._getAttachment = function _getAttachment(placement) {
					return AttachmentMap[placement.toUpperCase()];
				};

				_proto._setListeners = function _setListeners() {
					var _this5 = this;

					var triggers = this.config.trigger.split(' ');
					triggers.forEach(function (trigger) {
						if (trigger === 'click') {
							$__default['default'](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {
								return _this5.toggle(event);
							});
						} else if (trigger !== TRIGGER_MANUAL) {
							var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
							var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
							$__default['default'](_this5.element).on(eventIn, _this5.config.selector, function (event) {
								return _this5._enter(event);
							}).on(eventOut, _this5.config.selector, function (event) {
								return _this5._leave(event);
							});
						}
					});

					this._hideModalHandler = function () {
						if (_this5.element) {
							_this5.hide();
						}
					};

					$__default['default'](this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);

					if (this.config.selector) {
						this.config = _extends({}, this.config, {
							trigger: 'manual',
							selector: ''
						});
					} else {
						this._fixTitle();
					}
				};

				_proto._fixTitle = function _fixTitle() {
					var titleType = _typeof(this.element.getAttribute('data-original-title'));

					if (this.element.getAttribute('title') || titleType !== 'string') {
						this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
						this.element.setAttribute('title', '');
					}
				};

				_proto._enter = function _enter(event, context) {
					var dataKey = this.constructor.DATA_KEY;
					context = context || $__default['default'](event.currentTarget).data(dataKey);

					if (!context) {
						context = new this.constructor(event.currentTarget, this._getDelegateConfig());
						$__default['default'](event.currentTarget).data(dataKey, context);
					}

					if (event) {
						context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
					}

					if ($__default['default'](context.getTipElement()).hasClass(CLASS_NAME_SHOW$4) || context._hoverState === HOVER_STATE_SHOW) {
						context._hoverState = HOVER_STATE_SHOW;
						return;
					}

					clearTimeout(context._timeout);
					context._hoverState = HOVER_STATE_SHOW;

					if (!context.config.delay || !context.config.delay.show) {
						context.show();
						return;
					}

					context._timeout = setTimeout(function () {
						if (context._hoverState === HOVER_STATE_SHOW) {
							context.show();
						}
					}, context.config.delay.show);
				};

				_proto._leave = function _leave(event, context) {
					var dataKey = this.constructor.DATA_KEY;
					context = context || $__default['default'](event.currentTarget).data(dataKey);

					if (!context) {
						context = new this.constructor(event.currentTarget, this._getDelegateConfig());
						$__default['default'](event.currentTarget).data(dataKey, context);
					}

					if (event) {
						context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
					}

					if (context._isWithActiveTrigger()) {
						return;
					}

					clearTimeout(context._timeout);
					context._hoverState = HOVER_STATE_OUT;

					if (!context.config.delay || !context.config.delay.hide) {
						context.hide();
						return;
					}

					context._timeout = setTimeout(function () {
						if (context._hoverState === HOVER_STATE_OUT) {
							context.hide();
						}
					}, context.config.delay.hide);
				};

				_proto._isWithActiveTrigger = function _isWithActiveTrigger() {
					for (var trigger in this._activeTrigger) {
						if (this._activeTrigger[trigger]) {
							return true;
						}
					}

					return false;
				};

				_proto._getConfig = function _getConfig(config) {
					var dataAttributes = $__default['default'](this.element).data();
					Object.keys(dataAttributes).forEach(function (dataAttr) {
						if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
							delete dataAttributes[dataAttr];
						}
					});
					config = _extends({}, this.constructor.Default, dataAttributes, _typeof(config) === 'object' && config ? config : {});

					if (typeof config.delay === 'number') {
						config.delay = {
							show: config.delay,
							hide: config.delay
						};
					}

					if (typeof config.title === 'number') {
						config.title = config.title.toString();
					}

					if (typeof config.content === 'number') {
						config.content = config.content.toString();
					}

					Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

					if (config.sanitize) {
						config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
					}

					return config;
				};

				_proto._getDelegateConfig = function _getDelegateConfig() {
					var config = {};

					if (this.config) {
						for (var key in this.config) {
							if (this.constructor.Default[key] !== this.config[key]) {
								config[key] = this.config[key];
							}
						}
					}

					return config;
				};

				_proto._cleanTipClass = function _cleanTipClass() {
					var $tip = $__default['default'](this.getTipElement());
					var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

					if (tabClass !== null && tabClass.length) {
						$tip.removeClass(tabClass.join(''));
					}
				};

				_proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
					this.tip = popperData.instance.popper;

					this._cleanTipClass();

					this.addAttachmentClass(this._getAttachment(popperData.placement));
				};

				_proto._fixTransition = function _fixTransition() {
					var tip = this.getTipElement();
					var initConfigAnimation = this.config.animation;

					if (tip.getAttribute('x-placement') !== null) {
						return;
					}

					$__default['default'](tip).removeClass(CLASS_NAME_FADE$2);
					this.config.animation = false;
					this.hide();
					this.show();
					this.config.animation = initConfigAnimation;
				} // Static
				;

				Tooltip._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var $element = $__default['default'](this);
						var data = $element.data(DATA_KEY$6);

						var _config = _typeof(config) === 'object' && config;

						if (!data && /dispose|hide/.test(config)) {
							return;
						}

						if (!data) {
							data = new Tooltip(this, _config);
							$element.data(DATA_KEY$6, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				_createClass(Tooltip, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$6;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$4;
					}
				}, {
					key: "NAME",
					get: function get() {
						return NAME$6;
					}
				}, {
					key: "DATA_KEY",
					get: function get() {
						return DATA_KEY$6;
					}
				}, {
					key: "Event",
					get: function get() {
						return Event;
					}
				}, {
					key: "EVENT_KEY",
					get: function get() {
						return EVENT_KEY$6;
					}
				}, {
					key: "DefaultType",
					get: function get() {
						return DefaultType$4;
					}
				}]);

				return Tooltip;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */


			$__default['default'].fn[NAME$6] = Tooltip._jQueryInterface;
			$__default['default'].fn[NAME$6].Constructor = Tooltip;

			$__default['default'].fn[NAME$6].noConflict = function () {
				$__default['default'].fn[NAME$6] = JQUERY_NO_CONFLICT$6;
				return Tooltip._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$7 = 'popover';
			var VERSION$7 = '4.6.0';
			var DATA_KEY$7 = 'bs.popover';
			var EVENT_KEY$7 = "." + DATA_KEY$7;
			var JQUERY_NO_CONFLICT$7 = $__default['default'].fn[NAME$7];
			var CLASS_PREFIX$1 = 'bs-popover';
			var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

			var Default$5 = _extends({}, Tooltip.Default, {
				placement: 'right',
				trigger: 'click',
				content: '',
				template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
			});

			var DefaultType$5 = _extends({}, Tooltip.DefaultType, {
				content: '(string|element|function)'
			});

			var CLASS_NAME_FADE$3 = 'fade';
			var CLASS_NAME_SHOW$5 = 'show';
			var SELECTOR_TITLE = '.popover-header';
			var SELECTOR_CONTENT = '.popover-body';
			var Event$1 = {
				HIDE: "hide" + EVENT_KEY$7,
				HIDDEN: "hidden" + EVENT_KEY$7,
				SHOW: "show" + EVENT_KEY$7,
				SHOWN: "shown" + EVENT_KEY$7,
				INSERTED: "inserted" + EVENT_KEY$7,
				CLICK: "click" + EVENT_KEY$7,
				FOCUSIN: "focusin" + EVENT_KEY$7,
				FOCUSOUT: "focusout" + EVENT_KEY$7,
				MOUSEENTER: "mouseenter" + EVENT_KEY$7,
				MOUSELEAVE: "mouseleave" + EVENT_KEY$7
			};
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Popover = /*#__PURE__*/function (_Tooltip) {
				_inheritsLoose(Popover, _Tooltip);

				function Popover() {
					return _Tooltip.apply(this, arguments) || this;
				}

				var _proto = Popover.prototype; // Overrides

				_proto.isWithContent = function isWithContent() {
					return this.getTitle() || this._getContent();
				};

				_proto.addAttachmentClass = function addAttachmentClass(attachment) {
					$__default['default'](this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
				};

				_proto.getTipElement = function getTipElement() {
					this.tip = this.tip || $__default['default'](this.config.template)[0];
					return this.tip;
				};

				_proto.setContent = function setContent() {
					var $tip = $__default['default'](this.getTipElement()); // We use append for html objects to maintain js events

					this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());

					var content = this._getContent();

					if (typeof content === 'function') {
						content = content.call(this.element);
					}

					this.setElementContent($tip.find(SELECTOR_CONTENT), content);
					$tip.removeClass(CLASS_NAME_FADE$3 + " " + CLASS_NAME_SHOW$5);
				} // Private
				;

				_proto._getContent = function _getContent() {
					return this.element.getAttribute('data-content') || this.config.content;
				};

				_proto._cleanTipClass = function _cleanTipClass() {
					var $tip = $__default['default'](this.getTipElement());
					var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

					if (tabClass !== null && tabClass.length > 0) {
						$tip.removeClass(tabClass.join(''));
					}
				} // Static
				;

				Popover._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var data = $__default['default'](this).data(DATA_KEY$7);

						var _config = _typeof(config) === 'object' ? config : null;

						if (!data && /dispose|hide/.test(config)) {
							return;
						}

						if (!data) {
							data = new Popover(this, _config);
							$__default['default'](this).data(DATA_KEY$7, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				_createClass(Popover, null, [{
					key: "VERSION",
					// Getters
					get: function get() {
						return VERSION$7;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$5;
					}
				}, {
					key: "NAME",
					get: function get() {
						return NAME$7;
					}
				}, {
					key: "DATA_KEY",
					get: function get() {
						return DATA_KEY$7;
					}
				}, {
					key: "Event",
					get: function get() {
						return Event$1;
					}
				}, {
					key: "EVENT_KEY",
					get: function get() {
						return EVENT_KEY$7;
					}
				}, {
					key: "DefaultType",
					get: function get() {
						return DefaultType$5;
					}
				}]);

				return Popover;
			}(Tooltip);
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */


			$__default['default'].fn[NAME$7] = Popover._jQueryInterface;
			$__default['default'].fn[NAME$7].Constructor = Popover;

			$__default['default'].fn[NAME$7].noConflict = function () {
				$__default['default'].fn[NAME$7] = JQUERY_NO_CONFLICT$7;
				return Popover._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$8 = 'scrollspy';
			var VERSION$8 = '4.6.0';
			var DATA_KEY$8 = 'bs.scrollspy';
			var EVENT_KEY$8 = "." + DATA_KEY$8;
			var DATA_API_KEY$6 = '.data-api';
			var JQUERY_NO_CONFLICT$8 = $__default['default'].fn[NAME$8];
			var Default$6 = {
				offset: 10,
				method: 'auto',
				target: ''
			};
			var DefaultType$6 = {
				offset: 'number',
				method: 'string',
				target: '(string|element)'
			};
			var EVENT_ACTIVATE = "activate" + EVENT_KEY$8;
			var EVENT_SCROLL = "scroll" + EVENT_KEY$8;
			var EVENT_LOAD_DATA_API$2 = "load" + EVENT_KEY$8 + DATA_API_KEY$6;
			var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
			var CLASS_NAME_ACTIVE$2 = 'active';
			var SELECTOR_DATA_SPY = '[data-spy="scroll"]';
			var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
			var SELECTOR_NAV_LINKS = '.nav-link';
			var SELECTOR_NAV_ITEMS = '.nav-item';
			var SELECTOR_LIST_ITEMS = '.list-group-item';
			var SELECTOR_DROPDOWN = '.dropdown';
			var SELECTOR_DROPDOWN_ITEMS = '.dropdown-item';
			var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
			var METHOD_OFFSET = 'offset';
			var METHOD_POSITION = 'position';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var ScrollSpy = /*#__PURE__*/function () {
				function ScrollSpy(element, config) {
					var _this = this;

					this._element = element;
					this._scrollElement = element.tagName === 'BODY' ? window : element;
					this._config = this._getConfig(config);
					this._selector = this._config.target + " " + SELECTOR_NAV_LINKS + "," + (this._config.target + " " + SELECTOR_LIST_ITEMS + ",") + (this._config.target + " " + SELECTOR_DROPDOWN_ITEMS);
					this._offsets = [];
					this._targets = [];
					this._activeTarget = null;
					this._scrollHeight = 0;
					$__default['default'](this._scrollElement).on(EVENT_SCROLL, function (event) {
						return _this._process(event);
					});
					this.refresh();

					this._process();
				} // Getters


				var _proto = ScrollSpy.prototype; // Public

				_proto.refresh = function refresh() {
					var _this2 = this;

					var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
					var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
					var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
					this._offsets = [];
					this._targets = [];
					this._scrollHeight = this._getScrollHeight();
					var targets = [].slice.call(document.querySelectorAll(this._selector));
					targets.map(function (element) {
						var target;
						var targetSelector = Util.getSelectorFromElement(element);

						if (targetSelector) {
							target = document.querySelector(targetSelector);
						}

						if (target) {
							var targetBCR = target.getBoundingClientRect();

							if (targetBCR.width || targetBCR.height) {
								// TODO (fat): remove sketch reliance on jQuery position/offset
								return [$__default['default'](target)[offsetMethod]().top + offsetBase, targetSelector];
							}
						}

						return null;
					}).filter(function (item) {
						return item;
					}).sort(function (a, b) {
						return a[0] - b[0];
					}).forEach(function (item) {
						_this2._offsets.push(item[0]);

						_this2._targets.push(item[1]);
					});
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY$8);
					$__default['default'](this._scrollElement).off(EVENT_KEY$8);
					this._element = null;
					this._scrollElement = null;
					this._config = null;
					this._selector = null;
					this._offsets = null;
					this._targets = null;
					this._activeTarget = null;
					this._scrollHeight = null;
				} // Private
				;

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, Default$6, _typeof(config) === 'object' && config ? config : {});

					if (typeof config.target !== 'string' && Util.isElement(config.target)) {
						var id = $__default['default'](config.target).attr('id');

						if (!id) {
							id = Util.getUID(NAME$8);
							$__default['default'](config.target).attr('id', id);
						}

						config.target = "#" + id;
					}

					Util.typeCheckConfig(NAME$8, config, DefaultType$6);
					return config;
				};

				_proto._getScrollTop = function _getScrollTop() {
					return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
				};

				_proto._getScrollHeight = function _getScrollHeight() {
					return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
				};

				_proto._getOffsetHeight = function _getOffsetHeight() {
					return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
				};

				_proto._process = function _process() {
					var scrollTop = this._getScrollTop() + this._config.offset;

					var scrollHeight = this._getScrollHeight();

					var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

					if (this._scrollHeight !== scrollHeight) {
						this.refresh();
					}

					if (scrollTop >= maxScroll) {
						var target = this._targets[this._targets.length - 1];

						if (this._activeTarget !== target) {
							this._activate(target);
						}

						return;
					}

					if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
						this._activeTarget = null;

						this._clear();

						return;
					}

					for (var i = this._offsets.length; i--;) {
						var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

						if (isActiveTarget) {
							this._activate(this._targets[i]);
						}
					}
				};

				_proto._activate = function _activate(target) {
					this._activeTarget = target;

					this._clear();

					var queries = this._selector.split(',').map(function (selector) {
						return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
					});

					var $link = $__default['default']([].slice.call(document.querySelectorAll(queries.join(','))));

					if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {
						$link.closest(SELECTOR_DROPDOWN).find(SELECTOR_DROPDOWN_TOGGLE).addClass(CLASS_NAME_ACTIVE$2);
						$link.addClass(CLASS_NAME_ACTIVE$2);
					} else {
						// Set triggered link as active
						$link.addClass(CLASS_NAME_ACTIVE$2); // Set triggered links parents as active
						// With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

						$link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_LINKS + ", " + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$2); // Handle special case when .nav-link is inside .nav-item

						$link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$2);
					}

					$__default['default'](this._scrollElement).trigger(EVENT_ACTIVATE, {
						relatedTarget: target
					});
				};

				_proto._clear = function _clear() {
					[].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
						return node.classList.contains(CLASS_NAME_ACTIVE$2);
					}).forEach(function (node) {
						return node.classList.remove(CLASS_NAME_ACTIVE$2);
					});
				} // Static
				;

				ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var data = $__default['default'](this).data(DATA_KEY$8);

						var _config = _typeof(config) === 'object' && config;

						if (!data) {
							data = new ScrollSpy(this, _config);
							$__default['default'](this).data(DATA_KEY$8, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				_createClass(ScrollSpy, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$8;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$6;
					}
				}]);

				return ScrollSpy;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](window).on(EVENT_LOAD_DATA_API$2, function () {
				var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));
				var scrollSpysLength = scrollSpys.length;

				for (var i = scrollSpysLength; i--;) {
					var $spy = $__default['default'](scrollSpys[i]);

					ScrollSpy._jQueryInterface.call($spy, $spy.data());
				}
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$8] = ScrollSpy._jQueryInterface;
			$__default['default'].fn[NAME$8].Constructor = ScrollSpy;

			$__default['default'].fn[NAME$8].noConflict = function () {
				$__default['default'].fn[NAME$8] = JQUERY_NO_CONFLICT$8;
				return ScrollSpy._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$9 = 'tab';
			var VERSION$9 = '4.6.0';
			var DATA_KEY$9 = 'bs.tab';
			var EVENT_KEY$9 = "." + DATA_KEY$9;
			var DATA_API_KEY$7 = '.data-api';
			var JQUERY_NO_CONFLICT$9 = $__default['default'].fn[NAME$9];
			var EVENT_HIDE$3 = "hide" + EVENT_KEY$9;
			var EVENT_HIDDEN$3 = "hidden" + EVENT_KEY$9;
			var EVENT_SHOW$3 = "show" + EVENT_KEY$9;
			var EVENT_SHOWN$3 = "shown" + EVENT_KEY$9;
			var EVENT_CLICK_DATA_API$6 = "click" + EVENT_KEY$9 + DATA_API_KEY$7;
			var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
			var CLASS_NAME_ACTIVE$3 = 'active';
			var CLASS_NAME_DISABLED$1 = 'disabled';
			var CLASS_NAME_FADE$4 = 'fade';
			var CLASS_NAME_SHOW$6 = 'show';
			var SELECTOR_DROPDOWN$1 = '.dropdown';
			var SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';
			var SELECTOR_ACTIVE$2 = '.active';
			var SELECTOR_ACTIVE_UL = '> li > .active';
			var SELECTOR_DATA_TOGGLE$4 = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
			var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
			var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Tab = /*#__PURE__*/function () {
				function Tab(element) {
					this._element = element;
				} // Getters


				var _proto = Tab.prototype; // Public

				_proto.show = function show() {
					var _this = this;

					if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default['default'](this._element).hasClass(CLASS_NAME_ACTIVE$3) || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED$1)) {
						return;
					}

					var target;
					var previous;
					var listElement = $__default['default'](this._element).closest(SELECTOR_NAV_LIST_GROUP$1)[0];
					var selector = Util.getSelectorFromElement(this._element);

					if (listElement) {
						var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE$2;
						previous = $__default['default'].makeArray($__default['default'](listElement).find(itemSelector));
						previous = previous[previous.length - 1];
					}

					var hideEvent = $__default['default'].Event(EVENT_HIDE$3, {
						relatedTarget: this._element
					});
					var showEvent = $__default['default'].Event(EVENT_SHOW$3, {
						relatedTarget: previous
					});

					if (previous) {
						$__default['default'](previous).trigger(hideEvent);
					}

					$__default['default'](this._element).trigger(showEvent);

					if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
						return;
					}

					if (selector) {
						target = document.querySelector(selector);
					}

					this._activate(this._element, listElement);

					var complete = function complete() {
						var hiddenEvent = $__default['default'].Event(EVENT_HIDDEN$3, {
							relatedTarget: _this._element
						});
						var shownEvent = $__default['default'].Event(EVENT_SHOWN$3, {
							relatedTarget: previous
						});
						$__default['default'](previous).trigger(hiddenEvent);
						$__default['default'](_this._element).trigger(shownEvent);
					};

					if (target) {
						this._activate(target, target.parentNode, complete);
					} else {
						complete();
					}
				};

				_proto.dispose = function dispose() {
					$__default['default'].removeData(this._element, DATA_KEY$9);
					this._element = null;
				} // Private
				;

				_proto._activate = function _activate(element, container, callback) {
					var _this2 = this;

					var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $__default['default'](container).find(SELECTOR_ACTIVE_UL) : $__default['default'](container).children(SELECTOR_ACTIVE$2);
					var active = activeElements[0];
					var isTransitioning = callback && active && $__default['default'](active).hasClass(CLASS_NAME_FADE$4);

					var complete = function complete() {
						return _this2._transitionComplete(element, active, callback);
					};

					if (active && isTransitioning) {
						var transitionDuration = Util.getTransitionDurationFromElement(active);
						$__default['default'](active).removeClass(CLASS_NAME_SHOW$6).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
					} else {
						complete();
					}
				};

				_proto._transitionComplete = function _transitionComplete(element, active, callback) {
					if (active) {
						$__default['default'](active).removeClass(CLASS_NAME_ACTIVE$3);
						var dropdownChild = $__default['default'](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];

						if (dropdownChild) {
							$__default['default'](dropdownChild).removeClass(CLASS_NAME_ACTIVE$3);
						}

						if (active.getAttribute('role') === 'tab') {
							active.setAttribute('aria-selected', false);
						}
					}

					$__default['default'](element).addClass(CLASS_NAME_ACTIVE$3);

					if (element.getAttribute('role') === 'tab') {
						element.setAttribute('aria-selected', true);
					}

					Util.reflow(element);

					if (element.classList.contains(CLASS_NAME_FADE$4)) {
						element.classList.add(CLASS_NAME_SHOW$6);
					}

					if (element.parentNode && $__default['default'](element.parentNode).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
						var dropdownElement = $__default['default'](element).closest(SELECTOR_DROPDOWN$1)[0];

						if (dropdownElement) {
							var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE$1));
							$__default['default'](dropdownToggleList).addClass(CLASS_NAME_ACTIVE$3);
						}

						element.setAttribute('aria-expanded', true);
					}

					if (callback) {
						callback();
					}
				} // Static
				;

				Tab._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var $this = $__default['default'](this);
						var data = $this.data(DATA_KEY$9);

						if (!data) {
							data = new Tab(this);
							$this.data(DATA_KEY$9, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config]();
						}
					});
				};

				_createClass(Tab, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$9;
					}
				}]);

				return Tab;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * Data Api implementation
			 * ------------------------------------------------------------------------
			 */


			$__default['default'](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$4, function (event) {
				event.preventDefault();

				Tab._jQueryInterface.call($__default['default'](this), 'show');
			});
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */

			$__default['default'].fn[NAME$9] = Tab._jQueryInterface;
			$__default['default'].fn[NAME$9].Constructor = Tab;

			$__default['default'].fn[NAME$9].noConflict = function () {
				$__default['default'].fn[NAME$9] = JQUERY_NO_CONFLICT$9;
				return Tab._jQueryInterface;
			};
			/**
			 * ------------------------------------------------------------------------
			 * Constants
			 * ------------------------------------------------------------------------
			 */


			var NAME$a = 'toast';
			var VERSION$a = '4.6.0';
			var DATA_KEY$a = 'bs.toast';
			var EVENT_KEY$a = "." + DATA_KEY$a;
			var JQUERY_NO_CONFLICT$a = $__default['default'].fn[NAME$a];
			var EVENT_CLICK_DISMISS$1 = "click.dismiss" + EVENT_KEY$a;
			var EVENT_HIDE$4 = "hide" + EVENT_KEY$a;
			var EVENT_HIDDEN$4 = "hidden" + EVENT_KEY$a;
			var EVENT_SHOW$4 = "show" + EVENT_KEY$a;
			var EVENT_SHOWN$4 = "shown" + EVENT_KEY$a;
			var CLASS_NAME_FADE$5 = 'fade';
			var CLASS_NAME_HIDE = 'hide';
			var CLASS_NAME_SHOW$7 = 'show';
			var CLASS_NAME_SHOWING = 'showing';
			var DefaultType$7 = {
				animation: 'boolean',
				autohide: 'boolean',
				delay: 'number'
			};
			var Default$7 = {
				animation: true,
				autohide: true,
				delay: 500
			};
			var SELECTOR_DATA_DISMISS$1 = '[data-dismiss="toast"]';
			/**
			 * ------------------------------------------------------------------------
			 * Class Definition
			 * ------------------------------------------------------------------------
			 */

			var Toast = /*#__PURE__*/function () {
				function Toast(element, config) {
					this._element = element;
					this._config = this._getConfig(config);
					this._timeout = null;

					this._setListeners();
				} // Getters


				var _proto = Toast.prototype; // Public

				_proto.show = function show() {
					var _this = this;

					var showEvent = $__default['default'].Event(EVENT_SHOW$4);
					$__default['default'](this._element).trigger(showEvent);

					if (showEvent.isDefaultPrevented()) {
						return;
					}

					this._clearTimeout();

					if (this._config.animation) {
						this._element.classList.add(CLASS_NAME_FADE$5);
					}

					var complete = function complete() {
						_this._element.classList.remove(CLASS_NAME_SHOWING);

						_this._element.classList.add(CLASS_NAME_SHOW$7);

						$__default['default'](_this._element).trigger(EVENT_SHOWN$4);

						if (_this._config.autohide) {
							_this._timeout = setTimeout(function () {
								_this.hide();
							}, _this._config.delay);
						}
					};

					this._element.classList.remove(CLASS_NAME_HIDE);

					Util.reflow(this._element);

					this._element.classList.add(CLASS_NAME_SHOWING);

					if (this._config.animation) {
						var transitionDuration = Util.getTransitionDurationFromElement(this._element);
						$__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
					} else {
						complete();
					}
				};

				_proto.hide = function hide() {
					if (!this._element.classList.contains(CLASS_NAME_SHOW$7)) {
						return;
					}

					var hideEvent = $__default['default'].Event(EVENT_HIDE$4);
					$__default['default'](this._element).trigger(hideEvent);

					if (hideEvent.isDefaultPrevented()) {
						return;
					}

					this._close();
				};

				_proto.dispose = function dispose() {
					this._clearTimeout();

					if (this._element.classList.contains(CLASS_NAME_SHOW$7)) {
						this._element.classList.remove(CLASS_NAME_SHOW$7);
					}

					$__default['default'](this._element).off(EVENT_CLICK_DISMISS$1);
					$__default['default'].removeData(this._element, DATA_KEY$a);
					this._element = null;
					this._config = null;
				} // Private
				;

				_proto._getConfig = function _getConfig(config) {
					config = _extends({}, Default$7, $__default['default'](this._element).data(), _typeof(config) === 'object' && config ? config : {});
					Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
					return config;
				};

				_proto._setListeners = function _setListeners() {
					var _this2 = this;

					$__default['default'](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function () {
						return _this2.hide();
					});
				};

				_proto._close = function _close() {
					var _this3 = this;

					var complete = function complete() {
						_this3._element.classList.add(CLASS_NAME_HIDE);

						$__default['default'](_this3._element).trigger(EVENT_HIDDEN$4);
					};

					this._element.classList.remove(CLASS_NAME_SHOW$7);

					if (this._config.animation) {
						var transitionDuration = Util.getTransitionDurationFromElement(this._element);
						$__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
					} else {
						complete();
					}
				};

				_proto._clearTimeout = function _clearTimeout() {
					clearTimeout(this._timeout);
					this._timeout = null;
				} // Static
				;

				Toast._jQueryInterface = function _jQueryInterface(config) {
					return this.each(function () {
						var $element = $__default['default'](this);
						var data = $element.data(DATA_KEY$a);

						var _config = _typeof(config) === 'object' && config;

						if (!data) {
							data = new Toast(this, _config);
							$element.data(DATA_KEY$a, data);
						}

						if (typeof config === 'string') {
							if (typeof data[config] === 'undefined') {
								throw new TypeError("No method named \"" + config + "\"");
							}

							data[config](this);
						}
					});
				};

				_createClass(Toast, null, [{
					key: "VERSION",
					get: function get() {
						return VERSION$a;
					}
				}, {
					key: "DefaultType",
					get: function get() {
						return DefaultType$7;
					}
				}, {
					key: "Default",
					get: function get() {
						return Default$7;
					}
				}]);

				return Toast;
			}();
			/**
			 * ------------------------------------------------------------------------
			 * jQuery
			 * ------------------------------------------------------------------------
			 */


			$__default['default'].fn[NAME$a] = Toast._jQueryInterface;
			$__default['default'].fn[NAME$a].Constructor = Toast;

			$__default['default'].fn[NAME$a].noConflict = function () {
				$__default['default'].fn[NAME$a] = JQUERY_NO_CONFLICT$a;
				return Toast._jQueryInterface;
			};

			exports.Alert = Alert;
			exports.Button = Button;
			exports.Carousel = Carousel;
			exports.Collapse = Collapse;
			exports.Dropdown = Dropdown;
			exports.Modal = Modal;
			exports.Popover = Popover;
			exports.Scrollspy = ScrollSpy;
			exports.Tab = Tab;
			exports.Toast = Toast;
			exports.Tooltip = Tooltip;
			exports.Util = Util;
			Object.defineProperty(exports, '__esModule', {
				value: true
			});
		});

		/***/
	}),
	/* 4 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		__webpack_require__.r(__webpack_exports__);
		/* WEBPACK VAR INJECTION */
		(function (global) {
			/**!
			 * @fileOverview Kickass library to create and place poppers near their reference elements.
			 * @version 1.16.1
			 * @license
			 * Copyright (c) 2016 Federico Zivolo and contributors
			 *
			 * Permission is hereby granted, free of charge, to any person obtaining a copy
			 * of this software and associated documentation files (the "Software"), to deal
			 * in the Software without restriction, including without limitation the rights
			 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			 * copies of the Software, and to permit persons to whom the Software is
			 * furnished to do so, subject to the following conditions:
			 *
			 * The above copyright notice and this permission notice shall be included in all
			 * copies or substantial portions of the Software.
			 *
			 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			 * SOFTWARE.
			 */
			var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

			var timeoutDuration = function () {
				var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

				for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
					if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
						return 1;
					}
				}

				return 0;
			}();

			function microtaskDebounce(fn) {
				var called = false;
				return function () {
					if (called) {
						return;
					}

					called = true;
					window.Promise.resolve().then(function () {
						called = false;
						fn();
					});
				};
			}

			function taskDebounce(fn) {
				var scheduled = false;
				return function () {
					if (!scheduled) {
						scheduled = true;
						setTimeout(function () {
							scheduled = false;
							fn();
						}, timeoutDuration);
					}
				};
			}

			var supportsMicroTasks = isBrowser && window.Promise;
			/**
			 * Create a debounced version of a method, that's asynchronously deferred
			 * but called in the minimum time possible.
			 *
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Function} fn
			 * @returns {Function}
			 */

			var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

			/**
			 * Check if the given variable is a function
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Any} functionToCheck - variable to check
			 * @returns {Boolean} answer to: is a function?
			 */

			function isFunction(functionToCheck) {
				var getType = {};
				return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
			}

			/**
			 * Get CSS computed property of the given element
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Eement} element
			 * @argument {String} property
			 */


			function getStyleComputedProperty(element, property) {
				if (element.nodeType !== 1) {
					return [];
				} // NOTE: 1 DOM access here


				var window = element.ownerDocument.defaultView;
				var css = window.getComputedStyle(element, null);
				return property ? css[property] : css;
			}

			/**
			 * Returns the parentNode or the host of the element
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @returns {Element} parent
			 */


			function getParentNode(element) {
				if (element.nodeName === 'HTML') {
					return element;
				}

				return element.parentNode || element.host;
			}

			/**
			 * Returns the scrolling parent of the given element
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @returns {Element} scroll parent
			 */


			function getScrollParent(element) {
				// Return body, `getScroll` will take care to get the correct `scrollTop` from it
				if (!element) {
					return document.body;
				}

				switch (element.nodeName) {
					case 'HTML':
					case 'BODY':
						return element.ownerDocument.body;

					case '#document':
						return element.body;
				} // Firefox want us to check `-x` and `-y` variations as well


				var _getStyleComputedProp = getStyleComputedProperty(element),
					overflow = _getStyleComputedProp.overflow,
					overflowX = _getStyleComputedProp.overflowX,
					overflowY = _getStyleComputedProp.overflowY;

				if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
					return element;
				}

				return getScrollParent(getParentNode(element));
			}

			/**
			 * Returns the reference node of the reference object, or the reference object itself.
			 * @method
			 * @memberof Popper.Utils
			 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
			 * @returns {Element} parent
			 */


			function getReferenceNode(reference) {
				return reference && reference.referenceNode ? reference.referenceNode : reference;
			}

			var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
			var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

			/**
			 * Determines if the browser is Internet Explorer
			 * @method
			 * @memberof Popper.Utils
			 * @param {Number} version to check
			 * @returns {Boolean} isIE
			 */

			function isIE(version) {
				if (version === 11) {
					return isIE11;
				}

				if (version === 10) {
					return isIE10;
				}

				return isIE11 || isIE10;
			}

			/**
			 * Returns the offset parent of the given element
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @returns {Element} offset parent
			 */


			function getOffsetParent(element) {
				if (!element) {
					return document.documentElement;
				}

				var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

				var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

				while (offsetParent === noOffsetParent && element.nextElementSibling) {
					offsetParent = (element = element.nextElementSibling).offsetParent;
				}

				var nodeName = offsetParent && offsetParent.nodeName;

				if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
					return element ? element.ownerDocument.documentElement : document.documentElement;
				} // .offsetParent will return the closest TH, TD or TABLE in case
				// no offsetParent is present, I hate this job...


				if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
					return getOffsetParent(offsetParent);
				}

				return offsetParent;
			}

			function isOffsetContainer(element) {
				var nodeName = element.nodeName;

				if (nodeName === 'BODY') {
					return false;
				}

				return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
			}

			/**
			 * Finds the root node (document, shadowDOM root) of the given element
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} node
			 * @returns {Element} root node
			 */


			function getRoot(node) {
				if (node.parentNode !== null) {
					return getRoot(node.parentNode);
				}

				return node;
			}

			/**
			 * Finds the offset parent common to the two provided nodes
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element1
			 * @argument {Element} element2
			 * @returns {Element} common offset parent
			 */


			function findCommonOffsetParent(element1, element2) {
				// This check is needed to avoid errors in case one of the elements isn't defined for any reason
				if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
					return document.documentElement;
				} // Here we make sure to give as "start" the element that comes first in the DOM


				var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
				var start = order ? element1 : element2;
				var end = order ? element2 : element1; // Get common ancestor container

				var range = document.createRange();
				range.setStart(start, 0);
				range.setEnd(end, 0);
				var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

				if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
					if (isOffsetContainer(commonAncestorContainer)) {
						return commonAncestorContainer;
					}

					return getOffsetParent(commonAncestorContainer);
				} // one of the nodes is inside shadowDOM, find which one


				var element1root = getRoot(element1);

				if (element1root.host) {
					return findCommonOffsetParent(element1root.host, element2);
				} else {
					return findCommonOffsetParent(element1, getRoot(element2).host);
				}
			}

			/**
			 * Gets the scroll value of the given element in the given side (top and left)
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @argument {String} side `top` or `left`
			 * @returns {number} amount of scrolled pixels
			 */


			function getScroll(element) {
				var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
				var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
				var nodeName = element.nodeName;

				if (nodeName === 'BODY' || nodeName === 'HTML') {
					var html = element.ownerDocument.documentElement;
					var scrollingElement = element.ownerDocument.scrollingElement || html;
					return scrollingElement[upperSide];
				}

				return element[upperSide];
			}

			/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


			function includeScroll(rect, element) {
				var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
				var scrollTop = getScroll(element, 'top');
				var scrollLeft = getScroll(element, 'left');
				var modifier = subtract ? -1 : 1;
				rect.top += scrollTop * modifier;
				rect.bottom += scrollTop * modifier;
				rect.left += scrollLeft * modifier;
				rect.right += scrollLeft * modifier;
				return rect;
			}

			/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


			function getBordersSize(styles, axis) {
				var sideA = axis === 'x' ? 'Left' : 'Top';
				var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
				return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
			}

			function getSize(axis, body, html, computedStyle) {
				return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
			}

			function getWindowSizes(document) {
				var body = document.body;
				var html = document.documentElement;
				var computedStyle = isIE(10) && getComputedStyle(html);
				return {
					height: getSize('Height', body, html, computedStyle),
					width: getSize('Width', body, html, computedStyle)
				};
			}

			var classCallCheck = function classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			};

			var createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];
						descriptor.enumerable = descriptor.enumerable || false;
						descriptor.configurable = true;
						if ("value" in descriptor) descriptor.writable = true;
						Object.defineProperty(target, descriptor.key, descriptor);
					}
				}

				return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);
					if (staticProps) defineProperties(Constructor, staticProps);
					return Constructor;
				};
			}();

			var defineProperty = function defineProperty(obj, key, value) {
				if (key in obj) {
					Object.defineProperty(obj, key, {
						value: value,
						enumerable: true,
						configurable: true,
						writable: true
					});
				} else {
					obj[key] = value;
				}

				return obj;
			};

			var _extends = Object.assign || function (target) {
				for (var i = 1; i < arguments.length; i++) {
					var source = arguments[i];

					for (var key in source) {
						if (Object.prototype.hasOwnProperty.call(source, key)) {
							target[key] = source[key];
						}
					}
				}

				return target;
			};

			/**
			 * Given element offsets, generate an output similar to getBoundingClientRect
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Object} offsets
			 * @returns {Object} ClientRect like output
			 */


			function getClientRect(offsets) {
				return _extends({}, offsets, {
					right: offsets.left + offsets.width,
					bottom: offsets.top + offsets.height
				});
			}

			/**
			 * Get bounding client rect of given element
			 * @method
			 * @memberof Popper.Utils
			 * @param {HTMLElement} element
			 * @return {Object} client rect
			 */


			function getBoundingClientRect(element) {
				var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
				// considered in DOM in some circumstances...
				// This isn't reproducible in IE10 compatibility mode of IE11

				try {
					if (isIE(10)) {
						rect = element.getBoundingClientRect();
						var scrollTop = getScroll(element, 'top');
						var scrollLeft = getScroll(element, 'left');
						rect.top += scrollTop;
						rect.left += scrollLeft;
						rect.bottom += scrollTop;
						rect.right += scrollLeft;
					} else {
						rect = element.getBoundingClientRect();
					}
				} catch (e) {
				}

				var result = {
					left: rect.left,
					top: rect.top,
					width: rect.right - rect.left,
					height: rect.bottom - rect.top
				}; // subtract scrollbar size from sizes

				var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
				var width = sizes.width || element.clientWidth || result.width;
				var height = sizes.height || element.clientHeight || result.height;
				var horizScrollbar = element.offsetWidth - width;
				var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
				// we make this check conditional for performance reasons

				if (horizScrollbar || vertScrollbar) {
					var styles = getStyleComputedProperty(element);
					horizScrollbar -= getBordersSize(styles, 'x');
					vertScrollbar -= getBordersSize(styles, 'y');
					result.width -= horizScrollbar;
					result.height -= vertScrollbar;
				}

				return getClientRect(result);
			}

			function getOffsetRectRelativeToArbitraryNode(children, parent) {
				var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
				var isIE10 = isIE(10);
				var isHTML = parent.nodeName === 'HTML';
				var childrenRect = getBoundingClientRect(children);
				var parentRect = getBoundingClientRect(parent);
				var scrollParent = getScrollParent(children);
				var styles = getStyleComputedProperty(parent);
				var borderTopWidth = parseFloat(styles.borderTopWidth);
				var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

				if (fixedPosition && isHTML) {
					parentRect.top = Math.max(parentRect.top, 0);
					parentRect.left = Math.max(parentRect.left, 0);
				}

				var offsets = getClientRect({
					top: childrenRect.top - parentRect.top - borderTopWidth,
					left: childrenRect.left - parentRect.left - borderLeftWidth,
					width: childrenRect.width,
					height: childrenRect.height
				});
				offsets.marginTop = 0;
				offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
				// we do this only on HTML because it's the only element that behaves
				// differently when margins are applied to it. The margins are included in
				// the box of the documentElement, in the other cases not.

				if (!isIE10 && isHTML) {
					var marginTop = parseFloat(styles.marginTop);
					var marginLeft = parseFloat(styles.marginLeft);
					offsets.top -= borderTopWidth - marginTop;
					offsets.bottom -= borderTopWidth - marginTop;
					offsets.left -= borderLeftWidth - marginLeft;
					offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

					offsets.marginTop = marginTop;
					offsets.marginLeft = marginLeft;
				}

				if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
					offsets = includeScroll(offsets, parent);
				}

				return offsets;
			}

			function getViewportOffsetRectRelativeToArtbitraryNode(element) {
				var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
				var html = element.ownerDocument.documentElement;
				var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
				var width = Math.max(html.clientWidth, window.innerWidth || 0);
				var height = Math.max(html.clientHeight, window.innerHeight || 0);
				var scrollTop = !excludeScroll ? getScroll(html) : 0;
				var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
				var offset = {
					top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
					left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
					width: width,
					height: height
				};
				return getClientRect(offset);
			}

			/**
			 * Check if the given element is fixed or is inside a fixed parent
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @argument {Element} customContainer
			 * @returns {Boolean} answer to "isFixed?"
			 */


			function isFixed(element) {
				var nodeName = element.nodeName;

				if (nodeName === 'BODY' || nodeName === 'HTML') {
					return false;
				}

				if (getStyleComputedProperty(element, 'position') === 'fixed') {
					return true;
				}

				var parentNode = getParentNode(element);

				if (!parentNode) {
					return false;
				}

				return isFixed(parentNode);
			}

			/**
			 * Finds the first parent of an element that has a transformed property defined
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @returns {Element} first transformed parent or documentElement
			 */


			function getFixedPositionOffsetParent(element) {
				// This check is needed to avoid errors in case one of the elements isn't defined for any reason
				if (!element || !element.parentElement || isIE()) {
					return document.documentElement;
				}

				var el = element.parentElement;

				while (el && getStyleComputedProperty(el, 'transform') === 'none') {
					el = el.parentElement;
				}

				return el || document.documentElement;
			}

			/**
			 * Computed the boundaries limits and return them
			 * @method
			 * @memberof Popper.Utils
			 * @param {HTMLElement} popper
			 * @param {HTMLElement} reference
			 * @param {number} padding
			 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
			 * @param {Boolean} fixedPosition - Is in fixed position mode
			 * @returns {Object} Coordinates of the boundaries
			 */


			function getBoundaries(popper, reference, padding, boundariesElement) {
				var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

				var boundaries = {
					top: 0,
					left: 0
				};
				var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

				if (boundariesElement === 'viewport') {
					boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
				} else {
					// Handle other cases based on DOM element used as boundaries
					var boundariesNode = void 0;

					if (boundariesElement === 'scrollParent') {
						boundariesNode = getScrollParent(getParentNode(reference));

						if (boundariesNode.nodeName === 'BODY') {
							boundariesNode = popper.ownerDocument.documentElement;
						}
					} else if (boundariesElement === 'window') {
						boundariesNode = popper.ownerDocument.documentElement;
					} else {
						boundariesNode = boundariesElement;
					}

					var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

					if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
						var _getWindowSizes = getWindowSizes(popper.ownerDocument),
							height = _getWindowSizes.height,
							width = _getWindowSizes.width;

						boundaries.top += offsets.top - offsets.marginTop;
						boundaries.bottom = height + offsets.top;
						boundaries.left += offsets.left - offsets.marginLeft;
						boundaries.right = width + offsets.left;
					} else {
						// for all the other DOM elements, this one is good
						boundaries = offsets;
					}
				} // Add paddings


				padding = padding || 0;
				var isPaddingNumber = typeof padding === 'number';
				boundaries.left += isPaddingNumber ? padding : padding.left || 0;
				boundaries.top += isPaddingNumber ? padding : padding.top || 0;
				boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
				boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
				return boundaries;
			}

			function getArea(_ref) {
				var width = _ref.width,
					height = _ref.height;
				return width * height;
			}

			/**
			 * Utility used to transform the `auto` placement to the placement with more
			 * available space.
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
				var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

				if (placement.indexOf('auto') === -1) {
					return placement;
				}

				var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
				var rects = {
					top: {
						width: boundaries.width,
						height: refRect.top - boundaries.top
					},
					right: {
						width: boundaries.right - refRect.right,
						height: boundaries.height
					},
					bottom: {
						width: boundaries.width,
						height: boundaries.bottom - refRect.bottom
					},
					left: {
						width: refRect.left - boundaries.left,
						height: boundaries.height
					}
				};
				var sortedAreas = Object.keys(rects).map(function (key) {
					return _extends({
						key: key
					}, rects[key], {
						area: getArea(rects[key])
					});
				}).sort(function (a, b) {
					return b.area - a.area;
				});
				var filteredAreas = sortedAreas.filter(function (_ref2) {
					var width = _ref2.width,
						height = _ref2.height;
					return width >= popper.clientWidth && height >= popper.clientHeight;
				});
				var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
				var variation = placement.split('-')[1];
				return computedPlacement + (variation ? '-' + variation : '');
			}

			/**
			 * Get offsets to the reference element
			 * @method
			 * @memberof Popper.Utils
			 * @param {Object} state
			 * @param {Element} popper - the popper element
			 * @param {Element} reference - the reference element (the popper will be relative to this)
			 * @param {Element} fixedPosition - is in fixed position mode
			 * @returns {Object} An object containing the offsets which will be applied to the popper
			 */


			function getReferenceOffsets(state, popper, reference) {
				var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
				var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
				return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
			}

			/**
			 * Get the outer sizes of the given element (offset size + margins)
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element
			 * @returns {Object} object containing width and height properties
			 */


			function getOuterSizes(element) {
				var window = element.ownerDocument.defaultView;
				var styles = window.getComputedStyle(element);
				var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
				var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
				var result = {
					width: element.offsetWidth + y,
					height: element.offsetHeight + x
				};
				return result;
			}

			/**
			 * Get the opposite placement of the given one
			 * @method
			 * @memberof Popper.Utils
			 * @argument {String} placement
			 * @returns {String} flipped placement
			 */


			function getOppositePlacement(placement) {
				var hash = {
					left: 'right',
					right: 'left',
					bottom: 'top',
					top: 'bottom'
				};
				return placement.replace(/left|right|bottom|top/g, function (matched) {
					return hash[matched];
				});
			}

			/**
			 * Get offsets to the popper
			 * @method
			 * @memberof Popper.Utils
			 * @param {Object} position - CSS position the Popper will get applied
			 * @param {HTMLElement} popper - the popper element
			 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
			 * @param {String} placement - one of the valid placement options
			 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
			 */


			function getPopperOffsets(popper, referenceOffsets, placement) {
				placement = placement.split('-')[0]; // Get popper node sizes

				var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

				var popperOffsets = {
					width: popperRect.width,
					height: popperRect.height
				}; // depending by the popper placement we have to compute its offsets slightly differently

				var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
				var mainSide = isHoriz ? 'top' : 'left';
				var secondarySide = isHoriz ? 'left' : 'top';
				var measurement = isHoriz ? 'height' : 'width';
				var secondaryMeasurement = !isHoriz ? 'height' : 'width';
				popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

				if (placement === secondarySide) {
					popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
				} else {
					popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
				}

				return popperOffsets;
			}

			/**
			 * Mimics the `find` method of Array
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Array} arr
			 * @argument prop
			 * @argument value
			 * @returns index or -1
			 */


			function find(arr, check) {
				// use native find if supported
				if (Array.prototype.find) {
					return arr.find(check);
				} // use `filter` to obtain the same behavior of `find`


				return arr.filter(check)[0];
			}

			/**
			 * Return the index of the matching object
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Array} arr
			 * @argument prop
			 * @argument value
			 * @returns index or -1
			 */


			function findIndex(arr, prop, value) {
				// use native findIndex if supported
				if (Array.prototype.findIndex) {
					return arr.findIndex(function (cur) {
						return cur[prop] === value;
					});
				} // use `find` + `indexOf` if `findIndex` isn't supported


				var match = find(arr, function (obj) {
					return obj[prop] === value;
				});
				return arr.indexOf(match);
			}

			/**
			 * Loop trough the list of modifiers and run them in order,
			 * each of them will then edit the data object.
			 * @method
			 * @memberof Popper.Utils
			 * @param {dataObject} data
			 * @param {Array} modifiers
			 * @param {String} ends - Optional modifier name used as stopper
			 * @returns {dataObject}
			 */


			function runModifiers(modifiers, data, ends) {
				var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
				modifiersToRun.forEach(function (modifier) {
					if (modifier['function']) {
						// eslint-disable-line dot-notation
						console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
					}

					var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

					if (modifier.enabled && isFunction(fn)) {
						// Add properties to offsets to make them a complete clientRect object
						// we do this before each modifier to make sure the previous one doesn't
						// mess with these values
						data.offsets.popper = getClientRect(data.offsets.popper);
						data.offsets.reference = getClientRect(data.offsets.reference);
						data = fn(data, modifier);
					}
				});
				return data;
			}

			/**
			 * Updates the position of the popper, computing the new offsets and applying
			 * the new style.<br />
			 * Prefer `scheduleUpdate` over `update` because of performance reasons.
			 * @method
			 * @memberof Popper
			 */


			function update() {
				// if popper is destroyed, don't perform any further update
				if (this.state.isDestroyed) {
					return;
				}

				var data = {
					instance: this,
					styles: {},
					arrowStyles: {},
					attributes: {},
					flipped: false,
					offsets: {}
				}; // compute reference element offsets

				data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
				// modifiers will be able to edit `placement` if needed
				// and refer to originalPlacement to know the original value

				data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

				data.originalPlacement = data.placement;
				data.positionFixed = this.options.positionFixed; // compute the popper offsets

				data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
				data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

				data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
				// the other ones will call `onUpdate` callback

				if (!this.state.isCreated) {
					this.state.isCreated = true;
					this.options.onCreate(data);
				} else {
					this.options.onUpdate(data);
				}
			}

			/**
			 * Helper used to know if the given modifier is enabled.
			 * @method
			 * @memberof Popper.Utils
			 * @returns {Boolean}
			 */


			function isModifierEnabled(modifiers, modifierName) {
				return modifiers.some(function (_ref) {
					var name = _ref.name,
						enabled = _ref.enabled;
					return enabled && name === modifierName;
				});
			}

			/**
			 * Get the prefixed supported property name
			 * @method
			 * @memberof Popper.Utils
			 * @argument {String} property (camelCase)
			 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
			 */


			function getSupportedPropertyName(property) {
				var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
				var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

				for (var i = 0; i < prefixes.length; i++) {
					var prefix = prefixes[i];
					var toCheck = prefix ? '' + prefix + upperProp : property;

					if (typeof document.body.style[toCheck] !== 'undefined') {
						return toCheck;
					}
				}

				return null;
			}

			/**
			 * Destroys the popper.
			 * @method
			 * @memberof Popper
			 */


			function destroy() {
				this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

				if (isModifierEnabled(this.modifiers, 'applyStyle')) {
					this.popper.removeAttribute('x-placement');
					this.popper.style.position = '';
					this.popper.style.top = '';
					this.popper.style.left = '';
					this.popper.style.right = '';
					this.popper.style.bottom = '';
					this.popper.style.willChange = '';
					this.popper.style[getSupportedPropertyName('transform')] = '';
				}

				this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
				// do not use `remove` because IE11 doesn't support it

				if (this.options.removeOnDestroy) {
					this.popper.parentNode.removeChild(this.popper);
				}

				return this;
			}

			/**
			 * Get the window associated with the element
			 * @argument {Element} element
			 * @returns {Window}
			 */


			function getWindow(element) {
				var ownerDocument = element.ownerDocument;
				return ownerDocument ? ownerDocument.defaultView : window;
			}

			function attachToScrollParents(scrollParent, event, callback, scrollParents) {
				var isBody = scrollParent.nodeName === 'BODY';
				var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
				target.addEventListener(event, callback, {
					passive: true
				});

				if (!isBody) {
					attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
				}

				scrollParents.push(target);
			}

			/**
			 * Setup needed event listeners used to update the popper position
			 * @method
			 * @memberof Popper.Utils
			 * @private
			 */


			function setupEventListeners(reference, options, state, updateBound) {
				// Resize event listener on window
				state.updateBound = updateBound;
				getWindow(reference).addEventListener('resize', state.updateBound, {
					passive: true
				}); // Scroll event listener on scroll parents

				var scrollElement = getScrollParent(reference);
				attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
				state.scrollElement = scrollElement;
				state.eventsEnabled = true;
				return state;
			}

			/**
			 * It will add resize/scroll events and start recalculating
			 * position of the popper element when they are triggered.
			 * @method
			 * @memberof Popper
			 */


			function enableEventListeners() {
				if (!this.state.eventsEnabled) {
					this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
				}
			}

			/**
			 * Remove event listeners used to update the popper position
			 * @method
			 * @memberof Popper.Utils
			 * @private
			 */


			function removeEventListeners(reference, state) {
				// Remove resize event listener on window
				getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

				state.scrollParents.forEach(function (target) {
					target.removeEventListener('scroll', state.updateBound);
				}); // Reset state

				state.updateBound = null;
				state.scrollParents = [];
				state.scrollElement = null;
				state.eventsEnabled = false;
				return state;
			}

			/**
			 * It will remove resize/scroll events and won't recalculate popper position
			 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
			 * unless you call `update` method manually.
			 * @method
			 * @memberof Popper
			 */


			function disableEventListeners() {
				if (this.state.eventsEnabled) {
					cancelAnimationFrame(this.scheduleUpdate);
					this.state = removeEventListeners(this.reference, this.state);
				}
			}

			/**
			 * Tells if a given input is a number
			 * @method
			 * @memberof Popper.Utils
			 * @param {*} input to check
			 * @return {Boolean}
			 */


			function isNumeric(n) {
				return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
			}

			/**
			 * Set the style to the given popper
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element - Element to apply the style to
			 * @argument {Object} styles
			 * Object with a list of properties and values which will be applied to the element
			 */


			function setStyles(element, styles) {
				Object.keys(styles).forEach(function (prop) {
					var unit = ''; // add unit if the value is numeric and is one of the following

					if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
						unit = 'px';
					}

					element.style[prop] = styles[prop] + unit;
				});
			}

			/**
			 * Set the attributes to the given popper
			 * @method
			 * @memberof Popper.Utils
			 * @argument {Element} element - Element to apply the attributes to
			 * @argument {Object} styles
			 * Object with a list of properties and values which will be applied to the element
			 */


			function setAttributes(element, attributes) {
				Object.keys(attributes).forEach(function (prop) {
					var value = attributes[prop];

					if (value !== false) {
						element.setAttribute(prop, attributes[prop]);
					} else {
						element.removeAttribute(prop);
					}
				});
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Object} data.styles - List of style properties - values to apply to popper element
			 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The same data object
			 */


			function applyStyle(data) {
				// any property present in `data.styles` will be applied to the popper,
				// in this way we can make the 3rd party modifiers add custom styles to it
				// Be aware, modifiers could override the properties defined in the previous
				// lines of this modifier!
				setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
				// they will be set as HTML attributes of the element

				setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

				if (data.arrowElement && Object.keys(data.arrowStyles).length) {
					setStyles(data.arrowElement, data.arrowStyles);
				}

				return data;
			}

			/**
			 * Set the x-placement attribute before everything else because it could be used
			 * to add margins to the popper margins needs to be calculated to get the
			 * correct popper offsets.
			 * @method
			 * @memberof Popper.modifiers
			 * @param {HTMLElement} reference - The reference element used to position the popper
			 * @param {HTMLElement} popper - The HTML element used as popper
			 * @param {Object} options - Popper.js options
			 */


			function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
				// compute reference element offsets
				var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
				// modifiers will be able to edit `placement` if needed
				// and refer to originalPlacement to know the original value

				var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
				popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
				// without the position applied we can't guarantee correct computations

				setStyles(popper, {
					position: options.positionFixed ? 'fixed' : 'absolute'
				});
				return options;
			}

			/**
			 * @function
			 * @memberof Popper.Utils
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
			 * @returns {Object} The popper's position offsets rounded
			 *
			 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
			 * good as it can be within reason.
			 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
			 *
			 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
			 * as well on High DPI screens).
			 *
			 * Firefox prefers no rounding for positioning and does not have blurriness on
			 * high DPI screens.
			 *
			 * Only horizontal placement and left/right values need to be considered.
			 */


			function getRoundedOffsets(data, shouldRound) {
				var _data$offsets = data.offsets,
					popper = _data$offsets.popper,
					reference = _data$offsets.reference;
				var round = Math.round,
					floor = Math.floor;

				var noRound = function noRound(v) {
					return v;
				};

				var referenceWidth = round(reference.width);
				var popperWidth = round(popper.width);
				var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
				var isVariation = data.placement.indexOf('-') !== -1;
				var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
				var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
				var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
				var verticalToInteger = !shouldRound ? noRound : round;
				return {
					left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
					top: verticalToInteger(popper.top),
					bottom: verticalToInteger(popper.bottom),
					right: horizontalToInteger(popper.right)
				};
			}

			var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */

			function computeStyle(data, options) {
				var x = options.x,
					y = options.y;
				var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

				var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
					return modifier.name === 'applyStyle';
				}).gpuAcceleration;

				if (legacyGpuAccelerationOption !== undefined) {
					console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
				}

				var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
				var offsetParent = getOffsetParent(data.instance.popper);
				var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

				var styles = {
					position: popper.position
				};
				var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
				var sideA = x === 'bottom' ? 'top' : 'bottom';
				var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
				//  we use `translate3d` to apply the position to the popper we
				// automatically use the supported prefixed version if needed

				var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
				// If the content of the popper grows once it's been positioned, it
				// may happen that the popper gets misplaced because of the new content
				// overflowing its reference element
				// To avoid this problem, we provide two options (x and y), which allow
				// the consumer to define the offset origin.
				// If we position a popper on top of a reference element, we can set
				// `x` to `top` to make the popper grow towards its top instead of
				// its bottom.

				var left = void 0,
					top = void 0;

				if (sideA === 'bottom') {
					// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
					// and not the bottom of the html element
					if (offsetParent.nodeName === 'HTML') {
						top = -offsetParent.clientHeight + offsets.bottom;
					} else {
						top = -offsetParentRect.height + offsets.bottom;
					}
				} else {
					top = offsets.top;
				}

				if (sideB === 'right') {
					if (offsetParent.nodeName === 'HTML') {
						left = -offsetParent.clientWidth + offsets.right;
					} else {
						left = -offsetParentRect.width + offsets.right;
					}
				} else {
					left = offsets.left;
				}

				if (gpuAcceleration && prefixedProperty) {
					styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
					styles[sideA] = 0;
					styles[sideB] = 0;
					styles.willChange = 'transform';
				} else {
					// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
					var invertTop = sideA === 'bottom' ? -1 : 1;
					var invertLeft = sideB === 'right' ? -1 : 1;
					styles[sideA] = top * invertTop;
					styles[sideB] = left * invertLeft;
					styles.willChange = sideA + ', ' + sideB;
				} // Attributes


				var attributes = {
					'x-placement': data.placement
				}; // Update `data` attributes, styles and arrowStyles

				data.attributes = _extends({}, attributes, data.attributes);
				data.styles = _extends({}, styles, data.styles);
				data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
				return data;
			}

			/**
			 * Helper used to know if the given modifier depends from another one.<br />
			 * It checks if the needed modifier is listed and enabled.
			 * @method
			 * @memberof Popper.Utils
			 * @param {Array} modifiers - list of modifiers
			 * @param {String} requestingName - name of requesting modifier
			 * @param {String} requestedName - name of requested modifier
			 * @returns {Boolean}
			 */


			function isModifierRequired(modifiers, requestingName, requestedName) {
				var requesting = find(modifiers, function (_ref) {
					var name = _ref.name;
					return name === requestingName;
				});
				var isRequired = !!requesting && modifiers.some(function (modifier) {
					return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
				});

				if (!isRequired) {
					var _requesting = '`' + requestingName + '`';

					var requested = '`' + requestedName + '`';
					console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
				}

				return isRequired;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function arrow(data, options) {
				var _data$offsets$arrow; // arrow depends on keepTogether in order to work


				if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
					return data;
				}

				var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

				if (typeof arrowElement === 'string') {
					arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

					if (!arrowElement) {
						return data;
					}
				} else {
					// if the arrowElement isn't a query selector we must check that the
					// provided DOM node is child of its popper node
					if (!data.instance.popper.contains(arrowElement)) {
						console.warn('WARNING: `arrow.element` must be child of its popper element!');
						return data;
					}
				}

				var placement = data.placement.split('-')[0];
				var _data$offsets = data.offsets,
					popper = _data$offsets.popper,
					reference = _data$offsets.reference;
				var isVertical = ['left', 'right'].indexOf(placement) !== -1;
				var len = isVertical ? 'height' : 'width';
				var sideCapitalized = isVertical ? 'Top' : 'Left';
				var side = sideCapitalized.toLowerCase();
				var altSide = isVertical ? 'left' : 'top';
				var opSide = isVertical ? 'bottom' : 'right';
				var arrowElementSize = getOuterSizes(arrowElement)[len]; //
				// extends keepTogether behavior making sure the popper and its
				// reference have enough pixels in conjunction
				//
				// top/left side

				if (reference[opSide] - arrowElementSize < popper[side]) {
					data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
				} // bottom/right side


				if (reference[side] + arrowElementSize > popper[opSide]) {
					data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
				}

				data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

				var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
				// take popper margin in account because we don't have this info available

				var css = getStyleComputedProperty(data.instance.popper);
				var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
				var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
				var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

				sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
				data.arrowElement = arrowElement;
				data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
				return data;
			}

			/**
			 * Get the opposite placement variation of the given one
			 * @method
			 * @memberof Popper.Utils
			 * @argument {String} placement variation
			 * @returns {String} flipped placement variation
			 */


			function getOppositeVariation(variation) {
				if (variation === 'end') {
					return 'start';
				} else if (variation === 'start') {
					return 'end';
				}

				return variation;
			}

			/**
			 * List of accepted placements to use as values of the `placement` option.<br />
			 * Valid placements are:
			 * - `auto`
			 * - `top`
			 * - `right`
			 * - `bottom`
			 * - `left`
			 *
			 * Each placement can have a variation from this list:
			 * - `-start`
			 * - `-end`
			 *
			 * Variations are interpreted easily if you think of them as the left to right
			 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
			 * is right.<br />
			 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
			 *
			 * Some valid examples are:
			 * - `top-end` (on top of reference, right aligned)
			 * - `right-start` (on right of reference, top aligned)
			 * - `bottom` (on bottom, centered)
			 * - `auto-end` (on the side with more space available, alignment depends by placement)
			 *
			 * @static
			 * @type {Array}
			 * @enum {String}
			 * @readonly
			 * @method placements
			 * @memberof Popper
			 */


			var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

			var validPlacements = placements.slice(3);

			/**
			 * Given an initial placement, returns all the subsequent placements
			 * clockwise (or counter-clockwise).
			 *
			 * @method
			 * @memberof Popper.Utils
			 * @argument {String} placement - A valid placement (it accepts variations)
			 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
			 * @returns {Array} placements including their variations
			 */

			function clockwise(placement) {
				var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
				var index = validPlacements.indexOf(placement);
				var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
				return counter ? arr.reverse() : arr;
			}

			var BEHAVIORS = {
				FLIP: 'flip',
				CLOCKWISE: 'clockwise',
				COUNTERCLOCKWISE: 'counterclockwise'
			};

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */

			function flip(data, options) {
				// if `inner` modifier is enabled, we can't use the `flip` modifier
				if (isModifierEnabled(data.instance.modifiers, 'inner')) {
					return data;
				}

				if (data.flipped && data.placement === data.originalPlacement) {
					// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
					return data;
				}

				var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
				var placement = data.placement.split('-')[0];
				var placementOpposite = getOppositePlacement(placement);
				var variation = data.placement.split('-')[1] || '';
				var flipOrder = [];

				switch (options.behavior) {
					case BEHAVIORS.FLIP:
						flipOrder = [placement, placementOpposite];
						break;

					case BEHAVIORS.CLOCKWISE:
						flipOrder = clockwise(placement);
						break;

					case BEHAVIORS.COUNTERCLOCKWISE:
						flipOrder = clockwise(placement, true);
						break;

					default:
						flipOrder = options.behavior;
				}

				flipOrder.forEach(function (step, index) {
					if (placement !== step || flipOrder.length === index + 1) {
						return data;
					}

					placement = data.placement.split('-')[0];
					placementOpposite = getOppositePlacement(placement);
					var popperOffsets = data.offsets.popper;
					var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

					var floor = Math.floor;
					var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
					var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
					var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
					var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
					var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
					var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

					var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

					var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

					var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
					var flippedVariation = flippedVariationByRef || flippedVariationByContent;

					if (overlapsRef || overflowsBoundaries || flippedVariation) {
						// this boolean to detect any flip loop
						data.flipped = true;

						if (overlapsRef || overflowsBoundaries) {
							placement = flipOrder[index + 1];
						}

						if (flippedVariation) {
							variation = getOppositeVariation(variation);
						}

						data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
						// any additional property we may add in the future

						data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
						data = runModifiers(data.instance.modifiers, data, 'flip');
					}
				});
				return data;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function keepTogether(data) {
				var _data$offsets = data.offsets,
					popper = _data$offsets.popper,
					reference = _data$offsets.reference;
				var placement = data.placement.split('-')[0];
				var floor = Math.floor;
				var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
				var side = isVertical ? 'right' : 'bottom';
				var opSide = isVertical ? 'left' : 'top';
				var measurement = isVertical ? 'width' : 'height';

				if (popper[side] < floor(reference[opSide])) {
					data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
				}

				if (popper[opSide] > floor(reference[side])) {
					data.offsets.popper[opSide] = floor(reference[side]);
				}

				return data;
			}

			/**
			 * Converts a string containing value + unit into a px value number
			 * @function
			 * @memberof {modifiers~offset}
			 * @private
			 * @argument {String} str - Value + unit string
			 * @argument {String} measurement - `height` or `width`
			 * @argument {Object} popperOffsets
			 * @argument {Object} referenceOffsets
			 * @returns {Number|String}
			 * Value in pixels, or original string if no values were extracted
			 */


			function toValue(str, measurement, popperOffsets, referenceOffsets) {
				// separate value from unit
				var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
				var value = +split[1];
				var unit = split[2]; // If it's not a number it's an operator, I guess

				if (!value) {
					return str;
				}

				if (unit.indexOf('%') === 0) {
					var element = void 0;

					switch (unit) {
						case '%p':
							element = popperOffsets;
							break;

						case '%':
						case '%r':
						default:
							element = referenceOffsets;
					}

					var rect = getClientRect(element);
					return rect[measurement] / 100 * value;
				} else if (unit === 'vh' || unit === 'vw') {
					// if is a vh or vw, we calculate the size based on the viewport
					var size = void 0;

					if (unit === 'vh') {
						size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
					} else {
						size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
					}

					return size / 100 * value;
				} else {
					// if is an explicit pixel unit, we get rid of the unit and keep the value
					// if is an implicit unit, it's px, and we return just the value
					return value;
				}
			}

			/**
			 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
			 * @function
			 * @memberof {modifiers~offset}
			 * @private
			 * @argument {String} offset
			 * @argument {Object} popperOffsets
			 * @argument {Object} referenceOffsets
			 * @argument {String} basePlacement
			 * @returns {Array} a two cells array with x and y offsets in numbers
			 */


			function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
				var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
				// in this way the first offset will use an axis and the second one
				// will use the other one

				var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
				// The regex addresses values with the plus or minus sign in front (+10, -20, etc)

				var fragments = offset.split(/(\+|\-)/).map(function (frag) {
					return frag.trim();
				}); // Detect if the offset string contains a pair of values or a single one
				// they could be separated by comma or space

				var divider = fragments.indexOf(find(fragments, function (frag) {
					return frag.search(/,|\s/) !== -1;
				}));

				if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
					console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
				} // If divider is found, we divide the list of values and operands to divide
				// them by ofset X and Y.


				var splitRegex = /\s*,\s*|\s+/;
				var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

				ops = ops.map(function (op, index) {
					// Most of the units rely on the orientation of the popper
					var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
					var mergeWithPrevious = false;
					return op // This aggregates any `+` or `-` sign that aren't considered operators
						// e.g.: 10 + +5 => [10, +, +5]
						.reduce(function (a, b) {
							if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
								a[a.length - 1] = b;
								mergeWithPrevious = true;
								return a;
							} else if (mergeWithPrevious) {
								a[a.length - 1] += b;
								mergeWithPrevious = false;
								return a;
							} else {
								return a.concat(b);
							}
						}, []) // Here we convert the string values into number values (in px)
						.map(function (str) {
							return toValue(str, measurement, popperOffsets, referenceOffsets);
						});
				}); // Loop trough the offsets arrays and execute the operations

				ops.forEach(function (op, index) {
					op.forEach(function (frag, index2) {
						if (isNumeric(frag)) {
							offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
						}
					});
				});
				return offsets;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @argument {Number|String} options.offset=0
			 * The offset value as described in the modifier description
			 * @returns {Object} The data object, properly modified
			 */


			function offset(data, _ref) {
				var offset = _ref.offset;
				var placement = data.placement,
					_data$offsets = data.offsets,
					popper = _data$offsets.popper,
					reference = _data$offsets.reference;
				var basePlacement = placement.split('-')[0];
				var offsets = void 0;

				if (isNumeric(+offset)) {
					offsets = [+offset, 0];
				} else {
					offsets = parseOffset(offset, popper, reference, basePlacement);
				}

				if (basePlacement === 'left') {
					popper.top += offsets[0];
					popper.left -= offsets[1];
				} else if (basePlacement === 'right') {
					popper.top += offsets[0];
					popper.left += offsets[1];
				} else if (basePlacement === 'top') {
					popper.left += offsets[0];
					popper.top -= offsets[1];
				} else if (basePlacement === 'bottom') {
					popper.left += offsets[0];
					popper.top += offsets[1];
				}

				data.popper = popper;
				return data;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function preventOverflow(data, options) {
				var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
				// go one step up and use the next offsetParent as reference to
				// avoid to make this modifier completely useless and look like broken

				if (data.instance.reference === boundariesElement) {
					boundariesElement = getOffsetParent(boundariesElement);
				} // NOTE: DOM access here
				// resets the popper's position so that the document size can be calculated excluding
				// the size of the popper element itself


				var transformProp = getSupportedPropertyName('transform');
				var popperStyles = data.instance.popper.style; // assignment to help minification

				var top = popperStyles.top,
					left = popperStyles.left,
					transform = popperStyles[transformProp];
				popperStyles.top = '';
				popperStyles.left = '';
				popperStyles[transformProp] = '';
				var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
				// restores the original style properties after the offsets have been computed

				popperStyles.top = top;
				popperStyles.left = left;
				popperStyles[transformProp] = transform;
				options.boundaries = boundaries;
				var order = options.priority;
				var popper = data.offsets.popper;
				var check = {
					primary: function primary(placement) {
						var value = popper[placement];

						if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
							value = Math.max(popper[placement], boundaries[placement]);
						}

						return defineProperty({}, placement, value);
					},
					secondary: function secondary(placement) {
						var mainSide = placement === 'right' ? 'left' : 'top';
						var value = popper[mainSide];

						if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
							value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
						}

						return defineProperty({}, mainSide, value);
					}
				};
				order.forEach(function (placement) {
					var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
					popper = _extends({}, popper, check[side](placement));
				});
				data.offsets.popper = popper;
				return data;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function shift(data) {
				var placement = data.placement;
				var basePlacement = placement.split('-')[0];
				var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

				if (shiftvariation) {
					var _data$offsets = data.offsets,
						reference = _data$offsets.reference,
						popper = _data$offsets.popper;
					var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
					var side = isVertical ? 'left' : 'top';
					var measurement = isVertical ? 'width' : 'height';
					var shiftOffsets = {
						start: defineProperty({}, side, reference[side]),
						end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
					};
					data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
				}

				return data;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by update method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function hide(data) {
				if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
					return data;
				}

				var refRect = data.offsets.reference;
				var bound = find(data.instance.modifiers, function (modifier) {
					return modifier.name === 'preventOverflow';
				}).boundaries;

				if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
					// Avoid unnecessary DOM access if visibility hasn't changed
					if (data.hide === true) {
						return data;
					}

					data.hide = true;
					data.attributes['x-out-of-boundaries'] = '';
				} else {
					// Avoid unnecessary DOM access if visibility hasn't changed
					if (data.hide === false) {
						return data;
					}

					data.hide = false;
					data.attributes['x-out-of-boundaries'] = false;
				}

				return data;
			}

			/**
			 * @function
			 * @memberof Modifiers
			 * @argument {Object} data - The data object generated by `update` method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {Object} The data object, properly modified
			 */


			function inner(data) {
				var placement = data.placement;
				var basePlacement = placement.split('-')[0];
				var _data$offsets = data.offsets,
					popper = _data$offsets.popper,
					reference = _data$offsets.reference;
				var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
				var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
				popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
				data.placement = getOppositePlacement(placement);
				data.offsets.popper = getClientRect(popper);
				return data;
			}

			/**
			 * Modifier function, each modifier can have a function of this type assigned
			 * to its `fn` property.<br />
			 * These functions will be called on each update, this means that you must
			 * make sure they are performant enough to avoid performance bottlenecks.
			 *
			 * @function ModifierFn
			 * @argument {dataObject} data - The data object generated by `update` method
			 * @argument {Object} options - Modifiers configuration and options
			 * @returns {dataObject} The data object, properly modified
			 */

			/**
			 * Modifiers are plugins used to alter the behavior of your poppers.<br />
			 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
			 * needed by the library.
			 *
			 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
			 * All the other properties are configurations that could be tweaked.
			 * @namespace modifiers
			 */


			var modifiers = {
				/**
				 * Modifier used to shift the popper on the start or end of its reference
				 * element.<br />
				 * It will read the variation of the `placement` property.<br />
				 * It can be one either `-end` or `-start`.
				 * @memberof modifiers
				 * @inner
				 */
				shift: {
					/** @prop {number} order=100 - Index used to define the order of execution */
					order: 100,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: shift
				},

				/**
				 * The `offset` modifier can shift your popper on both its axis.
				 *
				 * It accepts the following units:
				 * - `px` or unit-less, interpreted as pixels
				 * - `%` or `%r`, percentage relative to the length of the reference element
				 * - `%p`, percentage relative to the length of the popper element
				 * - `vw`, CSS viewport width unit
				 * - `vh`, CSS viewport height unit
				 *
				 * For length is intended the main axis relative to the placement of the popper.<br />
				 * This means that if the placement is `top` or `bottom`, the length will be the
				 * `width`. In case of `left` or `right`, it will be the `height`.
				 *
				 * You can provide a single value (as `Number` or `String`), or a pair of values
				 * as `String` divided by a comma or one (or more) white spaces.<br />
				 * The latter is a deprecated method because it leads to confusion and will be
				 * removed in v2.<br />
				 * Additionally, it accepts additions and subtractions between different units.
				 * Note that multiplications and divisions aren't supported.
				 *
				 * Valid examples are:
				 * ```
				 * 10
				 * '10%'
				 * '10, 10'
				 * '10%, 10'
				 * '10 + 10%'
				 * '10 - 5vh + 3%'
				 * '-10px + 5vh, 5px - 6%'
				 * ```
				 * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
				 * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
				 * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
				 *
				 * @memberof modifiers
				 * @inner
				 */
				offset: {
					/** @prop {number} order=200 - Index used to define the order of execution */
					order: 200,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: offset,

					/** @prop {Number|String} offset=0
					 * The offset value as described in the modifier description
					 */
					offset: 0
				},

				/**
				 * Modifier used to prevent the popper from being positioned outside the boundary.
				 *
				 * A scenario exists where the reference itself is not within the boundaries.<br />
				 * We can say it has "escaped the boundaries"  or just "escaped".<br />
				 * In this case we need to decide whether the popper should either:
				 *
				 * - detach from the reference and remain "trapped" in the boundaries, or
				 * - if it should ignore the boundary and "escape with its reference"
				 *
				 * When `escapeWithReference` is set to`true` and reference is completely
				 * outside its boundaries, the popper will overflow (or completely leave)
				 * the boundaries in order to remain attached to the edge of the reference.
				 *
				 * @memberof modifiers
				 * @inner
				 */
				preventOverflow: {
					/** @prop {number} order=300 - Index used to define the order of execution */
					order: 300,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: preventOverflow,

					/**
					 * @prop {Array} [priority=['left','right','top','bottom']]
					 * Popper will try to prevent overflow following these priorities by default,
					 * then, it could overflow on the left and on top of the `boundariesElement`
					 */
					priority: ['left', 'right', 'top', 'bottom'],

					/**
					 * @prop {number} padding=5
					 * Amount of pixel used to define a minimum distance between the boundaries
					 * and the popper. This makes sure the popper always has a little padding
					 * between the edges of its container
					 */
					padding: 5,

					/**
					 * @prop {String|HTMLElement} boundariesElement='scrollParent'
					 * Boundaries used by the modifier. Can be `scrollParent`, `window`,
					 * `viewport` or any DOM element.
					 */
					boundariesElement: 'scrollParent'
				},

				/**
				 * Modifier used to make sure the reference and its popper stay near each other
				 * without leaving any gap between the two. Especially useful when the arrow is
				 * enabled and you want to ensure that it points to its reference element.
				 * It cares only about the first axis. You can still have poppers with margin
				 * between the popper and its reference element.
				 * @memberof modifiers
				 * @inner
				 */
				keepTogether: {
					/** @prop {number} order=400 - Index used to define the order of execution */
					order: 400,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: keepTogether
				},

				/**
				 * This modifier is used to move the `arrowElement` of the popper to make
				 * sure it is positioned between the reference element and its popper element.
				 * It will read the outer size of the `arrowElement` node to detect how many
				 * pixels of conjunction are needed.
				 *
				 * It has no effect if no `arrowElement` is provided.
				 * @memberof modifiers
				 * @inner
				 */
				arrow: {
					/** @prop {number} order=500 - Index used to define the order of execution */
					order: 500,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: arrow,

					/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
					element: '[x-arrow]'
				},

				/**
				 * Modifier used to flip the popper's placement when it starts to overlap its
				 * reference element.
				 *
				 * Requires the `preventOverflow` modifier before it in order to work.
				 *
				 * **NOTE:** this modifier will interrupt the current update cycle and will
				 * restart it if it detects the need to flip the placement.
				 * @memberof modifiers
				 * @inner
				 */
				flip: {
					/** @prop {number} order=600 - Index used to define the order of execution */
					order: 600,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: flip,

					/**
					 * @prop {String|Array} behavior='flip'
					 * The behavior used to change the popper's placement. It can be one of
					 * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
					 * placements (with optional variations)
					 */
					behavior: 'flip',

					/**
					 * @prop {number} padding=5
					 * The popper will flip if it hits the edges of the `boundariesElement`
					 */
					padding: 5,

					/**
					 * @prop {String|HTMLElement} boundariesElement='viewport'
					 * The element which will define the boundaries of the popper position.
					 * The popper will never be placed outside of the defined boundaries
					 * (except if `keepTogether` is enabled)
					 */
					boundariesElement: 'viewport',

					/**
					 * @prop {Boolean} flipVariations=false
					 * The popper will switch placement variation between `-start` and `-end` when
					 * the reference element overlaps its boundaries.
					 *
					 * The original placement should have a set variation.
					 */
					flipVariations: false,

					/**
					 * @prop {Boolean} flipVariationsByContent=false
					 * The popper will switch placement variation between `-start` and `-end` when
					 * the popper element overlaps its reference boundaries.
					 *
					 * The original placement should have a set variation.
					 */
					flipVariationsByContent: false
				},

				/**
				 * Modifier used to make the popper flow toward the inner of the reference element.
				 * By default, when this modifier is disabled, the popper will be placed outside
				 * the reference element.
				 * @memberof modifiers
				 * @inner
				 */
				inner: {
					/** @prop {number} order=700 - Index used to define the order of execution */
					order: 700,

					/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
					enabled: false,

					/** @prop {ModifierFn} */
					fn: inner
				},

				/**
				 * Modifier used to hide the popper when its reference element is outside of the
				 * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
				 * be used to hide with a CSS selector the popper when its reference is
				 * out of boundaries.
				 *
				 * Requires the `preventOverflow` modifier before it in order to work.
				 * @memberof modifiers
				 * @inner
				 */
				hide: {
					/** @prop {number} order=800 - Index used to define the order of execution */
					order: 800,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: hide
				},

				/**
				 * Computes the style that will be applied to the popper element to gets
				 * properly positioned.
				 *
				 * Note that this modifier will not touch the DOM, it just prepares the styles
				 * so that `applyStyle` modifier can apply it. This separation is useful
				 * in case you need to replace `applyStyle` with a custom implementation.
				 *
				 * This modifier has `850` as `order` value to maintain backward compatibility
				 * with previous versions of Popper.js. Expect the modifiers ordering method
				 * to change in future major versions of the library.
				 *
				 * @memberof modifiers
				 * @inner
				 */
				computeStyle: {
					/** @prop {number} order=850 - Index used to define the order of execution */
					order: 850,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: computeStyle,

					/**
					 * @prop {Boolean} gpuAcceleration=true
					 * If true, it uses the CSS 3D transformation to position the popper.
					 * Otherwise, it will use the `top` and `left` properties
					 */
					gpuAcceleration: true,

					/**
					 * @prop {string} [x='bottom']
					 * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
					 * Change this if your popper should grow in a direction different from `bottom`
					 */
					x: 'bottom',

					/**
					 * @prop {string} [x='left']
					 * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
					 * Change this if your popper should grow in a direction different from `right`
					 */
					y: 'right'
				},

				/**
				 * Applies the computed styles to the popper element.
				 *
				 * All the DOM manipulations are limited to this modifier. This is useful in case
				 * you want to integrate Popper.js inside a framework or view library and you
				 * want to delegate all the DOM manipulations to it.
				 *
				 * Note that if you disable this modifier, you must make sure the popper element
				 * has its position set to `absolute` before Popper.js can do its work!
				 *
				 * Just disable this modifier and define your own to achieve the desired effect.
				 *
				 * @memberof modifiers
				 * @inner
				 */
				applyStyle: {
					/** @prop {number} order=900 - Index used to define the order of execution */
					order: 900,

					/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
					enabled: true,

					/** @prop {ModifierFn} */
					fn: applyStyle,

					/** @prop {Function} */
					onLoad: applyStyleOnLoad,

					/**
					 * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
					 * @prop {Boolean} gpuAcceleration=true
					 * If true, it uses the CSS 3D transformation to position the popper.
					 * Otherwise, it will use the `top` and `left` properties
					 */
					gpuAcceleration: undefined
				}
			};
			/**
			 * The `dataObject` is an object containing all the information used by Popper.js.
			 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
			 * @name dataObject
			 * @property {Object} data.instance The Popper.js instance
			 * @property {String} data.placement Placement applied to popper
			 * @property {String} data.originalPlacement Placement originally defined on init
			 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
			 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
			 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
			 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
			 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
			 * @property {Object} data.boundaries Offsets of the popper boundaries
			 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
			 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
			 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
			 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
			 */

			/**
			 * Default options provided to Popper.js constructor.<br />
			 * These can be overridden using the `options` argument of Popper.js.<br />
			 * To override an option, simply pass an object with the same
			 * structure of the `options` object, as the 3rd argument. For example:
			 * ```
			 * new Popper(ref, pop, {
			 *   modifiers: {
			 *     preventOverflow: { enabled: false }
			 *   }
			 * })
			 * ```
			 * @type {Object}
			 * @static
			 * @memberof Popper
			 */

			var Defaults = {
				/**
				 * Popper's placement.
				 * @prop {Popper.placements} placement='bottom'
				 */
				placement: 'bottom',

				/**
				 * Set this to true if you want popper to position it self in 'fixed' mode
				 * @prop {Boolean} positionFixed=false
				 */
				positionFixed: false,

				/**
				 * Whether events (resize, scroll) are initially enabled.
				 * @prop {Boolean} eventsEnabled=true
				 */
				eventsEnabled: true,

				/**
				 * Set to true if you want to automatically remove the popper when
				 * you call the `destroy` method.
				 * @prop {Boolean} removeOnDestroy=false
				 */
				removeOnDestroy: false,

				/**
				 * Callback called when the popper is created.<br />
				 * By default, it is set to no-op.<br />
				 * Access Popper.js instance with `data.instance`.
				 * @prop {onCreate}
				 */
				onCreate: function onCreate() {
				},

				/**
				 * Callback called when the popper is updated. This callback is not called
				 * on the initialization/creation of the popper, but only on subsequent
				 * updates.<br />
				 * By default, it is set to no-op.<br />
				 * Access Popper.js instance with `data.instance`.
				 * @prop {onUpdate}
				 */
				onUpdate: function onUpdate() {
				},

				/**
				 * List of modifiers used to modify the offsets before they are applied to the popper.
				 * They provide most of the functionalities of Popper.js.
				 * @prop {modifiers}
				 */
				modifiers: modifiers
			};
			/**
			 * @callback onCreate
			 * @param {dataObject} data
			 */

			/**
			 * @callback onUpdate
			 * @param {dataObject} data
			 */
// Utils
// Methods

			var Popper = function () {
				/**
				 * Creates a new Popper.js instance.
				 * @class Popper
				 * @param {Element|referenceObject} reference - The reference element used to position the popper
				 * @param {Element} popper - The HTML / XML element used as the popper
				 * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
				 * @return {Object} instance - The generated Popper.js instance
				 */
				function Popper(reference, popper) {
					var _this = this;

					var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
					classCallCheck(this, Popper);

					this.scheduleUpdate = function () {
						return requestAnimationFrame(_this.update);
					}; // make update() debounced, so that it only runs at most once-per-tick


					this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

					this.options = _extends({}, Popper.Defaults, options); // init state

					this.state = {
						isDestroyed: false,
						isCreated: false,
						scrollParents: []
					}; // get reference and popper elements (allow jQuery wrappers)

					this.reference = reference && reference.jquery ? reference[0] : reference;
					this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

					this.options.modifiers = {};
					Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
						_this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
					}); // Refactoring modifiers' list (Object => Array)

					this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
						return _extends({
							name: name
						}, _this.options.modifiers[name]);
					}) // sort the modifiers by order
						.sort(function (a, b) {
							return a.order - b.order;
						}); // modifiers have the ability to execute arbitrary code when Popper.js get inited
					// such code is executed in the same order of its modifier
					// they could add new properties to their options configuration
					// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

					this.modifiers.forEach(function (modifierOptions) {
						if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
							modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
						}
					}); // fire the first update to position the popper in the right place

					this.update();
					var eventsEnabled = this.options.eventsEnabled;

					if (eventsEnabled) {
						// setup event listeners, they will take care of update the position in specific situations
						this.enableEventListeners();
					}

					this.state.eventsEnabled = eventsEnabled;
				} // We can't use class properties because they don't get listed in the
				// class prototype and break stuff like Sinon stubs


				createClass(Popper, [{
					key: 'update',
					value: function update$$1() {
						return update.call(this);
					}
				}, {
					key: 'destroy',
					value: function destroy$$1() {
						return destroy.call(this);
					}
				}, {
					key: 'enableEventListeners',
					value: function enableEventListeners$$1() {
						return enableEventListeners.call(this);
					}
				}, {
					key: 'disableEventListeners',
					value: function disableEventListeners$$1() {
						return disableEventListeners.call(this);
					}
					/**
					 * Schedules an update. It will run on the next UI update available.
					 * @method scheduleUpdate
					 * @memberof Popper
					 */

					/**
					 * Collection of utilities useful when writing custom modifiers.
					 * Starting from version 1.7, this method is available only if you
					 * include `popper-utils.js` before `popper.js`.
					 *
					 * **DEPRECATION**: This way to access PopperUtils is deprecated
					 * and will be removed in v2! Use the PopperUtils module directly instead.
					 * Due to the high instability of the methods contained in Utils, we can't
					 * guarantee them to follow semver. Use them at your own risk!
					 * @static
					 * @private
					 * @type {Object}
					 * @deprecated since version 1.8
					 * @member Utils
					 * @memberof Popper
					 */

				}]);
				return Popper;
			}();
			/**
			 * The `referenceObject` is an object that provides an interface compatible with Popper.js
			 * and lets you use it as replacement of a real DOM node.<br />
			 * You can use this method to position a popper relatively to a set of coordinates
			 * in case you don't have a DOM node to use as reference.
			 *
			 * ```
			 * new Popper(referenceObject, popperNode);
			 * ```
			 *
			 * NB: This feature isn't supported in Internet Explorer 10.
			 * @name referenceObject
			 * @property {Function} data.getBoundingClientRect
			 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
			 * @property {number} data.clientWidth
			 * An ES6 getter that will return the width of the virtual reference element.
			 * @property {number} data.clientHeight
			 * An ES6 getter that will return the height of the virtual reference element.
			 */


			Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
			Popper.placements = placements;
			Popper.Defaults = Defaults;
			/* harmony default export */
			__webpack_exports__["default"] = (Popper);
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(8)))

		/***/
	}),
	/* 5 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		__webpack_require__.r(__webpack_exports__);
		/* harmony import */
		var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
		/* harmony import */
		var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
		/* harmony import */
		var jquery_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
		/* harmony import */
		var jquery_ui__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui__WEBPACK_IMPORTED_MODULE_1__);
		/* harmony import */
		var bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
		/* harmony import */
		var bootstrap__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bootstrap__WEBPACK_IMPORTED_MODULE_2__);
		/* harmony import */
		var slick_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
		/* harmony import */
		var slick_carousel__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(slick_carousel__WEBPACK_IMPORTED_MODULE_3__);
		/* harmony import */
		var _styles_styles_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
		/* harmony import */
		var _styles_styles_scss__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_styles_scss__WEBPACK_IMPORTED_MODULE_4__);
		/* harmony import */
		var bootstrap_datepicker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
		/* harmony import */
		var bootstrap_datepicker__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(bootstrap_datepicker__WEBPACK_IMPORTED_MODULE_5__);
		/* harmony import */
		var bootstrap_select__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
		/* harmony import */
		var bootstrap_select__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(bootstrap_select__WEBPACK_IMPORTED_MODULE_6__);
		/* harmony import */
		var lightgallery__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
		/* harmony import */
		var lightgallery__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lightgallery__WEBPACK_IMPORTED_MODULE_7__);
		/* harmony import */
		var lg_video__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(14);
		/* harmony import */
		var lg_video__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lg_video__WEBPACK_IMPORTED_MODULE_8__);
		/* harmony import */
		var _scripts_lightgallery__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15);
		/* harmony import */
		var _scripts_general__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(16);
		/* harmony import */
		var _scripts_collapse__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(17);
		/* harmony import */
		var _scripts_collapse__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_scripts_collapse__WEBPACK_IMPORTED_MODULE_11__);
		/* harmony import */
		var _scripts_slick__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(18);
		/* harmony import */
		var _scripts_slick__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_scripts_slick__WEBPACK_IMPORTED_MODULE_12__);
		/* harmony import */
		var _scripts_drag_drop_image__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(19);
		/* harmony import */
		var _scripts_drag_drop_image__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_scripts_drag_drop_image__WEBPACK_IMPORTED_MODULE_13__);
		/* harmony import */
		var _scripts_dropdown_open_checkout__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(20);
		/* harmony import */
		var _scripts_dropdown_open_checkout__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_scripts_dropdown_open_checkout__WEBPACK_IMPORTED_MODULE_14__);
		/* harmony import */
		var _scripts_checkout_item_remove_border__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(21);
		/* harmony import */
		var _scripts_checkout_item_remove_border__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_scripts_checkout_item_remove_border__WEBPACK_IMPORTED_MODULE_15__);
		/* harmony import */
		var _scripts_select_all_check_boxes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(22);
		/* harmony import */
		var _scripts_select_all_check_boxes__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_scripts_select_all_check_boxes__WEBPACK_IMPORTED_MODULE_16__);
		/* harmony import */
		var _scripts_sticky_card_checkout__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(23);
		/* harmony import */
		var _scripts_sticky_card_checkout__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_scripts_sticky_card_checkout__WEBPACK_IMPORTED_MODULE_17__);
		/* harmony import */
		var _scripts_modal__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(24);
		/* harmony import */
		var _scripts_modal__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_scripts_modal__WEBPACK_IMPORTED_MODULE_18__);
		/* harmony import */
		var _scripts_file_upload__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(25);
		/* harmony import */
		var _scripts_file_upload__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_scripts_file_upload__WEBPACK_IMPORTED_MODULE_19__);
		/* harmony import */
		var _scripts_login_slide__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(26);
		/* harmony import */
		var _scripts_login_slide__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_scripts_login_slide__WEBPACK_IMPORTED_MODULE_20__);
		/* harmony import */
		var _scripts_mobile_sticky_header__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(27);
		/* harmony import */
		var _scripts_mobile_sticky_header__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_scripts_mobile_sticky_header__WEBPACK_IMPORTED_MODULE_21__);
		/* harmony import */
		var _scripts_select_custom__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(28);
		/* harmony import */
		var _scripts_select_custom__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_scripts_select_custom__WEBPACK_IMPORTED_MODULE_22__);
		/* harmony import */
		var _scripts_input_auto_focus__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(29);
		/* harmony import */
		var _scripts_input_auto_focus__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_scripts_input_auto_focus__WEBPACK_IMPORTED_MODULE_23__);
		/* harmony import */
		var _scripts_iframe_load_wpage__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(30);
		/* harmony import */
		var _scripts_iframe_load_wpage__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_scripts_iframe_load_wpage__WEBPACK_IMPORTED_MODULE_24__);
		/* harmony import */
		var _scripts_datapicker__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(31);
		/* harmony import */
		var _scripts_datapicker__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_scripts_datapicker__WEBPACK_IMPORTED_MODULE_25__);
		/* harmony import */
		var _scripts_modal_snipped__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(33);
		/* harmony import */
		var _scripts_modal_snipped__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_scripts_modal_snipped__WEBPACK_IMPORTED_MODULE_26__);
		/* harmony import */
		var _scripts_product_details__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(34);
		/* harmony import */
		var _scripts_account__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(35);
		/* harmony import */
		var _scripts_about_us__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(36);
		/* harmony import */
		var _scripts_shopping_card_detached_elements__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(37);
		/* harmony import */
		var _scripts_shopping_card_detached_elements__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_scripts_shopping_card_detached_elements__WEBPACK_IMPORTED_MODULE_30__);
		/* harmony import */
		var _scripts_input_counter_with_buttons__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(38);
		/* harmony import */
		var _scripts_input_counter_with_buttons__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_scripts_input_counter_with_buttons__WEBPACK_IMPORTED_MODULE_31__);
		/* harmony import */
		var _scripts_modal_address__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(39);
		/* harmony import */
		var _scripts_modal_address__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(_scripts_modal_address__WEBPACK_IMPORTED_MODULE_32__);
		/* harmony import */
		var _scripts_collapse_custom__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(40);
		/* harmony import */
		var _scripts_collapse_custom__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(_scripts_collapse_custom__WEBPACK_IMPORTED_MODULE_33__);
		/* harmony import */
		var _scripts_diy__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(41);
		/* harmony import */
		var _scripts_showroom_detail_view__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(42);
		/* harmony import */
		var _scripts_we_design__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(43);
		/* harmony import */
		var _scripts_free_in_home_consult__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(44);


		// import 'lightbox2';


		// import 'jquery-freeze-table'


		// import './scripts/lightboxOptions'


		// import './scripts/table';

		/***/
	}),
	/* 6 */
	/***/ (function (module, exports) {

		module.exports = function (module) {
			if (!module.webpackPolyfill) {
				module.deprecate = function () {
				};

				module.paths = []; // module.parent = undefined by default

				if (!module.children) module.children = [];
				Object.defineProperty(module, "loaded", {
					enumerable: true,
					get: function get() {
						return module.l;
					}
				});
				Object.defineProperty(module, "id", {
					enumerable: true,
					get: function get() {
						return module.i;
					}
				});
				module.webpackPolyfill = 1;
			}

			return module;
		};

		/***/
	}),
	/* 7 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		(function (factory) {
			if (true) {
				// AMD. Register as an anonymous module.
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
						(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(function ($) {
			$.ui = $.ui || {};
			return $.ui.version = "1.12.1";
		});

		/***/
	}),
	/* 8 */
	/***/ (function (module, exports) {

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		var g; // This works in non-strict mode

		g = function () {
			return this;
		}();

		try {
			// This works if eval is allowed (see CSP)
			g = g || new Function("return this")();
		} catch (e) {
			// This works if the window reference is available
			if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
		} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


		module.exports = g;

		/***/
	}),
	/* 9 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */

		/* global window, document, define, jQuery, setInterval, clearInterval */
		;

		(function (factory) {
			'use strict';

			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
						(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(function ($) {
			'use strict';

			var Slick = window.Slick || {};

			Slick = function () {
				var instanceUid = 0;

				function Slick(element, settings) {
					var _ = this,
						dataSettings;

					_.defaults = {
						accessibility: true,
						adaptiveHeight: false,
						appendArrows: $(element),
						appendDots: $(element),
						arrows: true,
						asNavFor: null,
						prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
						nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
						autoplay: false,
						autoplaySpeed: 3000,
						centerMode: false,
						centerPadding: '50px',
						cssEase: 'ease',
						customPaging: function customPaging(slider, i) {
							return $('<button type="button" />').text(i + 1);
						},
						dots: false,
						dotsClass: 'slick-dots',
						draggable: true,
						easing: 'linear',
						edgeFriction: 0.35,
						fade: false,
						focusOnSelect: false,
						focusOnChange: false,
						infinite: true,
						initialSlide: 0,
						lazyLoad: 'ondemand',
						mobileFirst: false,
						pauseOnHover: true,
						pauseOnFocus: true,
						pauseOnDotsHover: false,
						respondTo: 'window',
						responsive: null,
						rows: 1,
						rtl: false,
						slide: '',
						slidesPerRow: 1,
						slidesToShow: 1,
						slidesToScroll: 1,
						speed: 500,
						swipe: true,
						swipeToSlide: false,
						touchMove: true,
						touchThreshold: 5,
						useCSS: true,
						useTransform: true,
						variableWidth: false,
						vertical: false,
						verticalSwiping: false,
						waitForAnimate: true,
						zIndex: 1000
					};
					_.initials = {
						animating: false,
						dragging: false,
						autoPlayTimer: null,
						currentDirection: 0,
						currentLeft: null,
						currentSlide: 0,
						direction: 1,
						$dots: null,
						listWidth: null,
						listHeight: null,
						loadIndex: 0,
						$nextArrow: null,
						$prevArrow: null,
						scrolling: false,
						slideCount: null,
						slideWidth: null,
						$slideTrack: null,
						$slides: null,
						sliding: false,
						slideOffset: 0,
						swipeLeft: null,
						swiping: false,
						$list: null,
						touchObject: {},
						transformsEnabled: false,
						unslicked: false
					};
					$.extend(_, _.initials);
					_.activeBreakpoint = null;
					_.animType = null;
					_.animProp = null;
					_.breakpoints = [];
					_.breakpointSettings = [];
					_.cssTransitions = false;
					_.focussed = false;
					_.interrupted = false;
					_.hidden = 'hidden';
					_.paused = true;
					_.positionProp = null;
					_.respondTo = null;
					_.rowCount = 1;
					_.shouldClick = true;
					_.$slider = $(element);
					_.$slidesCache = null;
					_.transformType = null;
					_.transitionType = null;
					_.visibilityChange = 'visibilitychange';
					_.windowWidth = 0;
					_.windowTimer = null;
					dataSettings = $(element).data('slick') || {};
					_.options = $.extend({}, _.defaults, settings, dataSettings);
					_.currentSlide = _.options.initialSlide;
					_.originalSettings = _.options;

					if (typeof document.mozHidden !== 'undefined') {
						_.hidden = 'mozHidden';
						_.visibilityChange = 'mozvisibilitychange';
					} else if (typeof document.webkitHidden !== 'undefined') {
						_.hidden = 'webkitHidden';
						_.visibilityChange = 'webkitvisibilitychange';
					}

					_.autoPlay = $.proxy(_.autoPlay, _);
					_.autoPlayClear = $.proxy(_.autoPlayClear, _);
					_.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
					_.changeSlide = $.proxy(_.changeSlide, _);
					_.clickHandler = $.proxy(_.clickHandler, _);
					_.selectHandler = $.proxy(_.selectHandler, _);
					_.setPosition = $.proxy(_.setPosition, _);
					_.swipeHandler = $.proxy(_.swipeHandler, _);
					_.dragHandler = $.proxy(_.dragHandler, _);
					_.keyHandler = $.proxy(_.keyHandler, _);
					_.instanceUid = instanceUid++; // A simple way to check for HTML strings
					// Strict HTML recognition (must start with <)
					// Extracted from jQuery v1.11 source

					_.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

					_.registerBreakpoints();

					_.init(true);
				}

				return Slick;
			}();

			Slick.prototype.activateADA = function () {
				var _ = this;

				_.$slideTrack.find('.slick-active').attr({
					'aria-hidden': 'false'
				}).find('a, input, button, select').attr({
					'tabindex': '0'
				});
			};

			Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {
				var _ = this;

				if (typeof index === 'boolean') {
					addBefore = index;
					index = null;
				} else if (index < 0 || index >= _.slideCount) {
					return false;
				}

				_.unload();

				if (typeof index === 'number') {
					if (index === 0 && _.$slides.length === 0) {
						$(markup).appendTo(_.$slideTrack);
					} else if (addBefore) {
						$(markup).insertBefore(_.$slides.eq(index));
					} else {
						$(markup).insertAfter(_.$slides.eq(index));
					}
				} else {
					if (addBefore === true) {
						$(markup).prependTo(_.$slideTrack);
					} else {
						$(markup).appendTo(_.$slideTrack);
					}
				}

				_.$slides = _.$slideTrack.children(this.options.slide);

				_.$slideTrack.children(this.options.slide).detach();

				_.$slideTrack.append(_.$slides);

				_.$slides.each(function (index, element) {
					$(element).attr('data-slick-index', index);
				});

				_.$slidesCache = _.$slides;

				_.reinit();
			};

			Slick.prototype.animateHeight = function () {
				var _ = this;

				if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
					var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);

					_.$list.animate({
						height: targetHeight
					}, _.options.speed);
				}
			};

			Slick.prototype.animateSlide = function (targetLeft, callback) {
				var animProps = {},
					_ = this;

				_.animateHeight();

				if (_.options.rtl === true && _.options.vertical === false) {
					targetLeft = -targetLeft;
				}

				if (_.transformsEnabled === false) {
					if (_.options.vertical === false) {
						_.$slideTrack.animate({
							left: targetLeft
						}, _.options.speed, _.options.easing, callback);
					} else {
						_.$slideTrack.animate({
							top: targetLeft
						}, _.options.speed, _.options.easing, callback);
					}
				} else {
					if (_.cssTransitions === false) {
						if (_.options.rtl === true) {
							_.currentLeft = -_.currentLeft;
						}

						$({
							animStart: _.currentLeft
						}).animate({
							animStart: targetLeft
						}, {
							duration: _.options.speed,
							easing: _.options.easing,
							step: function step(now) {
								now = Math.ceil(now);

								if (_.options.vertical === false) {
									animProps[_.animType] = 'translate(' + now + 'px, 0px)';

									_.$slideTrack.css(animProps);
								} else {
									animProps[_.animType] = 'translate(0px,' + now + 'px)';

									_.$slideTrack.css(animProps);
								}
							},
							complete: function complete() {
								if (callback) {
									callback.call();
								}
							}
						});
					} else {
						_.applyTransition();

						targetLeft = Math.ceil(targetLeft);

						if (_.options.vertical === false) {
							animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
						} else {
							animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
						}

						_.$slideTrack.css(animProps);

						if (callback) {
							setTimeout(function () {
								_.disableTransition();

								callback.call();
							}, _.options.speed);
						}
					}
				}
			};

			Slick.prototype.getNavTarget = function () {
				var _ = this,
					asNavFor = _.options.asNavFor;

				if (asNavFor && asNavFor !== null) {
					asNavFor = $(asNavFor).not(_.$slider);
				}

				return asNavFor;
			};

			Slick.prototype.asNavFor = function (index) {
				var _ = this,
					asNavFor = _.getNavTarget();

				if (asNavFor !== null && _typeof(asNavFor) === 'object') {
					asNavFor.each(function () {
						var target = $(this).slick('getSlick');

						if (!target.unslicked) {
							target.slideHandler(index, true);
						}
					});
				}
			};

			Slick.prototype.applyTransition = function (slide) {
				var _ = this,
					transition = {};

				if (_.options.fade === false) {
					transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
				} else {
					transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
				}

				if (_.options.fade === false) {
					_.$slideTrack.css(transition);
				} else {
					_.$slides.eq(slide).css(transition);
				}
			};

			Slick.prototype.autoPlay = function () {
				var _ = this;

				_.autoPlayClear();

				if (_.slideCount > _.options.slidesToShow) {
					_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
				}
			};

			Slick.prototype.autoPlayClear = function () {
				var _ = this;

				if (_.autoPlayTimer) {
					clearInterval(_.autoPlayTimer);
				}
			};

			Slick.prototype.autoPlayIterator = function () {
				var _ = this,
					slideTo = _.currentSlide + _.options.slidesToScroll;

				if (!_.paused && !_.interrupted && !_.focussed) {
					if (_.options.infinite === false) {
						if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
							_.direction = 0;
						} else if (_.direction === 0) {
							slideTo = _.currentSlide - _.options.slidesToScroll;

							if (_.currentSlide - 1 === 0) {
								_.direction = 1;
							}
						}
					}

					_.slideHandler(slideTo);
				}
			};

			Slick.prototype.buildArrows = function () {
				var _ = this;

				if (_.options.arrows === true) {
					_.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
					_.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

					if (_.slideCount > _.options.slidesToShow) {
						_.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

						_.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

						if (_.htmlExpr.test(_.options.prevArrow)) {
							_.$prevArrow.prependTo(_.options.appendArrows);
						}

						if (_.htmlExpr.test(_.options.nextArrow)) {
							_.$nextArrow.appendTo(_.options.appendArrows);
						}

						if (_.options.infinite !== true) {
							_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
						}
					} else {
						_.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
							'aria-disabled': 'true',
							'tabindex': '-1'
						});
					}
				}
			};

			Slick.prototype.buildDots = function () {
				var _ = this,
					i,
					dot;

				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$slider.addClass('slick-dotted');

					dot = $('<ul />').addClass(_.options.dotsClass);

					for (i = 0; i <= _.getDotCount(); i += 1) {
						dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
					}

					_.$dots = dot.appendTo(_.options.appendDots);

					_.$dots.find('li').first().addClass('slick-active');
				}
			};

			Slick.prototype.buildOut = function () {
				var _ = this;

				_.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');
				_.slideCount = _.$slides.length;

				_.$slides.each(function (index, element) {
					$(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
				});

				_.$slider.addClass('slick-slider');

				_.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
				_.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();

				_.$slideTrack.css('opacity', 0);

				if (_.options.centerMode === true || _.options.swipeToSlide === true) {
					_.options.slidesToScroll = 1;
				}

				$('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

				_.setupInfinite();

				_.buildArrows();

				_.buildDots();

				_.updateDots();

				_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

				if (_.options.draggable === true) {
					_.$list.addClass('draggable');
				}
			};

			Slick.prototype.buildRows = function () {
				var _ = this,
					a,
					b,
					c,
					newSlides,
					numOfSlides,
					originalSlides,
					slidesPerSection;

				newSlides = document.createDocumentFragment();
				originalSlides = _.$slider.children();

				if (_.options.rows > 0) {
					slidesPerSection = _.options.slidesPerRow * _.options.rows;
					numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

					for (a = 0; a < numOfSlides; a++) {
						var slide = document.createElement('div');

						for (b = 0; b < _.options.rows; b++) {
							var row = document.createElement('div');

							for (c = 0; c < _.options.slidesPerRow; c++) {
								var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);

								if (originalSlides.get(target)) {
									row.appendChild(originalSlides.get(target));
								}
							}

							slide.appendChild(row);
						}

						newSlides.appendChild(slide);
					}

					_.$slider.empty().append(newSlides);

					_.$slider.children().children().children().css({
						'width': 100 / _.options.slidesPerRow + '%',
						'display': 'inline-block'
					});
				}
			};

			Slick.prototype.checkResponsive = function (initial, forceUpdate) {
				var _ = this,
					breakpoint,
					targetBreakpoint,
					respondToWidth,
					triggerBreakpoint = false;

				var sliderWidth = _.$slider.width();

				var windowWidth = window.innerWidth || $(window).width();

				if (_.respondTo === 'window') {
					respondToWidth = windowWidth;
				} else if (_.respondTo === 'slider') {
					respondToWidth = sliderWidth;
				} else if (_.respondTo === 'min') {
					respondToWidth = Math.min(windowWidth, sliderWidth);
				}

				if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {
					targetBreakpoint = null;

					for (breakpoint in _.breakpoints) {
						if (_.breakpoints.hasOwnProperty(breakpoint)) {
							if (_.originalSettings.mobileFirst === false) {
								if (respondToWidth < _.breakpoints[breakpoint]) {
									targetBreakpoint = _.breakpoints[breakpoint];
								}
							} else {
								if (respondToWidth > _.breakpoints[breakpoint]) {
									targetBreakpoint = _.breakpoints[breakpoint];
								}
							}
						}
					}

					if (targetBreakpoint !== null) {
						if (_.activeBreakpoint !== null) {
							if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
								_.activeBreakpoint = targetBreakpoint;

								if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
									_.unslick(targetBreakpoint);
								} else {
									_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);

									if (initial === true) {
										_.currentSlide = _.options.initialSlide;
									}

									_.refresh(initial);
								}

								triggerBreakpoint = targetBreakpoint;
							}
						} else {
							_.activeBreakpoint = targetBreakpoint;

							if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
								_.unslick(targetBreakpoint);
							} else {
								_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);

								if (initial === true) {
									_.currentSlide = _.options.initialSlide;
								}

								_.refresh(initial);
							}

							triggerBreakpoint = targetBreakpoint;
						}
					} else {
						if (_.activeBreakpoint !== null) {
							_.activeBreakpoint = null;
							_.options = _.originalSettings;

							if (initial === true) {
								_.currentSlide = _.options.initialSlide;
							}

							_.refresh(initial);

							triggerBreakpoint = targetBreakpoint;
						}
					} // only trigger breakpoints during an actual break. not on initialize.


					if (!initial && triggerBreakpoint !== false) {
						_.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
					}
				}
			};

			Slick.prototype.changeSlide = function (event, dontAnimate) {
				var _ = this,
					$target = $(event.currentTarget),
					indexOffset,
					slideOffset,
					unevenOffset; // If target is a link, prevent default action.


				if ($target.is('a')) {
					event.preventDefault();
				} // If target is not the <li> element (ie: a child), find the <li>.


				if (!$target.is('li')) {
					$target = $target.closest('li');
				}

				unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
				indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

				switch (event.data.message) {
					case 'previous':
						slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;

						if (_.slideCount > _.options.slidesToShow) {
							_.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
						}

						break;

					case 'next':
						slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;

						if (_.slideCount > _.options.slidesToShow) {
							_.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
						}

						break;

					case 'index':
						var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

						_.slideHandler(_.checkNavigable(index), false, dontAnimate);

						$target.children().trigger('focus');
						break;

					default:
						return;
				}
			};

			Slick.prototype.checkNavigable = function (index) {
				var _ = this,
					navigables,
					prevNavigable;

				navigables = _.getNavigableIndexes();
				prevNavigable = 0;

				if (index > navigables[navigables.length - 1]) {
					index = navigables[navigables.length - 1];
				} else {
					for (var n in navigables) {
						if (index < navigables[n]) {
							index = prevNavigable;
							break;
						}

						prevNavigable = navigables[n];
					}
				}

				return index;
			};

			Slick.prototype.cleanUpEvents = function () {
				var _ = this;

				if (_.options.dots && _.$dots !== null) {
					$('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));

					if (_.options.accessibility === true) {
						_.$dots.off('keydown.slick', _.keyHandler);
					}
				}

				_.$slider.off('focus.slick blur.slick');

				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
					_.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

					if (_.options.accessibility === true) {
						_.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
						_.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
					}
				}

				_.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);

				_.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);

				_.$list.off('touchend.slick mouseup.slick', _.swipeHandler);

				_.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

				_.$list.off('click.slick', _.clickHandler);

				$(document).off(_.visibilityChange, _.visibility);

				_.cleanUpSlideEvents();

				if (_.options.accessibility === true) {
					_.$list.off('keydown.slick', _.keyHandler);
				}

				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().off('click.slick', _.selectHandler);
				}

				$(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);
				$(window).off('resize.slick.slick-' + _.instanceUid, _.resize);
				$('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);
				$(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
			};

			Slick.prototype.cleanUpSlideEvents = function () {
				var _ = this;

				_.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));

				_.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
			};

			Slick.prototype.cleanUpRows = function () {
				var _ = this,
					originalSlides;

				if (_.options.rows > 0) {
					originalSlides = _.$slides.children().children();
					originalSlides.removeAttr('style');

					_.$slider.empty().append(originalSlides);
				}
			};

			Slick.prototype.clickHandler = function (event) {
				var _ = this;

				if (_.shouldClick === false) {
					event.stopImmediatePropagation();
					event.stopPropagation();
					event.preventDefault();
				}
			};

			Slick.prototype.destroy = function (refresh) {
				var _ = this;

				_.autoPlayClear();

				_.touchObject = {};

				_.cleanUpEvents();

				$('.slick-cloned', _.$slider).detach();

				if (_.$dots) {
					_.$dots.remove();
				}

				if (_.$prevArrow && _.$prevArrow.length) {
					_.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

					if (_.htmlExpr.test(_.options.prevArrow)) {
						_.$prevArrow.remove();
					}
				}

				if (_.$nextArrow && _.$nextArrow.length) {
					_.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

					if (_.htmlExpr.test(_.options.nextArrow)) {
						_.$nextArrow.remove();
					}
				}

				if (_.$slides) {
					_.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
						$(this).attr('style', $(this).data('originalStyling'));
					});

					_.$slideTrack.children(this.options.slide).detach();

					_.$slideTrack.detach();

					_.$list.detach();

					_.$slider.append(_.$slides);
				}

				_.cleanUpRows();

				_.$slider.removeClass('slick-slider');

				_.$slider.removeClass('slick-initialized');

				_.$slider.removeClass('slick-dotted');

				_.unslicked = true;

				if (!refresh) {
					_.$slider.trigger('destroy', [_]);
				}
			};

			Slick.prototype.disableTransition = function (slide) {
				var _ = this,
					transition = {};

				transition[_.transitionType] = '';

				if (_.options.fade === false) {
					_.$slideTrack.css(transition);
				} else {
					_.$slides.eq(slide).css(transition);
				}
			};

			Slick.prototype.fadeSlide = function (slideIndex, callback) {
				var _ = this;

				if (_.cssTransitions === false) {
					_.$slides.eq(slideIndex).css({
						zIndex: _.options.zIndex
					});

					_.$slides.eq(slideIndex).animate({
						opacity: 1
					}, _.options.speed, _.options.easing, callback);
				} else {
					_.applyTransition(slideIndex);

					_.$slides.eq(slideIndex).css({
						opacity: 1,
						zIndex: _.options.zIndex
					});

					if (callback) {
						setTimeout(function () {
							_.disableTransition(slideIndex);

							callback.call();
						}, _.options.speed);
					}
				}
			};

			Slick.prototype.fadeSlideOut = function (slideIndex) {
				var _ = this;

				if (_.cssTransitions === false) {
					_.$slides.eq(slideIndex).animate({
						opacity: 0,
						zIndex: _.options.zIndex - 2
					}, _.options.speed, _.options.easing);
				} else {
					_.applyTransition(slideIndex);

					_.$slides.eq(slideIndex).css({
						opacity: 0,
						zIndex: _.options.zIndex - 2
					});
				}
			};

			Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {
				var _ = this;

				if (filter !== null) {
					_.$slidesCache = _.$slides;

					_.unload();

					_.$slideTrack.children(this.options.slide).detach();

					_.$slidesCache.filter(filter).appendTo(_.$slideTrack);

					_.reinit();
				}
			};

			Slick.prototype.focusHandler = function () {
				var _ = this;

				_.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*', function (event) {
					event.stopImmediatePropagation();
					var $sf = $(this);
					setTimeout(function () {
						if (_.options.pauseOnFocus) {
							_.focussed = $sf.is(':focus');

							_.autoPlay();
						}
					}, 0);
				});
			};

			Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {
				var _ = this;

				return _.currentSlide;
			};

			Slick.prototype.getDotCount = function () {
				var _ = this;

				var breakPoint = 0;
				var counter = 0;
				var pagerQty = 0;

				if (_.options.infinite === true) {
					if (_.slideCount <= _.options.slidesToShow) {
						++pagerQty;
					} else {
						while (breakPoint < _.slideCount) {
							++pagerQty;
							breakPoint = counter + _.options.slidesToScroll;
							counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
						}
					}
				} else if (_.options.centerMode === true) {
					pagerQty = _.slideCount;
				} else if (!_.options.asNavFor) {
					pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
				} else {
					while (breakPoint < _.slideCount) {
						++pagerQty;
						breakPoint = counter + _.options.slidesToScroll;
						counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
					}
				}

				return pagerQty - 1;
			};

			Slick.prototype.getLeft = function (slideIndex) {
				var _ = this,
					targetLeft,
					verticalHeight,
					verticalOffset = 0,
					targetSlide,
					coef;

				_.slideOffset = 0;
				verticalHeight = _.$slides.first().outerHeight(true);

				if (_.options.infinite === true) {
					if (_.slideCount > _.options.slidesToShow) {
						_.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
						coef = -1;

						if (_.options.vertical === true && _.options.centerMode === true) {
							if (_.options.slidesToShow === 2) {
								coef = -1.5;
							} else if (_.options.slidesToShow === 1) {
								coef = -2;
							}
						}

						verticalOffset = verticalHeight * _.options.slidesToShow * coef;
					}

					if (_.slideCount % _.options.slidesToScroll !== 0) {
						if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
							if (slideIndex > _.slideCount) {
								_.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
								verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
							} else {
								_.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
								verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
							}
						}
					}
				} else {
					if (slideIndex + _.options.slidesToShow > _.slideCount) {
						_.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
						verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
					}
				}

				if (_.slideCount <= _.options.slidesToShow) {
					_.slideOffset = 0;
					verticalOffset = 0;
				}

				if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
					_.slideOffset = _.slideWidth * Math.floor(_.options.slidesToShow) / 2 - _.slideWidth * _.slideCount / 2;
				} else if (_.options.centerMode === true && _.options.infinite === true) {
					_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
				} else if (_.options.centerMode === true) {
					_.slideOffset = 0;
					_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
				}

				if (_.options.vertical === false) {
					targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
				} else {
					targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
				}

				if (_.options.variableWidth === true) {
					if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
						targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
					} else {
						targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
					}

					if (_.options.rtl === true) {
						if (targetSlide[0]) {
							targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
						} else {
							targetLeft = 0;
						}
					} else {
						targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
					}

					if (_.options.centerMode === true) {
						if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
						} else {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
						}

						if (_.options.rtl === true) {
							if (targetSlide[0]) {
								targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
							} else {
								targetLeft = 0;
							}
						} else {
							targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
						}

						targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
					}
				}

				return targetLeft;
			};

			Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {
				var _ = this;

				return _.options[option];
			};

			Slick.prototype.getNavigableIndexes = function () {
				var _ = this,
					breakPoint = 0,
					counter = 0,
					indexes = [],
					max;

				if (_.options.infinite === false) {
					max = _.slideCount;
				} else {
					breakPoint = _.options.slidesToScroll * -1;
					counter = _.options.slidesToScroll * -1;
					max = _.slideCount * 2;
				}

				while (breakPoint < max) {
					indexes.push(breakPoint);
					breakPoint = counter + _.options.slidesToScroll;
					counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
				}

				return indexes;
			};

			Slick.prototype.getSlick = function () {
				return this;
			};

			Slick.prototype.getSlideCount = function () {
				var _ = this,
					slidesTraversed,
					swipedSlide,
					centerOffset;

				centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

				if (_.options.swipeToSlide === true) {
					_.$slideTrack.find('.slick-slide').each(function (index, slide) {
						if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
							swipedSlide = slide;
							return false;
						}
					});

					slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;
					return slidesTraversed;
				} else {
					return _.options.slidesToScroll;
				}
			};

			Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {
				var _ = this;

				_.changeSlide({
					data: {
						message: 'index',
						index: parseInt(slide)
					}
				}, dontAnimate);
			};

			Slick.prototype.init = function (creation) {
				var _ = this;

				if (!$(_.$slider).hasClass('slick-initialized')) {
					$(_.$slider).addClass('slick-initialized');

					_.buildRows();

					_.buildOut();

					_.setProps();

					_.startLoad();

					_.loadSlider();

					_.initializeEvents();

					_.updateArrows();

					_.updateDots();

					_.checkResponsive(true);

					_.focusHandler();
				}

				if (creation) {
					_.$slider.trigger('init', [_]);
				}

				if (_.options.accessibility === true) {
					_.initADA();
				}

				if (_.options.autoplay) {
					_.paused = false;

					_.autoPlay();
				}
			};

			Slick.prototype.initADA = function () {
				var _ = this,
					numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
					tabControlIndexes = _.getNavigableIndexes().filter(function (val) {
						return val >= 0 && val < _.slideCount;
					});

				_.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
					'aria-hidden': 'true',
					'tabindex': '-1'
				}).find('a, input, button, select').attr({
					'tabindex': '-1'
				});

				if (_.$dots !== null) {
					_.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
						var slideControlIndex = tabControlIndexes.indexOf(i);
						$(this).attr({
							'role': 'tabpanel',
							'id': 'slick-slide' + _.instanceUid + i,
							'tabindex': -1
						});

						if (slideControlIndex !== -1) {
							var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex;

							if ($('#' + ariaButtonControl).length) {
								$(this).attr({
									'aria-describedby': ariaButtonControl
								});
							}
						}
					});

					_.$dots.attr('role', 'tablist').find('li').each(function (i) {
						var mappedSlideIndex = tabControlIndexes[i];
						$(this).attr({
							'role': 'presentation'
						});
						$(this).find('button').first().attr({
							'role': 'tab',
							'id': 'slick-slide-control' + _.instanceUid + i,
							'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
							'aria-label': i + 1 + ' of ' + numDotGroups,
							'aria-selected': null,
							'tabindex': '-1'
						});
					}).eq(_.currentSlide).find('button').attr({
						'aria-selected': 'true',
						'tabindex': '0'
					}).end();
				}

				for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++) {
					if (_.options.focusOnChange) {
						_.$slides.eq(i).attr({
							'tabindex': '0'
						});
					} else {
						_.$slides.eq(i).removeAttr('tabindex');
					}
				}

				_.activateADA();
			};

			Slick.prototype.initArrowEvents = function () {
				var _ = this;

				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.off('click.slick').on('click.slick', {
						message: 'previous'
					}, _.changeSlide);

					_.$nextArrow.off('click.slick').on('click.slick', {
						message: 'next'
					}, _.changeSlide);

					if (_.options.accessibility === true) {
						_.$prevArrow.on('keydown.slick', _.keyHandler);

						_.$nextArrow.on('keydown.slick', _.keyHandler);
					}
				}
			};

			Slick.prototype.initDotEvents = function () {
				var _ = this;

				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					$('li', _.$dots).on('click.slick', {
						message: 'index'
					}, _.changeSlide);

					if (_.options.accessibility === true) {
						_.$dots.on('keydown.slick', _.keyHandler);
					}
				}

				if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {
					$('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
				}
			};

			Slick.prototype.initSlideEvents = function () {
				var _ = this;

				if (_.options.pauseOnHover) {
					_.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));

					_.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
				}
			};

			Slick.prototype.initializeEvents = function () {
				var _ = this;

				_.initArrowEvents();

				_.initDotEvents();

				_.initSlideEvents();

				_.$list.on('touchstart.slick mousedown.slick', {
					action: 'start'
				}, _.swipeHandler);

				_.$list.on('touchmove.slick mousemove.slick', {
					action: 'move'
				}, _.swipeHandler);

				_.$list.on('touchend.slick mouseup.slick', {
					action: 'end'
				}, _.swipeHandler);

				_.$list.on('touchcancel.slick mouseleave.slick', {
					action: 'end'
				}, _.swipeHandler);

				_.$list.on('click.slick', _.clickHandler);

				$(document).on(_.visibilityChange, $.proxy(_.visibility, _));

				if (_.options.accessibility === true) {
					_.$list.on('keydown.slick', _.keyHandler);
				}

				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().on('click.slick', _.selectHandler);
				}

				$(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));
				$(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));
				$('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);
				$(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
				$(_.setPosition);
			};

			Slick.prototype.initUI = function () {
				var _ = this;

				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.show();

					_.$nextArrow.show();
				}

				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$dots.show();
				}
			};

			Slick.prototype.keyHandler = function (event) {
				var _ = this; //Dont slide if the cursor is inside the form fields and arrow keys are pressed


				if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
					if (event.keyCode === 37 && _.options.accessibility === true) {
						_.changeSlide({
							data: {
								message: _.options.rtl === true ? 'next' : 'previous'
							}
						});
					} else if (event.keyCode === 39 && _.options.accessibility === true) {
						_.changeSlide({
							data: {
								message: _.options.rtl === true ? 'previous' : 'next'
							}
						});
					}
				}
			};

			Slick.prototype.lazyLoad = function () {
				var _ = this,
					loadRange,
					cloneRange,
					rangeStart,
					rangeEnd;

				function loadImages(imagesScope) {
					$('img[data-lazy]', imagesScope).each(function () {
						var image = $(this),
							imageSource = $(this).attr('data-lazy'),
							imageSrcSet = $(this).attr('data-srcset'),
							imageSizes = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
							imageToLoad = document.createElement('img');

						imageToLoad.onload = function () {
							image.animate({
								opacity: 0
							}, 100, function () {
								if (imageSrcSet) {
									image.attr('srcset', imageSrcSet);

									if (imageSizes) {
										image.attr('sizes', imageSizes);
									}
								}

								image.attr('src', imageSource).animate({
									opacity: 1
								}, 200, function () {
									image.removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');
								});

								_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
							});
						};

						imageToLoad.onerror = function () {
							image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

							_.$slider.trigger('lazyLoadError', [_, image, imageSource]);
						};

						imageToLoad.src = imageSource;
					});
				}

				if (_.options.centerMode === true) {
					if (_.options.infinite === true) {
						rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
						rangeEnd = rangeStart + _.options.slidesToShow + 2;
					} else {
						rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
						rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
					}
				} else {
					rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
					rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);

					if (_.options.fade === true) {
						if (rangeStart > 0) rangeStart--;
						if (rangeEnd <= _.slideCount) rangeEnd++;
					}
				}

				loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

				if (_.options.lazyLoad === 'anticipated') {
					var prevSlide = rangeStart - 1,
						nextSlide = rangeEnd,
						$slides = _.$slider.find('.slick-slide');

					for (var i = 0; i < _.options.slidesToScroll; i++) {
						if (prevSlide < 0) prevSlide = _.slideCount - 1;
						loadRange = loadRange.add($slides.eq(prevSlide));
						loadRange = loadRange.add($slides.eq(nextSlide));
						prevSlide--;
						nextSlide++;
					}
				}

				loadImages(loadRange);

				if (_.slideCount <= _.options.slidesToShow) {
					cloneRange = _.$slider.find('.slick-slide');
					loadImages(cloneRange);
				} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
					cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
					loadImages(cloneRange);
				} else if (_.currentSlide === 0) {
					cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
					loadImages(cloneRange);
				}
			};

			Slick.prototype.loadSlider = function () {
				var _ = this;

				_.setPosition();

				_.$slideTrack.css({
					opacity: 1
				});

				_.$slider.removeClass('slick-loading');

				_.initUI();

				if (_.options.lazyLoad === 'progressive') {
					_.progressiveLazyLoad();
				}
			};

			Slick.prototype.next = Slick.prototype.slickNext = function () {
				var _ = this;

				_.changeSlide({
					data: {
						message: 'next'
					}
				});
			};

			Slick.prototype.orientationChange = function () {
				var _ = this;

				_.checkResponsive();

				_.setPosition();
			};

			Slick.prototype.pause = Slick.prototype.slickPause = function () {
				var _ = this;

				_.autoPlayClear();

				_.paused = true;
			};

			Slick.prototype.play = Slick.prototype.slickPlay = function () {
				var _ = this;

				_.autoPlay();

				_.options.autoplay = true;
				_.paused = false;
				_.focussed = false;
				_.interrupted = false;
			};

			Slick.prototype.postSlide = function (index) {
				var _ = this;

				if (!_.unslicked) {
					_.$slider.trigger('afterChange', [_, index]);

					_.animating = false;

					if (_.slideCount > _.options.slidesToShow) {
						_.setPosition();
					}

					_.swipeLeft = null;

					if (_.options.autoplay) {
						_.autoPlay();
					}

					if (_.options.accessibility === true) {
						_.initADA();

						if (_.options.focusOnChange) {
							var $currentSlide = $(_.$slides.get(_.currentSlide));
							$currentSlide.attr('tabindex', 0).focus();
						}
					}
				}
			};

			Slick.prototype.prev = Slick.prototype.slickPrev = function () {
				var _ = this;

				_.changeSlide({
					data: {
						message: 'previous'
					}
				});
			};

			Slick.prototype.preventDefault = function (event) {
				event.preventDefault();
			};

			Slick.prototype.progressiveLazyLoad = function (tryCount) {
				tryCount = tryCount || 1;

				var _ = this,
					$imgsToLoad = $('img[data-lazy]', _.$slider),
					image,
					imageSource,
					imageSrcSet,
					imageSizes,
					imageToLoad;

				if ($imgsToLoad.length) {
					image = $imgsToLoad.first();
					imageSource = image.attr('data-lazy');
					imageSrcSet = image.attr('data-srcset');
					imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');
					imageToLoad = document.createElement('img');

					imageToLoad.onload = function () {
						if (imageSrcSet) {
							image.attr('srcset', imageSrcSet);

							if (imageSizes) {
								image.attr('sizes', imageSizes);
							}
						}

						image.attr('src', imageSource).removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');

						if (_.options.adaptiveHeight === true) {
							_.setPosition();
						}

						_.$slider.trigger('lazyLoaded', [_, image, imageSource]);

						_.progressiveLazyLoad();
					};

					imageToLoad.onerror = function () {
						if (tryCount < 3) {
							/**
							 * try to load the image 3 times,
							 * leave a slight delay so we don't get
							 * servers blocking the request.
							 */
							setTimeout(function () {
								_.progressiveLazyLoad(tryCount + 1);
							}, 500);
						} else {
							image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

							_.$slider.trigger('lazyLoadError', [_, image, imageSource]);

							_.progressiveLazyLoad();
						}
					};

					imageToLoad.src = imageSource;
				} else {
					_.$slider.trigger('allImagesLoaded', [_]);
				}
			};

			Slick.prototype.refresh = function (initializing) {
				var _ = this,
					currentSlide,
					lastVisibleIndex;

				lastVisibleIndex = _.slideCount - _.options.slidesToShow; // in non-infinite sliders, we don't want to go past the
				// last visible index.

				if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
					_.currentSlide = lastVisibleIndex;
				} // if less slides than to show, go to start.


				if (_.slideCount <= _.options.slidesToShow) {
					_.currentSlide = 0;
				}

				currentSlide = _.currentSlide;

				_.destroy(true);

				$.extend(_, _.initials, {
					currentSlide: currentSlide
				});

				_.init();

				if (!initializing) {
					_.changeSlide({
						data: {
							message: 'index',
							index: currentSlide
						}
					}, false);
				}
			};

			Slick.prototype.registerBreakpoints = function () {
				var _ = this,
					breakpoint,
					currentBreakpoint,
					l,
					responsiveSettings = _.options.responsive || null;

				if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {
					_.respondTo = _.options.respondTo || 'window';

					for (breakpoint in responsiveSettings) {
						l = _.breakpoints.length - 1;

						if (responsiveSettings.hasOwnProperty(breakpoint)) {
							currentBreakpoint = responsiveSettings[breakpoint].breakpoint; // loop through the breakpoints and cut out any existing
							// ones with the same breakpoint number, we don't want dupes.

							while (l >= 0) {
								if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
									_.breakpoints.splice(l, 1);
								}

								l--;
							}

							_.breakpoints.push(currentBreakpoint);

							_.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
						}
					}

					_.breakpoints.sort(function (a, b) {
						return _.options.mobileFirst ? a - b : b - a;
					});
				}
			};

			Slick.prototype.reinit = function () {
				var _ = this;

				_.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');
				_.slideCount = _.$slides.length;

				if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
					_.currentSlide = _.currentSlide - _.options.slidesToScroll;
				}

				if (_.slideCount <= _.options.slidesToShow) {
					_.currentSlide = 0;
				}

				_.registerBreakpoints();

				_.setProps();

				_.setupInfinite();

				_.buildArrows();

				_.updateArrows();

				_.initArrowEvents();

				_.buildDots();

				_.updateDots();

				_.initDotEvents();

				_.cleanUpSlideEvents();

				_.initSlideEvents();

				_.checkResponsive(false, true);

				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().on('click.slick', _.selectHandler);
				}

				_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

				_.setPosition();

				_.focusHandler();

				_.paused = !_.options.autoplay;

				_.autoPlay();

				_.$slider.trigger('reInit', [_]);
			};

			Slick.prototype.resize = function () {
				var _ = this;

				if ($(window).width() !== _.windowWidth) {
					clearTimeout(_.windowDelay);
					_.windowDelay = window.setTimeout(function () {
						_.windowWidth = $(window).width();

						_.checkResponsive();

						if (!_.unslicked) {
							_.setPosition();
						}
					}, 50);
				}
			};

			Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {
				var _ = this;

				if (typeof index === 'boolean') {
					removeBefore = index;
					index = removeBefore === true ? 0 : _.slideCount - 1;
				} else {
					index = removeBefore === true ? --index : index;
				}

				if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
					return false;
				}

				_.unload();

				if (removeAll === true) {
					_.$slideTrack.children().remove();
				} else {
					_.$slideTrack.children(this.options.slide).eq(index).remove();
				}

				_.$slides = _.$slideTrack.children(this.options.slide);

				_.$slideTrack.children(this.options.slide).detach();

				_.$slideTrack.append(_.$slides);

				_.$slidesCache = _.$slides;

				_.reinit();
			};

			Slick.prototype.setCSS = function (position) {
				var _ = this,
					positionProps = {},
					x,
					y;

				if (_.options.rtl === true) {
					position = -position;
				}

				x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
				y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';
				positionProps[_.positionProp] = position;

				if (_.transformsEnabled === false) {
					_.$slideTrack.css(positionProps);
				} else {
					positionProps = {};

					if (_.cssTransitions === false) {
						positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';

						_.$slideTrack.css(positionProps);
					} else {
						positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';

						_.$slideTrack.css(positionProps);
					}
				}
			};

			Slick.prototype.setDimensions = function () {
				var _ = this;

				if (_.options.vertical === false) {
					if (_.options.centerMode === true) {
						_.$list.css({
							padding: '0px ' + _.options.centerPadding
						});
					}
				} else {
					_.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);

					if (_.options.centerMode === true) {
						_.$list.css({
							padding: _.options.centerPadding + ' 0px'
						});
					}
				}

				_.listWidth = _.$list.width();
				_.listHeight = _.$list.height();

				if (_.options.vertical === false && _.options.variableWidth === false) {
					_.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);

					_.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
				} else if (_.options.variableWidth === true) {
					_.$slideTrack.width(5000 * _.slideCount);
				} else {
					_.slideWidth = Math.ceil(_.listWidth);

					_.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
				}

				var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();

				if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
			};

			Slick.prototype.setFade = function () {
				var _ = this,
					targetLeft;

				_.$slides.each(function (index, element) {
					targetLeft = _.slideWidth * index * -1;

					if (_.options.rtl === true) {
						$(element).css({
							position: 'relative',
							right: targetLeft,
							top: 0,
							zIndex: _.options.zIndex - 2,
							opacity: 0
						});
					} else {
						$(element).css({
							position: 'relative',
							left: targetLeft,
							top: 0,
							zIndex: _.options.zIndex - 2,
							opacity: 0
						});
					}
				});

				_.$slides.eq(_.currentSlide).css({
					zIndex: _.options.zIndex - 1,
					opacity: 1
				});
			};

			Slick.prototype.setHeight = function () {
				var _ = this;

				if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
					var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);

					_.$list.css('height', targetHeight);
				}
			};

			Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {
				/**
				 * accepts arguments in format of:
				 *
				 *  - for changing a single option's value:
				 *     .slick("setOption", option, value, refresh )
				 *
				 *  - for changing a set of responsive options:
				 *     .slick("setOption", 'responsive', [{}, ...], refresh )
				 *
				 *  - for updating multiple values at once (not responsive)
				 *     .slick("setOption", { 'option': value, ... }, refresh )
				 */
				var _ = this,
					l,
					item,
					option,
					value,
					refresh = false,
					type;

				if ($.type(arguments[0]) === 'object') {
					option = arguments[0];
					refresh = arguments[1];
					type = 'multiple';
				} else if ($.type(arguments[0]) === 'string') {
					option = arguments[0];
					value = arguments[1];
					refresh = arguments[2];

					if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {
						type = 'responsive';
					} else if (typeof arguments[1] !== 'undefined') {
						type = 'single';
					}
				}

				if (type === 'single') {
					_.options[option] = value;
				} else if (type === 'multiple') {
					$.each(option, function (opt, val) {
						_.options[opt] = val;
					});
				} else if (type === 'responsive') {
					for (item in value) {
						if ($.type(_.options.responsive) !== 'array') {
							_.options.responsive = [value[item]];
						} else {
							l = _.options.responsive.length - 1; // loop through the responsive object and splice out duplicates.

							while (l >= 0) {
								if (_.options.responsive[l].breakpoint === value[item].breakpoint) {
									_.options.responsive.splice(l, 1);
								}

								l--;
							}

							_.options.responsive.push(value[item]);
						}
					}
				}

				if (refresh) {
					_.unload();

					_.reinit();
				}
			};

			Slick.prototype.setPosition = function () {
				var _ = this;

				_.setDimensions();

				_.setHeight();

				if (_.options.fade === false) {
					_.setCSS(_.getLeft(_.currentSlide));
				} else {
					_.setFade();
				}

				_.$slider.trigger('setPosition', [_]);
			};

			Slick.prototype.setProps = function () {
				var _ = this,
					bodyStyle = document.body.style;

				_.positionProp = _.options.vertical === true ? 'top' : 'left';

				if (_.positionProp === 'top') {
					_.$slider.addClass('slick-vertical');
				} else {
					_.$slider.removeClass('slick-vertical');
				}

				if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
					if (_.options.useCSS === true) {
						_.cssTransitions = true;
					}
				}

				if (_.options.fade) {
					if (typeof _.options.zIndex === 'number') {
						if (_.options.zIndex < 3) {
							_.options.zIndex = 3;
						}
					} else {
						_.options.zIndex = _.defaults.zIndex;
					}
				}

				if (bodyStyle.OTransform !== undefined) {
					_.animType = 'OTransform';
					_.transformType = '-o-transform';
					_.transitionType = 'OTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
				}

				if (bodyStyle.MozTransform !== undefined) {
					_.animType = 'MozTransform';
					_.transformType = '-moz-transform';
					_.transitionType = 'MozTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
				}

				if (bodyStyle.webkitTransform !== undefined) {
					_.animType = 'webkitTransform';
					_.transformType = '-webkit-transform';
					_.transitionType = 'webkitTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
				}

				if (bodyStyle.msTransform !== undefined) {
					_.animType = 'msTransform';
					_.transformType = '-ms-transform';
					_.transitionType = 'msTransition';
					if (bodyStyle.msTransform === undefined) _.animType = false;
				}

				if (bodyStyle.transform !== undefined && _.animType !== false) {
					_.animType = 'transform';
					_.transformType = 'transform';
					_.transitionType = 'transition';
				}

				_.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
			};

			Slick.prototype.setSlideClasses = function (index) {
				var _ = this,
					centerOffset,
					allSlides,
					indexOffset,
					remainder;

				allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

				_.$slides.eq(index).addClass('slick-current');

				if (_.options.centerMode === true) {
					var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;
					centerOffset = Math.floor(_.options.slidesToShow / 2);

					if (_.options.infinite === true) {
						if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {
							_.$slides.slice(index - centerOffset + evenCoef, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
						} else {
							indexOffset = _.options.slidesToShow + index;
							allSlides.slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
						}

						if (index === 0) {
							allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
						} else if (index === _.slideCount - 1) {
							allSlides.eq(_.options.slidesToShow).addClass('slick-center');
						}
					}

					_.$slides.eq(index).addClass('slick-center');
				} else {
					if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {
						_.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
					} else if (allSlides.length <= _.options.slidesToShow) {
						allSlides.addClass('slick-active').attr('aria-hidden', 'false');
					} else {
						remainder = _.slideCount % _.options.slidesToShow;
						indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

						if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {
							allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
						} else {
							allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
						}
					}
				}

				if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
					_.lazyLoad();
				}
			};

			Slick.prototype.setupInfinite = function () {
				var _ = this,
					i,
					slideIndex,
					infiniteCount;

				if (_.options.fade === true) {
					_.options.centerMode = false;
				}

				if (_.options.infinite === true && _.options.fade === false) {
					slideIndex = null;

					if (_.slideCount > _.options.slidesToShow) {
						if (_.options.centerMode === true) {
							infiniteCount = _.options.slidesToShow + 1;
						} else {
							infiniteCount = _.options.slidesToShow;
						}

						for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
							slideIndex = i - 1;
							$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
						}

						for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
							slideIndex = i;
							$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
						}

						_.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
							$(this).attr('id', '');
						});
					}
				}
			};

			Slick.prototype.interrupt = function (toggle) {
				var _ = this;

				if (!toggle) {
					_.autoPlay();
				}

				_.interrupted = toggle;
			};

			Slick.prototype.selectHandler = function (event) {
				var _ = this;

				var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');
				var index = parseInt(targetElement.attr('data-slick-index'));
				if (!index) index = 0;

				if (_.slideCount <= _.options.slidesToShow) {
					_.slideHandler(index, false, true);

					return;
				}

				_.slideHandler(index);
			};

			Slick.prototype.slideHandler = function (index, sync, dontAnimate) {
				var targetSlide,
					animSlide,
					oldSlide,
					slideLeft,
					targetLeft = null,
					_ = this,
					navTarget;

				sync = sync || false;

				if (_.animating === true && _.options.waitForAnimate === true) {
					return;
				}

				if (_.options.fade === true && _.currentSlide === index) {
					return;
				}

				if (sync === false) {
					_.asNavFor(index);
				}

				targetSlide = index;
				targetLeft = _.getLeft(targetSlide);
				slideLeft = _.getLeft(_.currentSlide);
				_.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

				if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
					if (_.options.fade === false) {
						targetSlide = _.currentSlide;

						if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
							_.animateSlide(slideLeft, function () {
								_.postSlide(targetSlide);
							});
						} else {
							_.postSlide(targetSlide);
						}
					}

					return;
				} else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
					if (_.options.fade === false) {
						targetSlide = _.currentSlide;

						if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
							_.animateSlide(slideLeft, function () {
								_.postSlide(targetSlide);
							});
						} else {
							_.postSlide(targetSlide);
						}
					}

					return;
				}

				if (_.options.autoplay) {
					clearInterval(_.autoPlayTimer);
				}

				if (targetSlide < 0) {
					if (_.slideCount % _.options.slidesToScroll !== 0) {
						animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
					} else {
						animSlide = _.slideCount + targetSlide;
					}
				} else if (targetSlide >= _.slideCount) {
					if (_.slideCount % _.options.slidesToScroll !== 0) {
						animSlide = 0;
					} else {
						animSlide = targetSlide - _.slideCount;
					}
				} else {
					animSlide = targetSlide;
				}

				_.animating = true;

				_.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

				oldSlide = _.currentSlide;
				_.currentSlide = animSlide;

				_.setSlideClasses(_.currentSlide);

				if (_.options.asNavFor) {
					navTarget = _.getNavTarget();
					navTarget = navTarget.slick('getSlick');

					if (navTarget.slideCount <= navTarget.options.slidesToShow) {
						navTarget.setSlideClasses(_.currentSlide);
					}
				}

				_.updateDots();

				_.updateArrows();

				if (_.options.fade === true) {
					if (dontAnimate !== true) {
						_.fadeSlideOut(oldSlide);

						_.fadeSlide(animSlide, function () {
							_.postSlide(animSlide);
						});
					} else {
						_.postSlide(animSlide);
					}

					_.animateHeight();

					return;
				}

				if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
					_.animateSlide(targetLeft, function () {
						_.postSlide(animSlide);
					});
				} else {
					_.postSlide(animSlide);
				}
			};

			Slick.prototype.startLoad = function () {
				var _ = this;

				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.hide();

					_.$nextArrow.hide();
				}

				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$dots.hide();
				}

				_.$slider.addClass('slick-loading');
			};

			Slick.prototype.swipeDirection = function () {
				var xDist,
					yDist,
					r,
					swipeAngle,
					_ = this;

				xDist = _.touchObject.startX - _.touchObject.curX;
				yDist = _.touchObject.startY - _.touchObject.curY;
				r = Math.atan2(yDist, xDist);
				swipeAngle = Math.round(r * 180 / Math.PI);

				if (swipeAngle < 0) {
					swipeAngle = 360 - Math.abs(swipeAngle);
				}

				if (swipeAngle <= 45 && swipeAngle >= 0) {
					return _.options.rtl === false ? 'left' : 'right';
				}

				if (swipeAngle <= 360 && swipeAngle >= 315) {
					return _.options.rtl === false ? 'left' : 'right';
				}

				if (swipeAngle >= 135 && swipeAngle <= 225) {
					return _.options.rtl === false ? 'right' : 'left';
				}

				if (_.options.verticalSwiping === true) {
					if (swipeAngle >= 35 && swipeAngle <= 135) {
						return 'down';
					} else {
						return 'up';
					}
				}

				return 'vertical';
			};

			Slick.prototype.swipeEnd = function (event) {
				var _ = this,
					slideCount,
					direction;

				_.dragging = false;
				_.swiping = false;

				if (_.scrolling) {
					_.scrolling = false;
					return false;
				}

				_.interrupted = false;
				_.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

				if (_.touchObject.curX === undefined) {
					return false;
				}

				if (_.touchObject.edgeHit === true) {
					_.$slider.trigger('edge', [_, _.swipeDirection()]);
				}

				if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
					direction = _.swipeDirection();

					switch (direction) {
						case 'left':
						case 'down':
							slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
							_.currentDirection = 0;
							break;

						case 'right':
						case 'up':
							slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
							_.currentDirection = 1;
							break;

						default:
					}

					if (direction != 'vertical') {
						_.slideHandler(slideCount);

						_.touchObject = {};

						_.$slider.trigger('swipe', [_, direction]);
					}
				} else {
					if (_.touchObject.startX !== _.touchObject.curX) {
						_.slideHandler(_.currentSlide);

						_.touchObject = {};
					}
				}
			};

			Slick.prototype.swipeHandler = function (event) {
				var _ = this;

				if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
					return;
				} else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
					return;
				}

				_.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;
				_.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

				if (_.options.verticalSwiping === true) {
					_.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
				}

				switch (event.data.action) {
					case 'start':
						_.swipeStart(event);

						break;

					case 'move':
						_.swipeMove(event);

						break;

					case 'end':
						_.swipeEnd(event);

						break;
				}
			};

			Slick.prototype.swipeMove = function (event) {
				var _ = this,
					edgeWasHit = false,
					curLeft,
					swipeDirection,
					swipeLength,
					positionOffset,
					touches,
					verticalSwipeLength;

				touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

				if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
					return false;
				}

				curLeft = _.getLeft(_.currentSlide);
				_.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
				_.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;
				_.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
				verticalSwipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

				if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
					_.scrolling = true;
					return false;
				}

				if (_.options.verticalSwiping === true) {
					_.touchObject.swipeLength = verticalSwipeLength;
				}

				swipeDirection = _.swipeDirection();

				if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
					_.swiping = true;
					event.preventDefault();
				}

				positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);

				if (_.options.verticalSwiping === true) {
					positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
				}

				swipeLength = _.touchObject.swipeLength;
				_.touchObject.edgeHit = false;

				if (_.options.infinite === false) {
					if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
						swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
						_.touchObject.edgeHit = true;
					}
				}

				if (_.options.vertical === false) {
					_.swipeLeft = curLeft + swipeLength * positionOffset;
				} else {
					_.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
				}

				if (_.options.verticalSwiping === true) {
					_.swipeLeft = curLeft + swipeLength * positionOffset;
				}

				if (_.options.fade === true || _.options.touchMove === false) {
					return false;
				}

				if (_.animating === true) {
					_.swipeLeft = null;
					return false;
				}

				_.setCSS(_.swipeLeft);
			};

			Slick.prototype.swipeStart = function (event) {
				var _ = this,
					touches;

				_.interrupted = true;

				if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
					_.touchObject = {};
					return false;
				}

				if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
					touches = event.originalEvent.touches[0];
				}

				_.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
				_.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;
				_.dragging = true;
			};

			Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {
				var _ = this;

				if (_.$slidesCache !== null) {
					_.unload();

					_.$slideTrack.children(this.options.slide).detach();

					_.$slidesCache.appendTo(_.$slideTrack);

					_.reinit();
				}
			};

			Slick.prototype.unload = function () {
				var _ = this;

				$('.slick-cloned', _.$slider).remove();

				if (_.$dots) {
					_.$dots.remove();
				}

				if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
					_.$prevArrow.remove();
				}

				if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
					_.$nextArrow.remove();
				}

				_.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
			};

			Slick.prototype.unslick = function (fromBreakpoint) {
				var _ = this;

				_.$slider.trigger('unslick', [_, fromBreakpoint]);

				_.destroy();
			};

			Slick.prototype.updateArrows = function () {
				var _ = this,
					centerOffset;

				centerOffset = Math.floor(_.options.slidesToShow / 2);

				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {
					_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

					_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

					if (_.currentSlide === 0) {
						_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

						_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {
						_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

						_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					} else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {
						_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

						_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					}
				}
			};

			Slick.prototype.updateDots = function () {
				var _ = this;

				if (_.$dots !== null) {
					_.$dots.find('li').removeClass('slick-active').end();

					_.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active');
				}
			};

			Slick.prototype.visibility = function () {
				var _ = this;

				if (_.options.autoplay) {
					if (document[_.hidden]) {
						_.interrupted = true;
					} else {
						_.interrupted = false;
					}
				}
			};

			$.fn.slick = function () {
				var _ = this,
					opt = arguments[0],
					args = Array.prototype.slice.call(arguments, 1),
					l = _.length,
					i,
					ret;

				for (i = 0; i < l; i++) {
					if (_typeof(opt) == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt); else ret = _[i].slick[opt].apply(_[i].slick, args);
					if (typeof ret != 'undefined') return ret;
				}

				return _;
			};
		});

		/***/
	}),
	/* 10 */
	/***/ (function (module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

		/***/
	}),
	/* 11 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*!
 * Datepicker for Bootstrap v1.9.0 (https://github.com/uxsolutions/bootstrap-datepicker)
 *
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */
		(function (factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
						(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(function ($, undefined) {
			function UTCDate() {
				return new Date(Date.UTC.apply(Date, arguments));
			}

			function UTCToday() {
				var today = new Date();
				return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
			}

			function isUTCEquals(date1, date2) {
				return date1.getUTCFullYear() === date2.getUTCFullYear() && date1.getUTCMonth() === date2.getUTCMonth() && date1.getUTCDate() === date2.getUTCDate();
			}

			function alias(method, deprecationMsg) {
				return function () {
					if (deprecationMsg !== undefined) {
						$.fn.datepicker.deprecated(deprecationMsg);
					}

					return this[method].apply(this, arguments);
				};
			}

			function isValidDate(d) {
				return d && !isNaN(d.getTime());
			}

			var DateArray = function () {
				var extras = {
					get: function get(i) {
						return this.slice(i)[0];
					},
					contains: function contains(d) {
						// Array.indexOf is not cross-browser;
						// $.inArray doesn't work with Dates
						var val = d && d.valueOf();

						for (var i = 0, l = this.length; i < l; i++) {
							// Use date arithmetic to allow dates with different times to match
							if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000 * 60 * 60 * 24) return i;
						}

						return -1;
					},
					remove: function remove(i) {
						this.splice(i, 1);
					},
					replace: function replace(new_array) {
						if (!new_array) return;
						if (!$.isArray(new_array)) new_array = [new_array];
						this.clear();
						this.push.apply(this, new_array);
					},
					clear: function clear() {
						this.length = 0;
					},
					copy: function copy() {
						var a = new DateArray();
						a.replace(this);
						return a;
					}
				};
				return function () {
					var a = [];
					a.push.apply(a, arguments);
					$.extend(a, extras);
					return a;
				};
			}(); // Picker object


			var Datepicker = function Datepicker(element, options) {
				$.data(element, 'datepicker', this);
				this._events = [];
				this._secondaryEvents = [];

				this._process_options(options);

				this.dates = new DateArray();
				this.viewDate = this.o.defaultViewDate;
				this.focusDate = null;
				this.element = $(element);
				this.isInput = this.element.is('input');
				this.inputField = this.isInput ? this.element : this.element.find('input');
				this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .input-group-append, .input-group-prepend, .btn') : false;
				if (this.component && this.component.length === 0) this.component = false;
				this.isInline = !this.component && this.element.is('div');
				this.picker = $(DPGlobal.template); // Checking templates and inserting

				if (this._check_template(this.o.templates.leftArrow)) {
					this.picker.find('.prev').html(this.o.templates.leftArrow);
				}

				if (this._check_template(this.o.templates.rightArrow)) {
					this.picker.find('.next').html(this.o.templates.rightArrow);
				}

				this._buildEvents();

				this._attachEvents();

				if (this.isInline) {
					this.picker.addClass('datepicker-inline').appendTo(this.element);
				} else {
					this.picker.addClass('datepicker-dropdown dropdown-menu');
				}

				if (this.o.rtl) {
					this.picker.addClass('datepicker-rtl');
				}

				if (this.o.calendarWeeks) {
					this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear').attr('colspan', function (i, val) {
						return Number(val) + 1;
					});
				}

				this._process_options({
					startDate: this._o.startDate,
					endDate: this._o.endDate,
					daysOfWeekDisabled: this.o.daysOfWeekDisabled,
					daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
					datesDisabled: this.o.datesDisabled
				});

				this._allow_update = false;
				this.setViewMode(this.o.startView);
				this._allow_update = true;
				this.fillDow();
				this.fillMonths();
				this.update();

				if (this.isInline) {
					this.show();
				}
			};

			Datepicker.prototype = {
				constructor: Datepicker,
				_resolveViewName: function _resolveViewName(view) {
					$.each(DPGlobal.viewModes, function (i, viewMode) {
						if (view === i || $.inArray(view, viewMode.names) !== -1) {
							view = i;
							return false;
						}
					});
					return view;
				},
				_resolveDaysOfWeek: function _resolveDaysOfWeek(daysOfWeek) {
					if (!$.isArray(daysOfWeek)) daysOfWeek = daysOfWeek.split(/[,\s]*/);
					return $.map(daysOfWeek, Number);
				},
				_check_template: function _check_template(tmp) {
					try {
						// If empty
						if (tmp === undefined || tmp === "") {
							return false;
						} // If no html, everything ok


						if ((tmp.match(/[<>]/g) || []).length <= 0) {
							return true;
						} // Checking if html is fine


						var jDom = $(tmp);
						return jDom.length > 0;
					} catch (ex) {
						return false;
					}
				},
				_process_options: function _process_options(opts) {
					// Store raw options for reference
					this._o = $.extend({}, this._o, opts); // Processed options

					var o = this.o = $.extend({}, this._o); // Check if "de-DE" style date is available, if not language should
					// fallback to 2 letter code eg "de"

					var lang = o.language;

					if (!dates[lang]) {
						lang = lang.split('-')[0];
						if (!dates[lang]) lang = defaults.language;
					}

					o.language = lang; // Retrieve view index from any aliases

					o.startView = this._resolveViewName(o.startView);
					o.minViewMode = this._resolveViewName(o.minViewMode);
					o.maxViewMode = this._resolveViewName(o.maxViewMode); // Check view is between min and max

					o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView)); // true, false, or Number > 0

					if (o.multidate !== true) {
						o.multidate = Number(o.multidate) || false;
						if (o.multidate !== false) o.multidate = Math.max(0, o.multidate);
					}

					o.multidateSeparator = String(o.multidateSeparator);
					o.weekStart %= 7;
					o.weekEnd = (o.weekStart + 6) % 7;
					var format = DPGlobal.parseFormat(o.format);

					if (o.startDate !== -Infinity) {
						if (!!o.startDate) {
							if (o.startDate instanceof Date) o.startDate = this._local_to_utc(this._zero_time(o.startDate)); else o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
						} else {
							o.startDate = -Infinity;
						}
					}

					if (o.endDate !== Infinity) {
						if (!!o.endDate) {
							if (o.endDate instanceof Date) o.endDate = this._local_to_utc(this._zero_time(o.endDate)); else o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
						} else {
							o.endDate = Infinity;
						}
					}

					o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled || []);
					o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted || []);
					o.datesDisabled = o.datesDisabled || [];

					if (!$.isArray(o.datesDisabled)) {
						o.datesDisabled = o.datesDisabled.split(',');
					}

					o.datesDisabled = $.map(o.datesDisabled, function (d) {
						return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
					});

					var plc = String(o.orientation).toLowerCase().split(/\s+/g),
						_plc = o.orientation.toLowerCase();

					plc = $.grep(plc, function (word) {
						return /^auto|left|right|top|bottom$/.test(word);
					});
					o.orientation = {
						x: 'auto',
						y: 'auto'
					};
					if (!_plc || _plc === 'auto') ; // no action
					else if (plc.length === 1) {
						switch (plc[0]) {
							case 'top':
							case 'bottom':
								o.orientation.y = plc[0];
								break;

							case 'left':
							case 'right':
								o.orientation.x = plc[0];
								break;
						}
					} else {
						_plc = $.grep(plc, function (word) {
							return /^left|right$/.test(word);
						});
						o.orientation.x = _plc[0] || 'auto';
						_plc = $.grep(plc, function (word) {
							return /^top|bottom$/.test(word);
						});
						o.orientation.y = _plc[0] || 'auto';
					}

					if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
						o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
					} else if (o.defaultViewDate) {
						var year = o.defaultViewDate.year || new Date().getFullYear();
						var month = o.defaultViewDate.month || 0;
						var day = o.defaultViewDate.day || 1;
						o.defaultViewDate = UTCDate(year, month, day);
					} else {
						o.defaultViewDate = UTCToday();
					}
				},
				_applyEvents: function _applyEvents(evs) {
					for (var i = 0, el, ch, ev; i < evs.length; i++) {
						el = evs[i][0];

						if (evs[i].length === 2) {
							ch = undefined;
							ev = evs[i][1];
						} else if (evs[i].length === 3) {
							ch = evs[i][1];
							ev = evs[i][2];
						}

						el.on(ev, ch);
					}
				},
				_unapplyEvents: function _unapplyEvents(evs) {
					for (var i = 0, el, ev, ch; i < evs.length; i++) {
						el = evs[i][0];

						if (evs[i].length === 2) {
							ch = undefined;
							ev = evs[i][1];
						} else if (evs[i].length === 3) {
							ch = evs[i][1];
							ev = evs[i][2];
						}

						el.off(ev, ch);
					}
				},
				_buildEvents: function _buildEvents() {
					var events = {
						keyup: $.proxy(function (e) {
							if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1) this.update();
						}, this),
						keydown: $.proxy(this.keydown, this),
						paste: $.proxy(this.paste, this)
					};

					if (this.o.showOnFocus === true) {
						events.focus = $.proxy(this.show, this);
					}

					if (this.isInput) {
						// single input
						this._events = [[this.element, events]];
					} // component: input + button
					else if (this.component && this.inputField.length) {
						this._events = [// For components that are not readonly, allow keyboard nav
							[this.inputField, events], [this.component, {
								click: $.proxy(this.show, this)
							}]];
					} else {
						this._events = [[this.element, {
							click: $.proxy(this.show, this),
							keydown: $.proxy(this.keydown, this)
						}]];
					}

					this._events.push( // Component: listen for blur on element descendants
						[this.element, '*', {
							blur: $.proxy(function (e) {
								this._focused_from = e.target;
							}, this)
						}], // Input: listen for blur on element
						[this.element, {
							blur: $.proxy(function (e) {
								this._focused_from = e.target;
							}, this)
						}]);

					if (this.o.immediateUpdates) {
						// Trigger input updates immediately on changed year/month
						this._events.push([this.element, {
							'changeYear changeMonth': $.proxy(function (e) {
								this.update(e.date);
							}, this)
						}]);
					}

					this._secondaryEvents = [[this.picker, {
						click: $.proxy(this.click, this)
					}], [this.picker, '.prev, .next', {
						click: $.proxy(this.navArrowsClick, this)
					}], [this.picker, '.day:not(.disabled)', {
						click: $.proxy(this.dayCellClick, this)
					}], [$(window), {
						resize: $.proxy(this.place, this)
					}], [$(document), {
						'mousedown touchstart': $.proxy(function (e) {
							// Clicked outside the datepicker, hide it
							if (!(this.element.is(e.target) || this.element.find(e.target).length || this.picker.is(e.target) || this.picker.find(e.target).length || this.isInline)) {
								this.hide();
							}
						}, this)
					}]];
				},
				_attachEvents: function _attachEvents() {
					this._detachEvents();

					this._applyEvents(this._events);
				},
				_detachEvents: function _detachEvents() {
					this._unapplyEvents(this._events);
				},
				_attachSecondaryEvents: function _attachSecondaryEvents() {
					this._detachSecondaryEvents();

					this._applyEvents(this._secondaryEvents);
				},
				_detachSecondaryEvents: function _detachSecondaryEvents() {
					this._unapplyEvents(this._secondaryEvents);
				},
				_trigger: function _trigger(event, altdate) {
					var date = altdate || this.dates.get(-1),
						local_date = this._utc_to_local(date);

					this.element.trigger({
						type: event,
						date: local_date,
						viewMode: this.viewMode,
						dates: $.map(this.dates, this._utc_to_local),
						format: $.proxy(function (ix, format) {
							if (arguments.length === 0) {
								ix = this.dates.length - 1;
								format = this.o.format;
							} else if (typeof ix === 'string') {
								format = ix;
								ix = this.dates.length - 1;
							}

							format = format || this.o.format;
							var date = this.dates.get(ix);
							return DPGlobal.formatDate(date, format, this.o.language);
						}, this)
					});
				},
				show: function show() {
					if (this.inputField.is(':disabled') || this.inputField.prop('readonly') && this.o.enableOnReadonly === false) return;
					if (!this.isInline) this.picker.appendTo(this.o.container);
					this.place();
					this.picker.show();

					this._attachSecondaryEvents();

					this._trigger('show');

					if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
						$(this.element).blur();
					}

					return this;
				},
				hide: function hide() {
					if (this.isInline || !this.picker.is(':visible')) return this;
					this.focusDate = null;
					this.picker.hide().detach();

					this._detachSecondaryEvents();

					this.setViewMode(this.o.startView);
					if (this.o.forceParse && this.inputField.val()) this.setValue();

					this._trigger('hide');

					return this;
				},
				destroy: function destroy() {
					this.hide();

					this._detachEvents();

					this._detachSecondaryEvents();

					this.picker.remove();
					delete this.element.data().datepicker;

					if (!this.isInput) {
						delete this.element.data().date;
					}

					return this;
				},
				paste: function paste(e) {
					var dateString;

					if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types && $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
						dateString = e.originalEvent.clipboardData.getData('text/plain');
					} else if (window.clipboardData) {
						dateString = window.clipboardData.getData('Text');
					} else {
						return;
					}

					this.setDate(dateString);
					this.update();
					e.preventDefault();
				},
				_utc_to_local: function _utc_to_local(utc) {
					if (!utc) {
						return utc;
					}

					var local = new Date(utc.getTime() + utc.getTimezoneOffset() * 60000);

					if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
						local = new Date(utc.getTime() + local.getTimezoneOffset() * 60000);
					}

					return local;
				},
				_local_to_utc: function _local_to_utc(local) {
					return local && new Date(local.getTime() - local.getTimezoneOffset() * 60000);
				},
				_zero_time: function _zero_time(local) {
					return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
				},
				_zero_utc_time: function _zero_utc_time(utc) {
					return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
				},
				getDates: function getDates() {
					return $.map(this.dates, this._utc_to_local);
				},
				getUTCDates: function getUTCDates() {
					return $.map(this.dates, function (d) {
						return new Date(d);
					});
				},
				getDate: function getDate() {
					return this._utc_to_local(this.getUTCDate());
				},
				getUTCDate: function getUTCDate() {
					var selected_date = this.dates.get(-1);

					if (selected_date !== undefined) {
						return new Date(selected_date);
					} else {
						return null;
					}
				},
				clearDates: function clearDates() {
					this.inputField.val('');
					this.update();

					this._trigger('changeDate');

					if (this.o.autoclose) {
						this.hide();
					}
				},
				setDates: function setDates() {
					var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
					this.update.apply(this, args);

					this._trigger('changeDate');

					this.setValue();
					return this;
				},
				setUTCDates: function setUTCDates() {
					var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
					this.setDates.apply(this, $.map(args, this._utc_to_local));
					return this;
				},
				setDate: alias('setDates'),
				setUTCDate: alias('setUTCDates'),
				remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),
				setValue: function setValue() {
					var formatted = this.getFormattedDate();
					this.inputField.val(formatted);
					return this;
				},
				getFormattedDate: function getFormattedDate(format) {
					if (format === undefined) format = this.o.format;
					var lang = this.o.language;
					return $.map(this.dates, function (d) {
						return DPGlobal.formatDate(d, format, lang);
					}).join(this.o.multidateSeparator);
				},
				getStartDate: function getStartDate() {
					return this.o.startDate;
				},
				setStartDate: function setStartDate(startDate) {
					this._process_options({
						startDate: startDate
					});

					this.update();
					this.updateNavArrows();
					return this;
				},
				getEndDate: function getEndDate() {
					return this.o.endDate;
				},
				setEndDate: function setEndDate(endDate) {
					this._process_options({
						endDate: endDate
					});

					this.update();
					this.updateNavArrows();
					return this;
				},
				setDaysOfWeekDisabled: function setDaysOfWeekDisabled(daysOfWeekDisabled) {
					this._process_options({
						daysOfWeekDisabled: daysOfWeekDisabled
					});

					this.update();
					return this;
				},
				setDaysOfWeekHighlighted: function setDaysOfWeekHighlighted(daysOfWeekHighlighted) {
					this._process_options({
						daysOfWeekHighlighted: daysOfWeekHighlighted
					});

					this.update();
					return this;
				},
				setDatesDisabled: function setDatesDisabled(datesDisabled) {
					this._process_options({
						datesDisabled: datesDisabled
					});

					this.update();
					return this;
				},
				place: function place() {
					if (this.isInline) return this;
					var calendarWidth = this.picker.outerWidth(),
						calendarHeight = this.picker.outerHeight(),
						visualPadding = 10,
						container = $(this.o.container),
						windowWidth = container.width(),
						scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
						appendOffset = container.offset();
					var parentsZindex = [0];
					this.element.parents().each(function () {
						var itemZIndex = $(this).css('z-index');
						if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
					});
					var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
					var offset = this.component ? this.component.parent().offset() : this.element.offset();
					var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
					var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
					var left = offset.left - appendOffset.left;
					var top = offset.top - appendOffset.top;

					if (this.o.container !== 'body') {
						top += scrollTop;
					}

					this.picker.removeClass('datepicker-orient-top datepicker-orient-bottom ' + 'datepicker-orient-right datepicker-orient-left');

					if (this.o.orientation.x !== 'auto') {
						this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
						if (this.o.orientation.x === 'right') left -= calendarWidth - width;
					} // auto x orientation is best-placement: if it crosses a window
					// edge, fudge it sideways
					else {
						if (offset.left < 0) {
							// component is outside the window on the left side. Move it into visible range
							this.picker.addClass('datepicker-orient-left');
							left -= offset.left - visualPadding;
						} else if (left + calendarWidth > windowWidth) {
							// the calendar passes the widow right edge. Align it to component right side
							this.picker.addClass('datepicker-orient-right');
							left += width - calendarWidth;
						} else {
							if (this.o.rtl) {
								// Default to right
								this.picker.addClass('datepicker-orient-right');
							} else {
								// Default to left
								this.picker.addClass('datepicker-orient-left');
							}
						}
					} // auto y orientation is best-situation: top or bottom, no fudging,
					// decision based on which shows more of the calendar


					var yorient = this.o.orientation.y,
						top_overflow;

					if (yorient === 'auto') {
						top_overflow = -scrollTop + top - calendarHeight;
						yorient = top_overflow < 0 ? 'bottom' : 'top';
					}

					this.picker.addClass('datepicker-orient-' + yorient);
					if (yorient === 'top') top -= calendarHeight + parseInt(this.picker.css('padding-top')); else top += height;

					if (this.o.rtl) {
						var right = windowWidth - (left + width);
						this.picker.css({
							top: top,
							right: right,
							zIndex: zIndex
						});
					} else {
						this.picker.css({
							top: top,
							left: left,
							zIndex: zIndex
						});
					}

					return this;
				},
				_allow_update: true,
				update: function update() {
					if (!this._allow_update) return this;
					var oldDates = this.dates.copy(),
						dates = [],
						fromArgs = false;

					if (arguments.length) {
						$.each(arguments, $.proxy(function (i, date) {
							if (date instanceof Date) date = this._local_to_utc(date);
							dates.push(date);
						}, this));
						fromArgs = true;
					} else {
						dates = this.isInput ? this.element.val() : this.element.data('date') || this.inputField.val();
						if (dates && this.o.multidate) dates = dates.split(this.o.multidateSeparator); else dates = [dates];
						delete this.element.data().date;
					}

					dates = $.map(dates, $.proxy(function (date) {
						return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
					}, this));
					dates = $.grep(dates, $.proxy(function (date) {
						return !this.dateWithinRange(date) || !date;
					}, this), true);
					this.dates.replace(dates);

					if (this.o.updateViewDate) {
						if (this.dates.length) this.viewDate = new Date(this.dates.get(-1)); else if (this.viewDate < this.o.startDate) this.viewDate = new Date(this.o.startDate); else if (this.viewDate > this.o.endDate) this.viewDate = new Date(this.o.endDate); else this.viewDate = this.o.defaultViewDate;
					}

					if (fromArgs) {
						// setting date by clicking
						this.setValue();
						this.element.change();
					} else if (this.dates.length) {
						// setting date by typing
						if (String(oldDates) !== String(this.dates) && fromArgs) {
							this._trigger('changeDate');

							this.element.change();
						}
					}

					if (!this.dates.length && oldDates.length) {
						this._trigger('clearDate');

						this.element.change();
					}

					this.fill();
					return this;
				},
				fillDow: function fillDow() {
					if (this.o.showWeekDays) {
						var dowCnt = this.o.weekStart,
							html = '<tr>';

						if (this.o.calendarWeeks) {
							html += '<th class="cw">&#160;</th>';
						}

						while (dowCnt < this.o.weekStart + 7) {
							html += '<th class="dow';
							if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1) html += ' disabled';
							html += '">' + dates[this.o.language].daysMin[dowCnt++ % 7] + '</th>';
						}

						html += '</tr>';
						this.picker.find('.datepicker-days thead').append(html);
					}
				},
				fillMonths: function fillMonths() {
					var localDate = this._utc_to_local(this.viewDate);

					var html = '';
					var focused;

					for (var i = 0; i < 12; i++) {
						focused = localDate && localDate.getMonth() === i ? ' focused' : '';
						html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
					}

					this.picker.find('.datepicker-months td').html(html);
				},
				setRange: function setRange(range) {
					if (!range || !range.length) delete this.range; else this.range = $.map(range, function (d) {
						return d.valueOf();
					});
					this.fill();
				},
				getClassNames: function getClassNames(date) {
					var cls = [],
						year = this.viewDate.getUTCFullYear(),
						month = this.viewDate.getUTCMonth(),
						today = UTCToday();

					if (date.getUTCFullYear() < year || date.getUTCFullYear() === year && date.getUTCMonth() < month) {
						cls.push('old');
					} else if (date.getUTCFullYear() > year || date.getUTCFullYear() === year && date.getUTCMonth() > month) {
						cls.push('new');
					}

					if (this.focusDate && date.valueOf() === this.focusDate.valueOf()) cls.push('focused'); // Compare internal UTC date with UTC today, not local today

					if (this.o.todayHighlight && isUTCEquals(date, today)) {
						cls.push('today');
					}

					if (this.dates.contains(date) !== -1) cls.push('active');

					if (!this.dateWithinRange(date)) {
						cls.push('disabled');
					}

					if (this.dateIsDisabled(date)) {
						cls.push('disabled', 'disabled-date');
					}

					if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1) {
						cls.push('highlighted');
					}

					if (this.range) {
						if (date > this.range[0] && date < this.range[this.range.length - 1]) {
							cls.push('range');
						}

						if ($.inArray(date.valueOf(), this.range) !== -1) {
							cls.push('selected');
						}

						if (date.valueOf() === this.range[0]) {
							cls.push('range-start');
						}

						if (date.valueOf() === this.range[this.range.length - 1]) {
							cls.push('range-end');
						}
					}

					return cls;
				},
				_fill_yearsView: function _fill_yearsView(selector, cssClass, factor, year, startYear, endYear, beforeFn) {
					var html = '';
					var step = factor / 10;
					var view = this.picker.find(selector);
					var startVal = Math.floor(year / factor) * factor;
					var endVal = startVal + step * 9;
					var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
					var selected = $.map(this.dates, function (d) {
						return Math.floor(d.getUTCFullYear() / step) * step;
					});
					var classes, tooltip, before;

					for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
						classes = [cssClass];
						tooltip = null;

						if (currVal === startVal - step) {
							classes.push('old');
						} else if (currVal === endVal + step) {
							classes.push('new');
						}

						if ($.inArray(currVal, selected) !== -1) {
							classes.push('active');
						}

						if (currVal < startYear || currVal > endYear) {
							classes.push('disabled');
						}

						if (currVal === focusedVal) {
							classes.push('focused');
						}

						if (beforeFn !== $.noop) {
							before = beforeFn(new Date(currVal, 0, 1));

							if (before === undefined) {
								before = {};
							} else if (typeof before === 'boolean') {
								before = {
									enabled: before
								};
							} else if (typeof before === 'string') {
								before = {
									classes: before
								};
							}

							if (before.enabled === false) {
								classes.push('disabled');
							}

							if (before.classes) {
								classes = classes.concat(before.classes.split(/\s+/));
							}

							if (before.tooltip) {
								tooltip = before.tooltip;
							}
						}

						html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
					}

					view.find('.datepicker-switch').text(startVal + '-' + endVal);
					view.find('td').html(html);
				},
				fill: function fill() {
					var d = new Date(this.viewDate),
						year = d.getUTCFullYear(),
						month = d.getUTCMonth(),
						startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
						startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
						endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
						endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
						todaytxt = dates[this.o.language].today || dates['en'].today || '',
						cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
						titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
						todayDate = UTCToday(),
						titleBtnVisible = (this.o.todayBtn === true || this.o.todayBtn === 'linked') && todayDate >= this.o.startDate && todayDate <= this.o.endDate && !this.weekOfDateIsDisabled(todayDate),
						tooltip,
						before;
					if (isNaN(year) || isNaN(month)) return;
					this.picker.find('.datepicker-days .datepicker-switch').text(DPGlobal.formatDate(d, titleFormat, this.o.language));
					this.picker.find('tfoot .today').text(todaytxt).css('display', titleBtnVisible ? 'table-cell' : 'none');
					this.picker.find('tfoot .clear').text(cleartxt).css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
					this.picker.find('thead .datepicker-title').text(this.o.title).css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
					this.updateNavArrows();
					this.fillMonths();
					var prevMonth = UTCDate(year, month, 0),
						day = prevMonth.getUTCDate();
					prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);
					var nextMonth = new Date(prevMonth);

					if (prevMonth.getUTCFullYear() < 100) {
						nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
					}

					nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
					nextMonth = nextMonth.valueOf();
					var html = [];
					var weekDay, clsName;

					while (prevMonth.valueOf() < nextMonth) {
						weekDay = prevMonth.getUTCDay();

						if (weekDay === this.o.weekStart) {
							html.push('<tr>');

							if (this.o.calendarWeeks) {
								// ISO 8601: First week contains first thursday.
								// ISO also states week starts on Monday, but we can be more abstract here.
								var // Start of current week: based on weekstart/current date
									ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
									// Thursday of this week
									th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
									// First Thursday of year, year from thursday
									yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
									// Calendar week: ms between thursdays, div ms per day, div 7 days
									calWeek = (th - yth) / 864e5 / 7 + 1;
								html.push('<td class="cw">' + calWeek + '</td>');
							}
						}

						clsName = this.getClassNames(prevMonth);
						clsName.push('day');
						var content = prevMonth.getUTCDate();

						if (this.o.beforeShowDay !== $.noop) {
							before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
							if (before === undefined) before = {}; else if (typeof before === 'boolean') before = {
								enabled: before
							}; else if (typeof before === 'string') before = {
								classes: before
							};
							if (before.enabled === false) clsName.push('disabled');
							if (before.classes) clsName = clsName.concat(before.classes.split(/\s+/));
							if (before.tooltip) tooltip = before.tooltip;
							if (before.content) content = before.content;
						} //Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
						//Fallback to unique function for older jquery versions


						if ($.isFunction($.uniqueSort)) {
							clsName = $.uniqueSort(clsName);
						} else {
							clsName = $.unique(clsName);
						}

						html.push('<td class="' + clsName.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
						tooltip = null;

						if (weekDay === this.o.weekEnd) {
							html.push('</tr>');
						}

						prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
					}

					this.picker.find('.datepicker-days tbody').html(html.join(''));
					var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
					var months = this.picker.find('.datepicker-months').find('.datepicker-switch').text(this.o.maxViewMode < 2 ? monthsTitle : year).end().find('tbody span').removeClass('active');
					$.each(this.dates, function (i, d) {
						if (d.getUTCFullYear() === year) months.eq(d.getUTCMonth()).addClass('active');
					});

					if (year < startYear || year > endYear) {
						months.addClass('disabled');
					}

					if (year === startYear) {
						months.slice(0, startMonth).addClass('disabled');
					}

					if (year === endYear) {
						months.slice(endMonth + 1).addClass('disabled');
					}

					if (this.o.beforeShowMonth !== $.noop) {
						var that = this;
						$.each(months, function (i, month) {
							var moDate = new Date(year, i, 1);
							var before = that.o.beforeShowMonth(moDate);
							if (before === undefined) before = {}; else if (typeof before === 'boolean') before = {
								enabled: before
							}; else if (typeof before === 'string') before = {
								classes: before
							};
							if (before.enabled === false && !$(month).hasClass('disabled')) $(month).addClass('disabled');
							if (before.classes) $(month).addClass(before.classes);
							if (before.tooltip) $(month).prop('title', before.tooltip);
						});
					} // Generating decade/years picker


					this._fill_yearsView('.datepicker-years', 'year', 10, year, startYear, endYear, this.o.beforeShowYear); // Generating century/decades picker


					this._fill_yearsView('.datepicker-decades', 'decade', 100, year, startYear, endYear, this.o.beforeShowDecade); // Generating millennium/centuries picker


					this._fill_yearsView('.datepicker-centuries', 'century', 1000, year, startYear, endYear, this.o.beforeShowCentury);
				},
				updateNavArrows: function updateNavArrows() {
					if (!this._allow_update) return;
					var d = new Date(this.viewDate),
						year = d.getUTCFullYear(),
						month = d.getUTCMonth(),
						startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
						startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
						endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
						endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
						prevIsDisabled,
						nextIsDisabled,
						factor = 1;

					switch (this.viewMode) {
						case 4:
							factor *= 10;

						/* falls through */

						case 3:
							factor *= 10;

						/* falls through */

						case 2:
							factor *= 10;

						/* falls through */

						case 1:
							prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
							nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
							break;

						case 0:
							prevIsDisabled = year <= startYear && month <= startMonth;
							nextIsDisabled = year >= endYear && month >= endMonth;
							break;
					}

					this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
					this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
				},
				click: function click(e) {
					e.preventDefault();
					e.stopPropagation();
					var target, dir, day, year, month;
					target = $(e.target); // Clicked on the switch

					if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode) {
						this.setViewMode(this.viewMode + 1);
					} // Clicked on today button


					if (target.hasClass('today') && !target.hasClass('day')) {
						this.setViewMode(0);

						this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
					} // Clicked on clear button


					if (target.hasClass('clear')) {
						this.clearDates();
					}

					if (!target.hasClass('disabled')) {
						// Clicked on a month, year, decade, century
						if (target.hasClass('month') || target.hasClass('year') || target.hasClass('decade') || target.hasClass('century')) {
							this.viewDate.setUTCDate(1);
							day = 1;

							if (this.viewMode === 1) {
								month = target.parent().find('span').index(target);
								year = this.viewDate.getUTCFullYear();
								this.viewDate.setUTCMonth(month);
							} else {
								month = 0;
								year = Number(target.text());
								this.viewDate.setUTCFullYear(year);
							}

							this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

							if (this.viewMode === this.o.minViewMode) {
								this._setDate(UTCDate(year, month, day));
							} else {
								this.setViewMode(this.viewMode - 1);
								this.fill();
							}
						}
					}

					if (this.picker.is(':visible') && this._focused_from) {
						this._focused_from.focus();
					}

					delete this._focused_from;
				},
				dayCellClick: function dayCellClick(e) {
					var $target = $(e.currentTarget);
					var timestamp = $target.data('date');
					var date = new Date(timestamp);

					if (this.o.updateViewDate) {
						if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
							this._trigger('changeYear', this.viewDate);
						}

						if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
							this._trigger('changeMonth', this.viewDate);
						}
					}

					this._setDate(date);
				},
				// Clicked on prev or next
				navArrowsClick: function navArrowsClick(e) {
					var $target = $(e.currentTarget);
					var dir = $target.hasClass('prev') ? -1 : 1;

					if (this.viewMode !== 0) {
						dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
					}

					this.viewDate = this.moveMonth(this.viewDate, dir);

					this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);

					this.fill();
				},
				_toggle_multidate: function _toggle_multidate(date) {
					var ix = this.dates.contains(date);

					if (!date) {
						this.dates.clear();
					}

					if (ix !== -1) {
						if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive) {
							this.dates.remove(ix);
						}
					} else if (this.o.multidate === false) {
						this.dates.clear();
						this.dates.push(date);
					} else {
						this.dates.push(date);
					}

					if (typeof this.o.multidate === 'number') while (this.dates.length > this.o.multidate) {
						this.dates.remove(0);
					}
				},
				_setDate: function _setDate(date, which) {
					if (!which || which === 'date') this._toggle_multidate(date && new Date(date));
					if (!which && this.o.updateViewDate || which === 'view') this.viewDate = date && new Date(date);
					this.fill();
					this.setValue();

					if (!which || which !== 'view') {
						this._trigger('changeDate');
					}

					this.inputField.trigger('change');

					if (this.o.autoclose && (!which || which === 'date')) {
						this.hide();
					}
				},
				moveDay: function moveDay(date, dir) {
					var newDate = new Date(date);
					newDate.setUTCDate(date.getUTCDate() + dir);
					return newDate;
				},
				moveWeek: function moveWeek(date, dir) {
					return this.moveDay(date, dir * 7);
				},
				moveMonth: function moveMonth(date, dir) {
					if (!isValidDate(date)) return this.o.defaultViewDate;
					if (!dir) return date;
					var new_date = new Date(date.valueOf()),
						day = new_date.getUTCDate(),
						month = new_date.getUTCMonth(),
						mag = Math.abs(dir),
						new_month,
						test;
					dir = dir > 0 ? 1 : -1;

					if (mag === 1) {
						test = dir === -1 // If going back one month, make sure month is not current month
							// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
							? function () {
								return new_date.getUTCMonth() === month;
							} // If going forward one month, make sure month is as expected
							// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
							: function () {
								return new_date.getUTCMonth() !== new_month;
							};
						new_month = month + dir;
						new_date.setUTCMonth(new_month); // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11

						new_month = (new_month + 12) % 12;
					} else {
						// For magnitudes >1, move one month at a time...
						for (var i = 0; i < mag; i++) {
							// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
							new_date = this.moveMonth(new_date, dir);
						} // ...then reset the day, keeping it in the new month


						new_month = new_date.getUTCMonth();
						new_date.setUTCDate(day);

						test = function test() {
							return new_month !== new_date.getUTCMonth();
						};
					} // Common date-resetting loop -- if date is beyond end of month, make it
					// end of month


					while (test()) {
						new_date.setUTCDate(--day);
						new_date.setUTCMonth(new_month);
					}

					return new_date;
				},
				moveYear: function moveYear(date, dir) {
					return this.moveMonth(date, dir * 12);
				},
				moveAvailableDate: function moveAvailableDate(date, dir, fn) {
					do {
						date = this[fn](date, dir);
						if (!this.dateWithinRange(date)) return false;
						fn = 'moveDay';
					} while (this.dateIsDisabled(date));

					return date;
				},
				weekOfDateIsDisabled: function weekOfDateIsDisabled(date) {
					return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
				},
				dateIsDisabled: function dateIsDisabled(date) {
					return this.weekOfDateIsDisabled(date) || $.grep(this.o.datesDisabled, function (d) {
						return isUTCEquals(date, d);
					}).length > 0;
				},
				dateWithinRange: function dateWithinRange(date) {
					return date >= this.o.startDate && date <= this.o.endDate;
				},
				keydown: function keydown(e) {
					if (!this.picker.is(':visible')) {
						if (e.keyCode === 40 || e.keyCode === 27) {
							// allow down to re-show picker
							this.show();
							e.stopPropagation();
						}

						return;
					}

					var dateChanged = false,
						dir,
						newViewDate,
						focusDate = this.focusDate || this.viewDate;

					switch (e.keyCode) {
						case 27:
							// escape
							if (this.focusDate) {
								this.focusDate = null;
								this.viewDate = this.dates.get(-1) || this.viewDate;
								this.fill();
							} else this.hide();

							e.preventDefault();
							e.stopPropagation();
							break;

						case 37: // left

						case 38: // up

						case 39: // right

						case 40:
							// down
							if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7) break;
							dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;

							if (this.viewMode === 0) {
								if (e.ctrlKey) {
									newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
									if (newViewDate) this._trigger('changeYear', this.viewDate);
								} else if (e.shiftKey) {
									newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
									if (newViewDate) this._trigger('changeMonth', this.viewDate);
								} else if (e.keyCode === 37 || e.keyCode === 39) {
									newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
								} else if (!this.weekOfDateIsDisabled(focusDate)) {
									newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
								}
							} else if (this.viewMode === 1) {
								if (e.keyCode === 38 || e.keyCode === 40) {
									dir = dir * 4;
								}

								newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
							} else if (this.viewMode === 2) {
								if (e.keyCode === 38 || e.keyCode === 40) {
									dir = dir * 4;
								}

								newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
							}

							if (newViewDate) {
								this.focusDate = this.viewDate = newViewDate;
								this.setValue();
								this.fill();
								e.preventDefault();
							}

							break;

						case 13:
							// enter
							if (!this.o.forceParse) break;
							focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;

							if (this.o.keyboardNavigation) {
								this._toggle_multidate(focusDate);

								dateChanged = true;
							}

							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.setValue();
							this.fill();

							if (this.picker.is(':visible')) {
								e.preventDefault();
								e.stopPropagation();
								if (this.o.autoclose) this.hide();
							}

							break;

						case 9:
							// tab
							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.fill();
							this.hide();
							break;
					}

					if (dateChanged) {
						if (this.dates.length) this._trigger('changeDate'); else this._trigger('clearDate');
						this.inputField.trigger('change');
					}
				},
				setViewMode: function setViewMode(viewMode) {
					this.viewMode = viewMode;
					this.picker.children('div').hide().filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName).show();
					this.updateNavArrows();

					this._trigger('changeViewMode', new Date(this.viewDate));
				}
			};

			var DateRangePicker = function DateRangePicker(element, options) {
				$.data(element, 'datepicker', this);
				this.element = $(element);
				this.inputs = $.map(options.inputs, function (i) {
					return i.jquery ? i[0] : i;
				});
				delete options.inputs;
				this.keepEmptyValues = options.keepEmptyValues;
				delete options.keepEmptyValues;
				datepickerPlugin.call($(this.inputs), options).on('changeDate', $.proxy(this.dateUpdated, this));
				this.pickers = $.map(this.inputs, function (i) {
					return $.data(i, 'datepicker');
				});
				this.updateDates();
			};

			DateRangePicker.prototype = {
				updateDates: function updateDates() {
					this.dates = $.map(this.pickers, function (i) {
						return i.getUTCDate();
					});
					this.updateRanges();
				},
				updateRanges: function updateRanges() {
					var range = $.map(this.dates, function (d) {
						return d.valueOf();
					});
					$.each(this.pickers, function (i, p) {
						p.setRange(range);
					});
				},
				clearDates: function clearDates() {
					$.each(this.pickers, function (i, p) {
						p.clearDates();
					});
				},
				dateUpdated: function dateUpdated(e) {
					// `this.updating` is a workaround for preventing infinite recursion
					// between `changeDate` triggering and `setUTCDate` calling.  Until
					// there is a better mechanism.
					if (this.updating) return;
					this.updating = true;
					var dp = $.data(e.target, 'datepicker');

					if (dp === undefined) {
						return;
					}

					var new_date = dp.getUTCDate(),
						keep_empty_values = this.keepEmptyValues,
						i = $.inArray(e.target, this.inputs),
						j = i - 1,
						k = i + 1,
						l = this.inputs.length;
					if (i === -1) return;
					$.each(this.pickers, function (i, p) {
						if (!p.getUTCDate() && (p === dp || !keep_empty_values)) p.setUTCDate(new_date);
					});

					if (new_date < this.dates[j]) {
						// Date being moved earlier/left
						while (j >= 0 && new_date < this.dates[j]) {
							this.pickers[j--].setUTCDate(new_date);
						}
					} else if (new_date > this.dates[k]) {
						// Date being moved later/right
						while (k < l && new_date > this.dates[k]) {
							this.pickers[k++].setUTCDate(new_date);
						}
					}

					this.updateDates();
					delete this.updating;
				},
				destroy: function destroy() {
					$.map(this.pickers, function (p) {
						p.destroy();
					});
					$(this.inputs).off('changeDate', this.dateUpdated);
					delete this.element.data().datepicker;
				},
				remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
			};

			function opts_from_el(el, prefix) {
				// Derive options from element data-attrs
				var data = $(el).data(),
					out = {},
					inkey,
					replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
				prefix = new RegExp('^' + prefix.toLowerCase());

				function re_lower(_, a) {
					return a.toLowerCase();
				}

				for (var key in data) {
					if (prefix.test(key)) {
						inkey = key.replace(replace, re_lower);
						out[inkey] = data[key];
					}
				}

				return out;
			}

			function opts_from_locale(lang) {
				// Derive options from locale plugins
				var out = {}; // Check if "de-DE" style date is available, if not language should
				// fallback to 2 letter code eg "de"

				if (!dates[lang]) {
					lang = lang.split('-')[0];
					if (!dates[lang]) return;
				}

				var d = dates[lang];
				$.each(locale_opts, function (i, k) {
					if (k in d) out[k] = d[k];
				});
				return out;
			}

			var old = $.fn.datepicker;

			var datepickerPlugin = function datepickerPlugin(option) {
				var args = Array.apply(null, arguments);
				args.shift();
				var internal_return;
				this.each(function () {
					var $this = $(this),
						data = $this.data('datepicker'),
						options = _typeof(option) === 'object' && option;

					if (!data) {
						var elopts = opts_from_el(this, 'date'),
							// Preliminary otions
							xopts = $.extend({}, defaults, elopts, options),
							locopts = opts_from_locale(xopts.language),
							// Options priority: js args, data-attrs, locales, defaults
							opts = $.extend({}, defaults, locopts, elopts, options);

						if ($this.hasClass('input-daterange') || opts.inputs) {
							$.extend(opts, {
								inputs: opts.inputs || $this.find('input').toArray()
							});
							data = new DateRangePicker(this, opts);
						} else {
							data = new Datepicker(this, opts);
						}

						$this.data('datepicker', data);
					}

					if (typeof option === 'string' && typeof data[option] === 'function') {
						internal_return = data[option].apply(data, args);
					}
				});
				if (internal_return === undefined || internal_return instanceof Datepicker || internal_return instanceof DateRangePicker) return this;
				if (this.length > 1) throw new Error('Using only allowed for the collection of a single element (' + option + ' function)'); else return internal_return;
			};

			$.fn.datepicker = datepickerPlugin;
			var defaults = $.fn.datepicker.defaults = {
				assumeNearbyYear: false,
				autoclose: false,
				beforeShowDay: $.noop,
				beforeShowMonth: $.noop,
				beforeShowYear: $.noop,
				beforeShowDecade: $.noop,
				beforeShowCentury: $.noop,
				calendarWeeks: false,
				clearBtn: false,
				toggleActive: false,
				daysOfWeekDisabled: [],
				daysOfWeekHighlighted: [],
				datesDisabled: [],
				endDate: Infinity,
				forceParse: true,
				format: 'mm/dd/yyyy',
				keepEmptyValues: false,
				keyboardNavigation: true,
				language: 'en',
				minViewMode: 0,
				maxViewMode: 4,
				multidate: false,
				multidateSeparator: ',',
				orientation: "auto",
				rtl: false,
				startDate: -Infinity,
				startView: 0,
				todayBtn: false,
				todayHighlight: false,
				updateViewDate: true,
				weekStart: 0,
				disableTouchKeyboard: false,
				enableOnReadonly: true,
				showOnFocus: true,
				zIndexOffset: 10,
				container: 'body',
				immediateUpdates: false,
				title: '',
				templates: {
					leftArrow: '&#x00AB;',
					rightArrow: '&#x00BB;'
				},
				showWeekDays: true
			};
			var locale_opts = $.fn.datepicker.locale_opts = ['format', 'rtl', 'weekStart'];
			$.fn.datepicker.Constructor = Datepicker;
			var dates = $.fn.datepicker.dates = {
				en: {
					days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
					daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
					daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
					months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
					monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
					today: "Today",
					clear: "Clear",
					titleFormat: "MM yyyy"
				}
			};
			var DPGlobal = {
				viewModes: [{
					names: ['days', 'month'],
					clsName: 'days',
					e: 'changeMonth'
				}, {
					names: ['months', 'year'],
					clsName: 'months',
					e: 'changeYear',
					navStep: 1
				}, {
					names: ['years', 'decade'],
					clsName: 'years',
					e: 'changeDecade',
					navStep: 10
				}, {
					names: ['decades', 'century'],
					clsName: 'decades',
					e: 'changeCentury',
					navStep: 100
				}, {
					names: ['centuries', 'millennium'],
					clsName: 'centuries',
					e: 'changeMillennium',
					navStep: 1000
				}],
				validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
				nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
				parseFormat: function parseFormat(format) {
					if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function') return format; // IE treats \0 as a string end in inputs (truncating the value),
					// so it's a bad format delimiter, anyway

					var separators = format.replace(this.validParts, '\0').split('\0'),
						parts = format.match(this.validParts);

					if (!separators || !separators.length || !parts || parts.length === 0) {
						throw new Error("Invalid date format.");
					}

					return {
						separators: separators,
						parts: parts
					};
				},
				parseDate: function parseDate(date, format, language, assumeNearby) {
					if (!date) return undefined;
					if (date instanceof Date) return date;
					if (typeof format === 'string') format = DPGlobal.parseFormat(format);
					if (format.toValue) return format.toValue(date, format, language);
					var fn_map = {
							d: 'moveDay',
							m: 'moveMonth',
							w: 'moveWeek',
							y: 'moveYear'
						},
						dateAliases = {
							yesterday: '-1d',
							today: '+0d',
							tomorrow: '+1d'
						},
						parts,
						part,
						dir,
						i,
						fn;

					if (date in dateAliases) {
						date = dateAliases[date];
					}

					if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)) {
						parts = date.match(/([\-+]\d+)([dmwy])/gi);
						date = new Date();

						for (i = 0; i < parts.length; i++) {
							part = parts[i].match(/([\-+]\d+)([dmwy])/i);
							dir = Number(part[1]);
							fn = fn_map[part[2].toLowerCase()];
							date = Datepicker.prototype[fn](date, dir);
						}

						return Datepicker.prototype._zero_utc_time(date);
					}

					parts = date && date.match(this.nonpunctuation) || [];

					function applyNearbyYear(year, threshold) {
						if (threshold === true) threshold = 10; // if year is 2 digits or less, than the user most likely is trying to get a recent century

						if (year < 100) {
							year += 2000; // if the new year is more than threshold years in advance, use last century

							if (year > new Date().getFullYear() + threshold) {
								year -= 100;
							}
						}

						return year;
					}

					var parsed = {},
						setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
						setters_map = {
							yyyy: function yyyy(d, v) {
								return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
							},
							m: function m(d, v) {
								if (isNaN(d)) return d;
								v -= 1;

								while (v < 0) {
									v += 12;
								}

								v %= 12;
								d.setUTCMonth(v);

								while (d.getUTCMonth() !== v) {
									d.setUTCDate(d.getUTCDate() - 1);
								}

								return d;
							},
							d: function d(_d, v) {
								return _d.setUTCDate(v);
							}
						},
						val,
						filtered;
					setters_map['yy'] = setters_map['yyyy'];
					setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
					setters_map['dd'] = setters_map['d'];
					date = UTCToday();
					var fparts = format.parts.slice(); // Remove noop parts

					if (parts.length !== fparts.length) {
						fparts = $(fparts).filter(function (i, p) {
							return $.inArray(p, setters_order) !== -1;
						}).toArray();
					} // Process remainder


					function match_part() {
						var m = this.slice(0, parts[i].length),
							p = parts[i].slice(0, m.length);
						return m.toLowerCase() === p.toLowerCase();
					}

					if (parts.length === fparts.length) {
						var cnt;

						for (i = 0, cnt = fparts.length; i < cnt; i++) {
							val = parseInt(parts[i], 10);
							part = fparts[i];

							if (isNaN(val)) {
								switch (part) {
									case 'MM':
										filtered = $(dates[language].months).filter(match_part);
										val = $.inArray(filtered[0], dates[language].months) + 1;
										break;

									case 'M':
										filtered = $(dates[language].monthsShort).filter(match_part);
										val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
										break;
								}
							}

							parsed[part] = val;
						}

						var _date, s;

						for (i = 0; i < setters_order.length; i++) {
							s = setters_order[i];

							if (s in parsed && !isNaN(parsed[s])) {
								_date = new Date(date);
								setters_map[s](_date, parsed[s]);
								if (!isNaN(_date)) date = _date;
							}
						}
					}

					return date;
				},
				formatDate: function formatDate(date, format, language) {
					if (!date) return '';
					if (typeof format === 'string') format = DPGlobal.parseFormat(format);
					if (format.toDisplay) return format.toDisplay(date, format, language);
					var val = {
						d: date.getUTCDate(),
						D: dates[language].daysShort[date.getUTCDay()],
						DD: dates[language].days[date.getUTCDay()],
						m: date.getUTCMonth() + 1,
						M: dates[language].monthsShort[date.getUTCMonth()],
						MM: dates[language].months[date.getUTCMonth()],
						yy: date.getUTCFullYear().toString().substring(2),
						yyyy: date.getUTCFullYear()
					};
					val.dd = (val.d < 10 ? '0' : '') + val.d;
					val.mm = (val.m < 10 ? '0' : '') + val.m;
					date = [];
					var seps = $.extend([], format.separators);

					for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {
						if (seps.length) date.push(seps.shift());
						date.push(val[format.parts[i]]);
					}

					return date.join('');
				},
				headTemplate: '<thead>' + '<tr>' + '<th colspan="7" class="datepicker-title"></th>' + '</tr>' + '<tr>' + '<th class="prev">' + defaults.templates.leftArrow + '</th>' + '<th colspan="5" class="datepicker-switch"></th>' + '<th class="next">' + defaults.templates.rightArrow + '</th>' + '</tr>' + '</thead>',
				contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
				footTemplate: '<tfoot>' + '<tr>' + '<th colspan="7" class="today"></th>' + '</tr>' + '<tr>' + '<th colspan="7" class="clear"></th>' + '</tr>' + '</tfoot>'
			};
			DPGlobal.template = '<div class="datepicker">' + '<div class="datepicker-days">' + '<table class="table-condensed">' + DPGlobal.headTemplate + '<tbody></tbody>' + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-months">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-years">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-decades">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class="datepicker-centuries">' + '<table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '</div>';
			$.fn.datepicker.DPGlobal = DPGlobal;
			/* DATEPICKER NO CONFLICT
  * =================== */

			$.fn.datepicker.noConflict = function () {
				$.fn.datepicker = old;
				return this;
			};
			/* DATEPICKER VERSION
   * =================== */


			$.fn.datepicker.version = '1.9.0';

			$.fn.datepicker.deprecated = function (msg) {
				var console = window.console;

				if (console && console.warn) {
					console.warn('DEPRECATED: ' + msg);
				}
			};
			/* DATEPICKER DATA-API
  * ================== */


			$(document).on('focus.datepicker.data-api click.datepicker.data-api', '[data-provide="datepicker"]', function (e) {
				var $this = $(this);
				if ($this.data('datepicker')) return;
				e.preventDefault(); // component click requires us to explicitly show it

				datepickerPlugin.call($this, 'show');
			});
			$(function () {
				datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
			});
		});

		/***/
	}),
	/* 12 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*!
 * Bootstrap-select v1.13.18 (https://developer.snapappointments.com/bootstrap-select)
 *
 * Copyright 2012-2020 SnapAppointments, LLC
 * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)
 */
		(function (root, factory) {
			if (root === undefined && window !== undefined) root = window;

			if (true) {
				// AMD. Register as an anonymous module unless amdModuleId is set
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (a0) {
					return factory(a0);
				}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(this, function (jQuery) {
			(function ($) {
				'use strict';

				var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
				var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
				var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
				var DefaultWhitelist = {
					// Global attributes allowed on any supplied element below.
					'*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],
					a: ['target', 'href', 'title', 'rel'],
					area: [],
					b: [],
					br: [],
					col: [],
					code: [],
					div: [],
					em: [],
					hr: [],
					h1: [],
					h2: [],
					h3: [],
					h4: [],
					h5: [],
					h6: [],
					i: [],
					img: ['src', 'alt', 'title', 'width', 'height'],
					li: [],
					ol: [],
					p: [],
					pre: [],
					s: [],
					small: [],
					span: [],
					sub: [],
					sup: [],
					strong: [],
					u: [],
					ul: []
				};
				/**
				 * A pattern that recognizes a commonly useful subset of URLs that are safe.
				 *
				 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
				 */

				var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
				/**
				 * A pattern that matches safe data URLs. Only matches image, video and audio types.
				 *
				 * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
				 */

				var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

				function allowedAttribute(attr, allowedAttributeList) {
					var attrName = attr.nodeName.toLowerCase();

					if ($.inArray(attrName, allowedAttributeList) !== -1) {
						if ($.inArray(attrName, uriAttrs) !== -1) {
							return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
						}

						return true;
					}

					var regExp = $(allowedAttributeList).filter(function (index, value) {
						return value instanceof RegExp;
					}); // Check if a regular expression validates the attribute.

					for (var i = 0, l = regExp.length; i < l; i++) {
						if (attrName.match(regExp[i])) {
							return true;
						}
					}

					return false;
				}

				function sanitizeHtml(unsafeElements, whiteList, sanitizeFn) {
					if (sanitizeFn && typeof sanitizeFn === 'function') {
						return sanitizeFn(unsafeElements);
					}

					var whitelistKeys = Object.keys(whiteList);

					for (var i = 0, len = unsafeElements.length; i < len; i++) {
						var elements = unsafeElements[i].querySelectorAll('*');

						for (var j = 0, len2 = elements.length; j < len2; j++) {
							var el = elements[j];
							var elName = el.nodeName.toLowerCase();

							if (whitelistKeys.indexOf(elName) === -1) {
								el.parentNode.removeChild(el);
								continue;
							}

							var attributeList = [].slice.call(el.attributes);
							var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);

							for (var k = 0, len3 = attributeList.length; k < len3; k++) {
								var attr = attributeList[k];

								if (!allowedAttribute(attr, whitelistedAttributes)) {
									el.removeAttribute(attr.nodeName);
								}
							}
						}
					}
				} // Polyfill for browsers with no classList support
				// Remove in v2


				if (!('classList' in document.createElement('_'))) {
					(function (view) {
						if (!('Element' in view)) return;

						var classListProp = 'classList',
							protoProp = 'prototype',
							elemCtrProto = view.Element[protoProp],
							objCtr = Object,
							classListGetter = function classListGetter() {
								var $elem = $(this);
								return {
									add: function add(classes) {
										classes = Array.prototype.slice.call(arguments).join(' ');
										return $elem.addClass(classes);
									},
									remove: function remove(classes) {
										classes = Array.prototype.slice.call(arguments).join(' ');
										return $elem.removeClass(classes);
									},
									toggle: function toggle(classes, force) {
										return $elem.toggleClass(classes, force);
									},
									contains: function contains(classes) {
										return $elem.hasClass(classes);
									}
								};
							};

						if (objCtr.defineProperty) {
							var classListPropDesc = {
								get: classListGetter,
								enumerable: true,
								configurable: true
							};

							try {
								objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
							} catch (ex) {
								// IE 8 doesn't support enumerable:true
								// adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
								// modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
								if (ex.number === undefined || ex.number === -0x7FF5EC54) {
									classListPropDesc.enumerable = false;
									objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
								}
							}
						} else if (objCtr[protoProp].__defineGetter__) {
							elemCtrProto.__defineGetter__(classListProp, classListGetter);
						}
					})(window);
				}

				var testElement = document.createElement('_');
				testElement.classList.add('c1', 'c2');

				if (!testElement.classList.contains('c2')) {
					var _add = DOMTokenList.prototype.add,
						_remove = DOMTokenList.prototype.remove;

					DOMTokenList.prototype.add = function () {
						Array.prototype.forEach.call(arguments, _add.bind(this));
					};

					DOMTokenList.prototype.remove = function () {
						Array.prototype.forEach.call(arguments, _remove.bind(this));
					};
				}

				testElement.classList.toggle('c3', false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
				// support the second argument.

				if (testElement.classList.contains('c3')) {
					var _toggle = DOMTokenList.prototype.toggle;

					DOMTokenList.prototype.toggle = function (token, force) {
						if (1 in arguments && !this.contains(token) === !force) {
							return force;
						} else {
							return _toggle.call(this, token);
						}
					};
				}

				testElement = null; // shallow array comparison

				function isEqual(array1, array2) {
					return array1.length === array2.length && array1.every(function (element, index) {
						return element === array2[index];
					});
				}

				; // <editor-fold desc="Shims">

				if (!String.prototype.startsWith) {
					(function () {
						'use strict'; // needed to support `apply`/`call` with `undefined`/`null`

						var defineProperty = function () {
							// IE 8 only supports `Object.defineProperty` on DOM elements
							try {
								var object = {};
								var $defineProperty = Object.defineProperty;
								var result = $defineProperty(object, object, object) && $defineProperty;
							} catch (error) {
							}

							return result;
						}();

						var toString = {}.toString;

						var startsWith = function startsWith(search) {
							if (this == null) {
								throw new TypeError();
							}

							var string = String(this);

							if (search && toString.call(search) == '[object RegExp]') {
								throw new TypeError();
							}

							var stringLength = string.length;
							var searchString = String(search);
							var searchLength = searchString.length;
							var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger`

							var pos = position ? Number(position) : 0;

							if (pos != pos) {
								// better `isNaN`
								pos = 0;
							}

							var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible

							if (searchLength + start > stringLength) {
								return false;
							}

							var index = -1;

							while (++index < searchLength) {
								if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
									return false;
								}
							}

							return true;
						};

						if (defineProperty) {
							defineProperty(String.prototype, 'startsWith', {
								'value': startsWith,
								'configurable': true,
								'writable': true
							});
						} else {
							String.prototype.startsWith = startsWith;
						}
					})();
				}

				if (!Object.keys) {
					Object.keys = function (o, // object
											k, // key
											r // result array
					) {
						// initialize object and result
						r = []; // iterate over object keys

						for (k in o) {
							// fill result array with non-prototypical keys
							r.hasOwnProperty.call(o, k) && r.push(k);
						} // return result


						return r;
					};
				}

				if (HTMLSelectElement && !HTMLSelectElement.prototype.hasOwnProperty('selectedOptions')) {
					Object.defineProperty(HTMLSelectElement.prototype, 'selectedOptions', {
						get: function get() {
							return this.querySelectorAll(':checked');
						}
					});
				}

				function getSelectedOptions(select, ignoreDisabled) {
					var selectedOptions = select.selectedOptions,
						options = [],
						opt;

					if (ignoreDisabled) {
						for (var i = 0, len = selectedOptions.length; i < len; i++) {
							opt = selectedOptions[i];

							if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {
								options.push(opt);
							}
						}

						return options;
					}

					return selectedOptions;
				} // much faster than $.val()


				function getSelectValues(select, selectedOptions) {
					var value = [],
						options = selectedOptions || select.selectedOptions,
						opt;

					for (var i = 0, len = options.length; i < len; i++) {
						opt = options[i];

						if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {
							value.push(opt.value);
						}
					}

					if (!select.multiple) {
						return !value.length ? null : value[0];
					}

					return value;
				} // set data-selected on select element if the value has been programmatically selected
				// prior to initialization of bootstrap-select
				// * consider removing or replacing an alternative method *


				var valHooks = {
					useDefault: false,
					_set: $.valHooks.select.set
				};

				$.valHooks.select.set = function (elem, value) {
					if (value && !valHooks.useDefault) $(elem).data('selected', true);
					return valHooks._set.apply(this, arguments);
				};

				var changedArguments = null;

				var EventIsSupported = function () {
					try {
						new Event('change');
						return true;
					} catch (e) {
						return false;
					}
				}();

				$.fn.triggerNative = function (eventName) {
					var el = this[0],
						event;

					if (el.dispatchEvent) {
						// for modern browsers & IE9+
						if (EventIsSupported) {
							// For modern browsers
							event = new Event(eventName, {
								bubbles: true
							});
						} else {
							// For IE since it doesn't support Event constructor
							event = document.createEvent('Event');
							event.initEvent(eventName, true, false);
						}

						el.dispatchEvent(event);
					} else if (el.fireEvent) {
						// for IE8
						event = document.createEventObject();
						event.eventType = eventName;
						el.fireEvent('on' + eventName, event);
					} else {
						// fall back to jQuery.trigger
						this.trigger(eventName);
					}
				}; // </editor-fold>


				function stringSearch(li, searchString, method, normalize) {
					var stringTypes = ['display', 'subtext', 'tokens'],
						searchSuccess = false;

					for (var i = 0; i < stringTypes.length; i++) {
						var stringType = stringTypes[i],
							string = li[stringType];

						if (string) {
							string = string.toString(); // Strip HTML tags. This isn't perfect, but it's much faster than any other method

							if (stringType === 'display') {
								string = string.replace(/<[^>]+>/g, '');
							}

							if (normalize) string = normalizeToBase(string);
							string = string.toUpperCase();

							if (method === 'contains') {
								searchSuccess = string.indexOf(searchString) >= 0;
							} else {
								searchSuccess = string.startsWith(searchString);
							}

							if (searchSuccess) break;
						}
					}

					return searchSuccess;
				}

				function toInteger(value) {
					return parseInt(value, 10) || 0;
				} // Borrowed from Lodash (_.deburr)

				/** Used to map Latin Unicode letters to basic Latin letters. */


				var deburredLetters = {
					// Latin-1 Supplement block.
					'\xc0': 'A',
					'\xc1': 'A',
					'\xc2': 'A',
					'\xc3': 'A',
					'\xc4': 'A',
					'\xc5': 'A',
					'\xe0': 'a',
					'\xe1': 'a',
					'\xe2': 'a',
					'\xe3': 'a',
					'\xe4': 'a',
					'\xe5': 'a',
					'\xc7': 'C',
					'\xe7': 'c',
					'\xd0': 'D',
					'\xf0': 'd',
					'\xc8': 'E',
					'\xc9': 'E',
					'\xca': 'E',
					'\xcb': 'E',
					'\xe8': 'e',
					'\xe9': 'e',
					'\xea': 'e',
					'\xeb': 'e',
					'\xcc': 'I',
					'\xcd': 'I',
					'\xce': 'I',
					'\xcf': 'I',
					'\xec': 'i',
					'\xed': 'i',
					'\xee': 'i',
					'\xef': 'i',
					'\xd1': 'N',
					'\xf1': 'n',
					'\xd2': 'O',
					'\xd3': 'O',
					'\xd4': 'O',
					'\xd5': 'O',
					'\xd6': 'O',
					'\xd8': 'O',
					'\xf2': 'o',
					'\xf3': 'o',
					'\xf4': 'o',
					'\xf5': 'o',
					'\xf6': 'o',
					'\xf8': 'o',
					'\xd9': 'U',
					'\xda': 'U',
					'\xdb': 'U',
					'\xdc': 'U',
					'\xf9': 'u',
					'\xfa': 'u',
					'\xfb': 'u',
					'\xfc': 'u',
					'\xdd': 'Y',
					'\xfd': 'y',
					'\xff': 'y',
					'\xc6': 'Ae',
					'\xe6': 'ae',
					'\xde': 'Th',
					'\xfe': 'th',
					'\xdf': 'ss',
					// Latin Extended-A block.
					"\u0100": 'A',
					"\u0102": 'A',
					"\u0104": 'A',
					"\u0101": 'a',
					"\u0103": 'a',
					"\u0105": 'a',
					"\u0106": 'C',
					"\u0108": 'C',
					"\u010A": 'C',
					"\u010C": 'C',
					"\u0107": 'c',
					"\u0109": 'c',
					"\u010B": 'c',
					"\u010D": 'c',
					"\u010E": 'D',
					"\u0110": 'D',
					"\u010F": 'd',
					"\u0111": 'd',
					"\u0112": 'E',
					"\u0114": 'E',
					"\u0116": 'E',
					"\u0118": 'E',
					"\u011A": 'E',
					"\u0113": 'e',
					"\u0115": 'e',
					"\u0117": 'e',
					"\u0119": 'e',
					"\u011B": 'e',
					"\u011C": 'G',
					"\u011E": 'G',
					"\u0120": 'G',
					"\u0122": 'G',
					"\u011D": 'g',
					"\u011F": 'g',
					"\u0121": 'g',
					"\u0123": 'g',
					"\u0124": 'H',
					"\u0126": 'H',
					"\u0125": 'h',
					"\u0127": 'h',
					"\u0128": 'I',
					"\u012A": 'I',
					"\u012C": 'I',
					"\u012E": 'I',
					"\u0130": 'I',
					"\u0129": 'i',
					"\u012B": 'i',
					"\u012D": 'i',
					"\u012F": 'i',
					"\u0131": 'i',
					"\u0134": 'J',
					"\u0135": 'j',
					"\u0136": 'K',
					"\u0137": 'k',
					"\u0138": 'k',
					"\u0139": 'L',
					"\u013B": 'L',
					"\u013D": 'L',
					"\u013F": 'L',
					"\u0141": 'L',
					"\u013A": 'l',
					"\u013C": 'l',
					"\u013E": 'l',
					"\u0140": 'l',
					"\u0142": 'l',
					"\u0143": 'N',
					"\u0145": 'N',
					"\u0147": 'N',
					"\u014A": 'N',
					"\u0144": 'n',
					"\u0146": 'n',
					"\u0148": 'n',
					"\u014B": 'n',
					"\u014C": 'O',
					"\u014E": 'O',
					"\u0150": 'O',
					"\u014D": 'o',
					"\u014F": 'o',
					"\u0151": 'o',
					"\u0154": 'R',
					"\u0156": 'R',
					"\u0158": 'R',
					"\u0155": 'r',
					"\u0157": 'r',
					"\u0159": 'r',
					"\u015A": 'S',
					"\u015C": 'S',
					"\u015E": 'S',
					"\u0160": 'S',
					"\u015B": 's',
					"\u015D": 's',
					"\u015F": 's',
					"\u0161": 's',
					"\u0162": 'T',
					"\u0164": 'T',
					"\u0166": 'T',
					"\u0163": 't',
					"\u0165": 't',
					"\u0167": 't',
					"\u0168": 'U',
					"\u016A": 'U',
					"\u016C": 'U',
					"\u016E": 'U',
					"\u0170": 'U',
					"\u0172": 'U',
					"\u0169": 'u',
					"\u016B": 'u',
					"\u016D": 'u',
					"\u016F": 'u',
					"\u0171": 'u',
					"\u0173": 'u',
					"\u0174": 'W',
					"\u0175": 'w',
					"\u0176": 'Y',
					"\u0177": 'y',
					"\u0178": 'Y',
					"\u0179": 'Z',
					"\u017B": 'Z',
					"\u017D": 'Z',
					"\u017A": 'z',
					"\u017C": 'z',
					"\u017E": 'z',
					"\u0132": 'IJ',
					"\u0133": 'ij',
					"\u0152": 'Oe',
					"\u0153": 'oe',
					"\u0149": "'n",
					"\u017F": 's'
				};
				/** Used to match Latin Unicode letters (excluding mathematical operators). */

				var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
				/** Used to compose unicode character classes. */

				var rsComboMarksRange = "\\u0300-\\u036f",
					reComboHalfMarksRange = "\\ufe20-\\ufe2f",
					rsComboSymbolsRange = "\\u20d0-\\u20ff",
					rsComboMarksExtendedRange = "\\u1ab0-\\u1aff",
					rsComboMarksSupplementRange = "\\u1dc0-\\u1dff",
					rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;
				/** Used to compose unicode capture groups. */

				var rsCombo = '[' + rsComboRange + ']';
				/**
				 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
				 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
				 */

				var reComboMark = RegExp(rsCombo, 'g');

				function deburrLetter(key) {
					return deburredLetters[key];
				}

				;

				function normalizeToBase(string) {
					string = string.toString();
					return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
				} // List of HTML entities for escaping.


				var escapeMap = {
					'&': '&amp;',
					'<': '&lt;',
					'>': '&gt;',
					'"': '&quot;',
					"'": '&#x27;',
					'`': '&#x60;'
				}; // Functions for escaping and unescaping strings to/from HTML interpolation.

				var createEscaper = function createEscaper(map) {
					var escaper = function escaper(match) {
						return map[match];
					}; // Regexes for identifying a key that needs to be escaped.


					var source = '(?:' + Object.keys(map).join('|') + ')';
					var testRegexp = RegExp(source);
					var replaceRegexp = RegExp(source, 'g');
					return function (string) {
						string = string == null ? '' : '' + string;
						return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
					};
				};

				var htmlEscape = createEscaper(escapeMap);
				/**
				 * ------------------------------------------------------------------------
				 * Constants
				 * ------------------------------------------------------------------------
				 */

				var keyCodeMap = {
					32: ' ',
					48: '0',
					49: '1',
					50: '2',
					51: '3',
					52: '4',
					53: '5',
					54: '6',
					55: '7',
					56: '8',
					57: '9',
					59: ';',
					65: 'A',
					66: 'B',
					67: 'C',
					68: 'D',
					69: 'E',
					70: 'F',
					71: 'G',
					72: 'H',
					73: 'I',
					74: 'J',
					75: 'K',
					76: 'L',
					77: 'M',
					78: 'N',
					79: 'O',
					80: 'P',
					81: 'Q',
					82: 'R',
					83: 'S',
					84: 'T',
					85: 'U',
					86: 'V',
					87: 'W',
					88: 'X',
					89: 'Y',
					90: 'Z',
					96: '0',
					97: '1',
					98: '2',
					99: '3',
					100: '4',
					101: '5',
					102: '6',
					103: '7',
					104: '8',
					105: '9'
				};
				var keyCodes = {
					ESCAPE: 27,
					// KeyboardEvent.which value for Escape (Esc) key
					ENTER: 13,
					// KeyboardEvent.which value for Enter key
					SPACE: 32,
					// KeyboardEvent.which value for space key
					TAB: 9,
					// KeyboardEvent.which value for tab key
					ARROW_UP: 38,
					// KeyboardEvent.which value for up arrow key
					ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key

				};
				var version = {
					success: false,
					major: '3'
				};

				try {
					version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');
					version.major = version.full[0];
					version.success = true;
				} catch (err) {// do nothing
				}

				var selectId = 0;
				var EVENT_KEY = '.bs.select';
				var classNames = {
					DISABLED: 'disabled',
					DIVIDER: 'divider',
					SHOW: 'open',
					DROPUP: 'dropup',
					MENU: 'dropdown-menu',
					MENURIGHT: 'dropdown-menu-right',
					MENULEFT: 'dropdown-menu-left',
					// to-do: replace with more advanced template/customization options
					BUTTONCLASS: 'btn-default',
					POPOVERHEADER: 'popover-title',
					ICONBASE: 'glyphicon',
					TICKICON: 'glyphicon-ok'
				};
				var Selector = {
					MENU: '.' + classNames.MENU
				};
				var elementTemplates = {
					div: document.createElement('div'),
					span: document.createElement('span'),
					i: document.createElement('i'),
					subtext: document.createElement('small'),
					a: document.createElement('a'),
					li: document.createElement('li'),
					whitespace: document.createTextNode("\xA0"),
					fragment: document.createDocumentFragment()
				};
				elementTemplates.noResults = elementTemplates.li.cloneNode(false);
				elementTemplates.noResults.className = 'no-results';
				elementTemplates.a.setAttribute('role', 'option');
				elementTemplates.a.className = 'dropdown-item';
				elementTemplates.subtext.className = 'text-muted';
				elementTemplates.text = elementTemplates.span.cloneNode(false);
				elementTemplates.text.className = 'text';
				elementTemplates.checkMark = elementTemplates.span.cloneNode(false);
				var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);
				var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);
				var generateOption = {
					li: function li(content, classes, optgroup) {
						var li = elementTemplates.li.cloneNode(false);

						if (content) {
							if (content.nodeType === 1 || content.nodeType === 11) {
								li.appendChild(content);
							} else {
								li.innerHTML = content;
							}
						}

						if (typeof classes !== 'undefined' && classes !== '') li.className = classes;
						if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);
						return li;
					},
					a: function a(text, classes, inline) {
						var a = elementTemplates.a.cloneNode(true);

						if (text) {
							if (text.nodeType === 11) {
								a.appendChild(text);
							} else {
								a.insertAdjacentHTML('beforeend', text);
							}
						}

						if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\s+/));
						if (inline) a.setAttribute('style', inline);
						return a;
					},
					text: function text(options, useFragment) {
						var textElement = elementTemplates.text.cloneNode(false),
							subtextElement,
							iconElement;

						if (options.content) {
							textElement.innerHTML = options.content;
						} else {
							textElement.textContent = options.text;

							if (options.icon) {
								var whitespace = elementTemplates.whitespace.cloneNode(false); // need to use <i> for icons in the button to prevent a breaking change
								// note: switch to span in next major release

								iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);
								iconElement.className = this.options.iconBase + ' ' + options.icon;
								elementTemplates.fragment.appendChild(iconElement);
								elementTemplates.fragment.appendChild(whitespace);
							}

							if (options.subtext) {
								subtextElement = elementTemplates.subtext.cloneNode(false);
								subtextElement.textContent = options.subtext;
								textElement.appendChild(subtextElement);
							}
						}

						if (useFragment === true) {
							while (textElement.childNodes.length > 0) {
								elementTemplates.fragment.appendChild(textElement.childNodes[0]);
							}
						} else {
							elementTemplates.fragment.appendChild(textElement);
						}

						return elementTemplates.fragment;
					},
					label: function label(options) {
						var textElement = elementTemplates.text.cloneNode(false),
							subtextElement,
							iconElement;
						textElement.innerHTML = options.display;

						if (options.icon) {
							var whitespace = elementTemplates.whitespace.cloneNode(false);
							iconElement = elementTemplates.span.cloneNode(false);
							iconElement.className = this.options.iconBase + ' ' + options.icon;
							elementTemplates.fragment.appendChild(iconElement);
							elementTemplates.fragment.appendChild(whitespace);
						}

						if (options.subtext) {
							subtextElement = elementTemplates.subtext.cloneNode(false);
							subtextElement.textContent = options.subtext;
							textElement.appendChild(subtextElement);
						}

						elementTemplates.fragment.appendChild(textElement);
						return elementTemplates.fragment;
					}
				};

				function showNoResults(searchMatch, searchValue) {
					if (!searchMatch.length) {
						elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '"' + htmlEscape(searchValue) + '"');
						this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);
					}
				}

				var Selectpicker = function Selectpicker(element, options) {
					var that = this; // bootstrap-select has been initialized - revert valHooks.select.set back to its original function

					if (!valHooks.useDefault) {
						$.valHooks.select.set = valHooks._set;
						valHooks.useDefault = true;
					}

					this.$element = $(element);
					this.$newElement = null;
					this.$button = null;
					this.$menu = null;
					this.options = options;
					this.selectpicker = {
						main: {},
						search: {},
						current: {},
						// current changes if a search is in progress
						view: {},
						isSearching: false,
						keydown: {
							keyHistory: '',
							resetKeyHistory: {
								start: function start() {
									return setTimeout(function () {
										that.selectpicker.keydown.keyHistory = '';
									}, 800);
								}
							}
						}
					};
					this.sizeInfo = {}; // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a
					// data-attribute)

					if (this.options.title === null) {
						this.options.title = this.$element.attr('title');
					} // Format window padding


					var winPad = this.options.windowPadding;

					if (typeof winPad === 'number') {
						this.options.windowPadding = [winPad, winPad, winPad, winPad];
					} // Expose public methods


					this.val = Selectpicker.prototype.val;
					this.render = Selectpicker.prototype.render;
					this.refresh = Selectpicker.prototype.refresh;
					this.setStyle = Selectpicker.prototype.setStyle;
					this.selectAll = Selectpicker.prototype.selectAll;
					this.deselectAll = Selectpicker.prototype.deselectAll;
					this.destroy = Selectpicker.prototype.destroy;
					this.remove = Selectpicker.prototype.remove;
					this.show = Selectpicker.prototype.show;
					this.hide = Selectpicker.prototype.hide;
					this.init();
				};

				Selectpicker.VERSION = '1.13.18'; // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.

				Selectpicker.DEFAULTS = {
					noneSelectedText: 'Nothing selected',
					noneResultsText: 'No results matched {0}',
					countSelectedText: function countSelectedText(numSelected, numTotal) {
						return numSelected == 1 ? '{0} item selected' : '{0} items selected';
					},
					maxOptionsText: function maxOptionsText(numAll, numGroup) {
						return [numAll == 1 ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)', numGroup == 1 ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'];
					},
					selectAllText: 'Select All',
					deselectAllText: 'Deselect All',
					doneButton: false,
					doneButtonText: 'Close',
					multipleSeparator: ', ',
					styleBase: 'btn',
					style: classNames.BUTTONCLASS,
					size: 'auto',
					title: null,
					selectedTextFormat: 'values',
					width: false,
					container: false,
					hideDisabled: false,
					showSubtext: false,
					showIcon: true,
					showContent: true,
					dropupAuto: true,
					header: false,
					liveSearch: false,
					liveSearchPlaceholder: null,
					liveSearchNormalize: false,
					liveSearchStyle: 'contains',
					actionsBox: false,
					iconBase: classNames.ICONBASE,
					tickIcon: classNames.TICKICON,
					showTick: false,
					template: {
						caret: '<span class="caret"></span>'
					},
					maxOptions: false,
					mobile: false,
					selectOnTab: false,
					dropdownAlignRight: false,
					windowPadding: 0,
					virtualScroll: 600,
					display: false,
					sanitize: true,
					sanitizeFn: null,
					whiteList: DefaultWhitelist
				};
				Selectpicker.prototype = {
					constructor: Selectpicker,
					init: function init() {
						var that = this,
							id = this.$element.attr('id'),
							element = this.$element[0],
							form = element.form;
						selectId++;
						this.selectId = 'bs-select-' + selectId;
						element.classList.add('bs-select-hidden');
						this.multiple = this.$element.prop('multiple');
						this.autofocus = this.$element.prop('autofocus');

						if (element.classList.contains('show-tick')) {
							this.options.showTick = true;
						}

						this.$newElement = this.createDropdown();
						this.buildData();
						this.$element.after(this.$newElement).prependTo(this.$newElement); // ensure select is associated with form element if it got unlinked after moving it inside newElement

						if (form && element.form === null) {
							if (!form.id) form.id = 'form-' + this.selectId;
							element.setAttribute('form', form.id);
						}

						this.$button = this.$newElement.children('button');
						this.$menu = this.$newElement.children(Selector.MENU);
						this.$menuInner = this.$menu.children('.inner');
						this.$searchbox = this.$menu.find('input');
						element.classList.remove('bs-select-hidden');
						if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);

						if (typeof id !== 'undefined') {
							this.$button.attr('data-id', id);
						}

						this.checkDisabled();
						this.clickListener();

						if (this.options.liveSearch) {
							this.liveSearchListener();
							this.focusedParent = this.$searchbox[0];
						} else {
							this.focusedParent = this.$menuInner[0];
						}

						this.setStyle();
						this.render();
						this.setWidth();

						if (this.options.container) {
							this.selectPosition();
						} else {
							this.$element.on('hide' + EVENT_KEY, function () {
								if (that.isVirtual()) {
									// empty menu on close
									var menuInner = that.$menuInner[0],
										emptyMenu = menuInner.firstChild.cloneNode(false); // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''

									menuInner.replaceChild(emptyMenu, menuInner.firstChild);
									menuInner.scrollTop = 0;
								}
							});
						}

						this.$menu.data('this', this);
						this.$newElement.data('this', this);
						if (this.options.mobile) this.mobile();
						this.$newElement.on({
							'hide.bs.dropdown': function hideBsDropdown(e) {
								that.$element.trigger('hide' + EVENT_KEY, e);
							},
							'hidden.bs.dropdown': function hiddenBsDropdown(e) {
								that.$element.trigger('hidden' + EVENT_KEY, e);
							},
							'show.bs.dropdown': function showBsDropdown(e) {
								that.$element.trigger('show' + EVENT_KEY, e);
							},
							'shown.bs.dropdown': function shownBsDropdown(e) {
								that.$element.trigger('shown' + EVENT_KEY, e);
							}
						});

						if (element.hasAttribute('required')) {
							this.$element.on('invalid' + EVENT_KEY, function () {
								that.$button[0].classList.add('bs-invalid');
								that.$element.on('shown' + EVENT_KEY + '.invalid', function () {
									that.$element.val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened
										.off('shown' + EVENT_KEY + '.invalid');
								}).on('rendered' + EVENT_KEY, function () {
									// if select is no longer invalid, remove the bs-invalid class
									if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');
									that.$element.off('rendered' + EVENT_KEY);
								});
								that.$button.on('blur' + EVENT_KEY, function () {
									that.$element.trigger('focus').trigger('blur');
									that.$button.off('blur' + EVENT_KEY);
								});
							});
						}

						setTimeout(function () {
							that.buildList();
							that.$element.trigger('loaded' + EVENT_KEY);
						});
					},
					createDropdown: function createDropdown() {
						// Options
						// If we are multiple or showTick option is set, then add the show-tick class
						var showTick = this.multiple || this.options.showTick ? ' show-tick' : '',
							multiselectable = this.multiple ? ' aria-multiselectable="true"' : '',
							inputGroup = '',
							autofocus = this.autofocus ? ' autofocus' : '';

						if (version.major < 4 && this.$element.parent().hasClass('input-group')) {
							inputGroup = ' input-group-btn';
						} // Elements


						var drop,
							header = '',
							searchbox = '',
							actionsbox = '',
							donebutton = '';

						if (this.options.header) {
							header = '<div class="' + classNames.POPOVERHEADER + '">' + '<button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>';
						}

						if (this.options.liveSearch) {
							searchbox = '<div class="bs-searchbox">' + '<input type="search" class="form-control" autocomplete="off"' + (this.options.liveSearchPlaceholder === null ? '' : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + ' role="combobox" aria-label="Search" aria-controls="' + this.selectId + '" aria-autocomplete="list">' + '</div>';
						}

						if (this.multiple && this.options.actionsBox) {
							actionsbox = '<div class="bs-actionsbox">' + '<div class="btn-group btn-group-sm btn-block">' + '<button type="button" class="actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '">' + this.options.selectAllText + '</button>' + '<button type="button" class="actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '">' + this.options.deselectAllText + '</button>' + '</div>' + '</div>';
						}

						if (this.multiple && this.options.doneButton) {
							donebutton = '<div class="bs-donebutton">' + '<div class="btn-group btn-block">' + '<button type="button" class="btn btn-sm ' + classNames.BUTTONCLASS + '">' + this.options.doneButtonText + '</button>' + '</div>' + '</div>';
						}

						drop = '<div class="dropdown bootstrap-select' + showTick + inputGroup + '">' + '<button type="button" tabindex="-1" class="' + this.options.styleBase + ' dropdown-toggle" ' + (this.options.display === 'static' ? 'data-display="static"' : '') + 'data-toggle="dropdown"' + autofocus + ' role="combobox" aria-owns="' + this.selectId + '" aria-haspopup="listbox" aria-expanded="false">' + '<div class="filter-option">' + '<div class="filter-option-inner">' + '<div class="filter-option-inner-inner"></div>' + '</div> ' + '</div>' + (version.major === '4' ? '' : '<span class="bs-caret">' + this.options.template.caret + '</span>') + '</button>' + '<div class="' + classNames.MENU + ' ' + (version.major === '4' ? '' : classNames.SHOW) + '">' + header + searchbox + actionsbox + '<div class="inner ' + classNames.SHOW + '" role="listbox" id="' + this.selectId + '" tabindex="-1" ' + multiselectable + '>' + '<ul class="' + classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '') + '" role="presentation">' + '</ul>' + '</div>' + donebutton + '</div>' + '</div>';
						return $(drop);
					},
					setPositionData: function setPositionData() {
						this.selectpicker.view.canHighlight = [];
						this.selectpicker.view.size = 0;
						this.selectpicker.view.firstHighlightIndex = false;

						for (var i = 0; i < this.selectpicker.current.data.length; i++) {
							var li = this.selectpicker.current.data[i],
								canHighlight = true;

							if (li.type === 'divider') {
								canHighlight = false;
								li.height = this.sizeInfo.dividerHeight;
							} else if (li.type === 'optgroup-label') {
								canHighlight = false;
								li.height = this.sizeInfo.dropdownHeaderHeight;
							} else {
								li.height = this.sizeInfo.liHeight;
							}

							if (li.disabled) canHighlight = false;
							this.selectpicker.view.canHighlight.push(canHighlight);

							if (canHighlight) {
								this.selectpicker.view.size++;
								li.posinset = this.selectpicker.view.size;
								if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;
							}

							li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;
						}
					},
					isVirtual: function isVirtual() {
						return this.options.virtualScroll !== false && this.selectpicker.main.elements.length >= this.options.virtualScroll || this.options.virtualScroll === true;
					},
					createView: function createView(isSearching, setSize, refresh) {
						var that = this,
							scrollTop = 0,
							active = [],
							selected,
							prevActive;
						this.selectpicker.isSearching = isSearching;
						this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;
						this.setPositionData();

						if (setSize) {
							if (refresh) {
								scrollTop = this.$menuInner[0].scrollTop;
							} else if (!that.multiple) {
								var element = that.$element[0],
									selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;

								if (typeof selectedIndex === 'number' && that.options.size !== false) {
									var selectedData = that.selectpicker.main.data[selectedIndex],
										position = selectedData && selectedData.position;

									if (position) {
										scrollTop = position - (that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2;
									}
								}
							}
						}

						scroll(scrollTop, true);
						this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {
							if (!that.noScroll) scroll(this.scrollTop, updateValue);
							that.noScroll = false;
						});

						function scroll(scrollTop, init) {
							var size = that.selectpicker.current.elements.length,
								chunks = [],
								chunkSize,
								chunkCount,
								firstChunk,
								lastChunk,
								currentChunk,
								prevPositions,
								positionIsDifferent,
								previousElements,
								menuIsDifferent = true,
								isVirtual = that.isVirtual();
							that.selectpicker.view.scrollTop = scrollTop;
							chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk

							chunkCount = Math.round(size / chunkSize) || 1; // number of chunks

							for (var i = 0; i < chunkCount; i++) {
								var endOfChunk = (i + 1) * chunkSize;

								if (i === chunkCount - 1) {
									endOfChunk = size;
								}

								chunks[i] = [i * chunkSize + (!i ? 0 : 1), endOfChunk];
								if (!size) break;

								if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {
									currentChunk = i;
								}
							}

							if (currentChunk === undefined) currentChunk = 0;
							prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1]; // always display previous, current, and next chunks

							firstChunk = Math.max(0, currentChunk - 1);
							lastChunk = Math.min(chunkCount - 1, currentChunk + 1);
							that.selectpicker.view.position0 = isVirtual === false ? 0 : Math.max(0, chunks[firstChunk][0]) || 0;
							that.selectpicker.view.position1 = isVirtual === false ? size : Math.min(size, chunks[lastChunk][1]) || 0;
							positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;

							if (that.activeIndex !== undefined) {
								prevActive = that.selectpicker.main.elements[that.prevActiveIndex];
								active = that.selectpicker.main.elements[that.activeIndex];
								selected = that.selectpicker.main.elements[that.selectedIndex];

								if (init) {
									if (that.activeIndex !== that.selectedIndex) {
										that.defocusItem(active);
									}

									that.activeIndex = undefined;
								}

								if (that.activeIndex && that.activeIndex !== that.selectedIndex) {
									that.defocusItem(selected);
								}
							}

							if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex) {
								that.defocusItem(prevActive);
							}

							if (init || positionIsDifferent) {
								previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];

								if (isVirtual === false) {
									that.selectpicker.view.visibleElements = that.selectpicker.current.elements;
								} else {
									that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);
								}

								that.setOptionStatus(); // if searching, check to make sure the list has actually been updated before updating DOM
								// this prevents unnecessary repaints

								if (isSearching || isVirtual === false && init) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements); // if virtual scroll is disabled and not searching,
								// menu should never need to be updated more than once

								if ((init || isVirtual === true) && menuIsDifferent) {
									var menuInner = that.$menuInner[0],
										menuFragment = document.createDocumentFragment(),
										emptyMenu = menuInner.firstChild.cloneNode(false),
										marginTop,
										marginBottom,
										elements = that.selectpicker.view.visibleElements,
										toSanitize = []; // replace the existing UL with an empty one - this is faster than $.empty()

									menuInner.replaceChild(emptyMenu, menuInner.firstChild);

									for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {
										var element = elements[i],
											elText,
											elementData;

										if (that.options.sanitize) {
											elText = element.lastChild;

											if (elText) {
												elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];

												if (elementData && elementData.content && !elementData.sanitized) {
													toSanitize.push(elText);
													elementData.sanitized = true;
												}
											}
										}

										menuFragment.appendChild(element);
									}

									if (that.options.sanitize && toSanitize.length) {
										sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);
									}

									if (isVirtual === true) {
										marginTop = that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position;
										marginBottom = that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position;
										menuInner.firstChild.style.marginTop = marginTop + 'px';
										menuInner.firstChild.style.marginBottom = marginBottom + 'px';
									} else {
										menuInner.firstChild.style.marginTop = 0;
										menuInner.firstChild.style.marginBottom = 0;
									}

									menuInner.firstChild.appendChild(menuFragment); // if an option is encountered that is wider than the current menu width, update the menu width accordingly
									// switch to ResizeObserver with increased browser support

									if (isVirtual === true && that.sizeInfo.hasScrollBar) {
										var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;

										if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {
											menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';
										} else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {
											// set to 0 to get actual width of menu
											that.$menu[0].style.minWidth = 0;
											var actualMenuWidth = menuInner.firstChild.offsetWidth;

											if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {
												that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;
												menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';
											} // reset to default CSS styling


											that.$menu[0].style.minWidth = '';
										}
									}
								}
							}

							that.prevActiveIndex = that.activeIndex;

							if (!that.options.liveSearch) {
								that.$menuInner.trigger('focus');
							} else if (isSearching && init) {
								var index = 0,
									newActive;

								if (!that.selectpicker.view.canHighlight[index]) {
									index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);
								}

								newActive = that.selectpicker.view.visibleElements[index];
								that.defocusItem(that.selectpicker.view.currentActive);
								that.activeIndex = (that.selectpicker.current.data[index] || {}).index;
								that.focusItem(newActive);
							}
						}

						$(window).off('resize' + EVENT_KEY + '.' + this.selectId + '.createView').on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {
							var isActive = that.$newElement.hasClass(classNames.SHOW);
							if (isActive) scroll(that.$menuInner[0].scrollTop);
						});
					},
					focusItem: function focusItem(li, liData, noStyle) {
						if (li) {
							liData = liData || this.selectpicker.main.data[this.activeIndex];
							var a = li.firstChild;

							if (a) {
								a.setAttribute('aria-setsize', this.selectpicker.view.size);
								a.setAttribute('aria-posinset', liData.posinset);

								if (noStyle !== true) {
									this.focusedParent.setAttribute('aria-activedescendant', a.id);
									li.classList.add('active');
									a.classList.add('active');
								}
							}
						}
					},
					defocusItem: function defocusItem(li) {
						if (li) {
							li.classList.remove('active');
							if (li.firstChild) li.firstChild.classList.remove('active');
						}
					},
					setPlaceholder: function setPlaceholder() {
						var that = this,
							updateIndex = false;

						if (this.options.title && !this.multiple) {
							if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option'); // this option doesn't create a new <li> element, but does add a new option at the start,
							// so startIndex should increase to prevent having to check every option for the bs-title-option class

							updateIndex = true;
							var element = this.$element[0],
								selectTitleOption = false,
								titleNotAppended = !this.selectpicker.view.titleOption.parentNode,
								selectedIndex = element.selectedIndex,
								selectedOption = element.options[selectedIndex],
								navigation = window.performance && window.performance.getEntriesByType('navigation'),
								// Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation
								isNotBackForward = navigation && navigation.length ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;

							if (titleNotAppended) {
								// Use native JS to prepend option (faster)
								this.selectpicker.view.titleOption.className = 'bs-title-option';
								this.selectpicker.view.titleOption.value = ''; // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.
								// the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,
								// if so, the select will have the data-selected attribute

								selectTitleOption = !selectedOption || selectedIndex === 0 && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined;
							}

							if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {
								element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);
							} // Set selected *after* appending to select,
							// otherwise the option doesn't get selected in IE
							// set using selectedIndex, as setting the selected attr to true here doesn't work in IE11


							if (selectTitleOption && isNotBackForward) {
								element.selectedIndex = 0;
							} else if (document.readyState !== 'complete') {
								// if navigation type is back_forward, there's a chance the select will have its value set by BFCache
								// wait for that value to be set, then run render again
								window.addEventListener('pageshow', function () {
									if (that.selectpicker.view.displayedValue !== element.value) that.render();
								});
							}
						}

						return updateIndex;
					},
					buildData: function buildData() {
						var optionSelector = ':not([hidden]):not([data-hidden="true"])',
							mainData = [],
							optID = 0,
							startIndex = this.setPlaceholder() ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop

						if (this.options.hideDisabled) optionSelector += ':not(:disabled)';
						var selectOptions = this.$element[0].querySelectorAll('select > *' + optionSelector);

						function addDivider(config) {
							var previousData = mainData[mainData.length - 1]; // ensure optgroup doesn't create back-to-back dividers

							if (previousData && previousData.type === 'divider' && (previousData.optID || config.optID)) {
								return;
							}

							config = config || {};
							config.type = 'divider';
							mainData.push(config);
						}

						function addOption(option, config) {
							config = config || {};
							config.divider = option.getAttribute('data-divider') === 'true';

							if (config.divider) {
								addDivider({
									optID: config.optID
								});
							} else {
								var liIndex = mainData.length,
									cssText = option.style.cssText,
									inlineStyle = cssText ? htmlEscape(cssText) : '',
									optionClass = (option.className || '') + (config.optgroupClass || '');
								if (config.optID) optionClass = 'opt ' + optionClass;
								config.optionClass = optionClass.trim();
								config.inlineStyle = inlineStyle;
								config.text = option.textContent;
								config.content = option.getAttribute('data-content');
								config.tokens = option.getAttribute('data-tokens');
								config.subtext = option.getAttribute('data-subtext');
								config.icon = option.getAttribute('data-icon');
								option.liIndex = liIndex;
								config.display = config.content || config.text;
								config.type = 'option';
								config.index = liIndex;
								config.option = option;
								config.selected = !!option.selected;
								config.disabled = config.disabled || !!option.disabled;
								mainData.push(config);
							}
						}

						function addOptgroup(index, selectOptions) {
							var optgroup = selectOptions[index],
								// skip placeholder option
								previous = index - 1 < startIndex ? false : selectOptions[index - 1],
								next = selectOptions[index + 1],
								options = optgroup.querySelectorAll('option' + optionSelector);
							if (!options.length) return;
							var config = {
									display: htmlEscape(optgroup.label),
									subtext: optgroup.getAttribute('data-subtext'),
									icon: optgroup.getAttribute('data-icon'),
									type: 'optgroup-label',
									optgroupClass: ' ' + (optgroup.className || '')
								},
								headerIndex,
								lastIndex;
							optID++;

							if (previous) {
								addDivider({
									optID: optID
								});
							}

							config.optID = optID;
							mainData.push(config);

							for (var j = 0, len = options.length; j < len; j++) {
								var option = options[j];

								if (j === 0) {
									headerIndex = mainData.length - 1;
									lastIndex = headerIndex + len;
								}

								addOption(option, {
									headerIndex: headerIndex,
									lastIndex: lastIndex,
									optID: config.optID,
									optgroupClass: config.optgroupClass,
									disabled: optgroup.disabled
								});
							}

							if (next) {
								addDivider({
									optID: optID
								});
							}
						}

						for (var len = selectOptions.length, i = startIndex; i < len; i++) {
							var item = selectOptions[i];

							if (item.tagName !== 'OPTGROUP') {
								addOption(item, {});
							} else {
								addOptgroup(i, selectOptions);
							}
						}

						this.selectpicker.main.data = this.selectpicker.current.data = mainData;
					},
					buildList: function buildList() {
						var that = this,
							selectData = this.selectpicker.main.data,
							mainElements = [],
							widestOptionLength = 0;

						if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {
							elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';
							elementTemplates.a.appendChild(elementTemplates.checkMark);
						}

						function buildElement(item) {
							var liElement,
								combinedLength = 0;

							switch (item.type) {
								case 'divider':
									liElement = generateOption.li(false, classNames.DIVIDER, item.optID ? item.optID + 'div' : undefined);
									break;

								case 'option':
									liElement = generateOption.li(generateOption.a(generateOption.text.call(that, item), item.optionClass, item.inlineStyle), '', item.optID);

									if (liElement.firstChild) {
										liElement.firstChild.id = that.selectId + '-' + item.index;
									}

									break;

								case 'optgroup-label':
									liElement = generateOption.li(generateOption.label.call(that, item), 'dropdown-header' + item.optgroupClass, item.optID);
									break;
							}

							item.element = liElement;
							mainElements.push(liElement); // count the number of characters in the option - not perfect, but should work in most cases

							if (item.display) combinedLength += item.display.length;
							if (item.subtext) combinedLength += item.subtext.length; // if there is an icon, ensure this option's width is checked

							if (item.icon) combinedLength += 1;

							if (combinedLength > widestOptionLength) {
								widestOptionLength = combinedLength; // guess which option is the widest
								// use this when calculating menu width
								// not perfect, but it's fast, and the width will be updating accordingly when scrolling

								that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];
							}
						}

						for (var len = selectData.length, i = 0; i < len; i++) {
							var item = selectData[i];
							buildElement(item);
						}

						this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;
					},
					findLis: function findLis() {
						return this.$menuInner.find('.inner > li');
					},
					render: function render() {
						var that = this,
							element = this.$element[0],
							// ensure titleOption is appended and selected (if necessary) before getting selectedOptions
							placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,
							selectedOptions = getSelectedOptions(element, this.options.hideDisabled),
							selectedCount = selectedOptions.length,
							button = this.$button[0],
							buttonInner = button.querySelector('.filter-option-inner-inner'),
							multipleSeparator = document.createTextNode(this.options.multipleSeparator),
							titleFragment = elementTemplates.fragment.cloneNode(false),
							showCount,
							countMax,
							hasContent = false;
						button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !getSelectValues(element, selectedOptions));

						if (!that.multiple && selectedOptions.length === 1) {
							that.selectpicker.view.displayedValue = getSelectValues(element, selectedOptions);
						}

						if (this.options.selectedTextFormat === 'static') {
							titleFragment = generateOption.text.call(this, {
								text: this.options.title
							}, true);
						} else {
							showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 1; // determine if the number of selected options will be shown (showCount === true)

							if (showCount) {
								countMax = this.options.selectedTextFormat.split('>');
								showCount = countMax.length > 1 && selectedCount > countMax[1] || countMax.length === 1 && selectedCount >= 2;
							} // only loop through all selected options if the count won't be shown


							if (showCount === false) {
								if (!placeholderSelected) {
									for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {
										if (selectedIndex < 50) {
											var option = selectedOptions[selectedIndex],
												thisData = this.selectpicker.main.data[option.liIndex],
												titleOptions = {};

											if (this.multiple && selectedIndex > 0) {
												titleFragment.appendChild(multipleSeparator.cloneNode(false));
											}

											if (option.title) {
												titleOptions.text = option.title;
											} else if (thisData) {
												if (thisData.content && that.options.showContent) {
													titleOptions.content = thisData.content.toString();
													hasContent = true;
												} else {
													if (that.options.showIcon) {
														titleOptions.icon = thisData.icon;
													}

													if (that.options.showSubtext && !that.multiple && thisData.subtext) titleOptions.subtext = ' ' + thisData.subtext;
													titleOptions.text = option.textContent.trim();
												}
											}

											titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));
										} else {
											break;
										}
									} // add ellipsis


									if (selectedCount > 49) {
										titleFragment.appendChild(document.createTextNode('...'));
									}
								}
							} else {
								var optionSelector = ':not([hidden]):not([data-hidden="true"]):not([data-divider="true"])';
								if (this.options.hideDisabled) optionSelector += ':not(:disabled)'; // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.

								var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,
									tr8nText = typeof this.options.countSelectedText === 'function' ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;
								titleFragment = generateOption.text.call(this, {
									text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())
								}, true);
							}
						}

						if (this.options.title == undefined) {
							// use .attr to ensure undefined is returned if title attribute is not set
							this.options.title = this.$element.attr('title');
						} // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText


						if (!titleFragment.childNodes.length) {
							titleFragment = generateOption.text.call(this, {
								text: typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText
							}, true);
						} // strip all HTML tags and trim the result, then unescape any escaped tags


						button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();

						if (this.options.sanitize && hasContent) {
							sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);
						}

						buttonInner.innerHTML = '';
						buttonInner.appendChild(titleFragment);

						if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {
							var filterExpand = button.querySelector('.filter-expand'),
								clone = buttonInner.cloneNode(true);
							clone.className = 'filter-expand';

							if (filterExpand) {
								button.replaceChild(clone, filterExpand);
							} else {
								button.appendChild(clone);
							}
						}

						this.$element.trigger('rendered' + EVENT_KEY);
					},

					/**
					 * @param [style]
					 * @param [status]
					 */
					setStyle: function setStyle(newStyle, status) {
						var button = this.$button[0],
							newElement = this.$newElement[0],
							style = this.options.style.trim(),
							buttonClass;

						if (this.$element.attr('class')) {
							this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ''));
						}

						if (version.major < 4) {
							newElement.classList.add('bs3');

							if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') && (newElement.previousElementSibling || newElement.nextElementSibling) && (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')) {
								newElement.classList.add('bs3-has-addon');
							}
						}

						if (newStyle) {
							buttonClass = newStyle.trim();
						} else {
							buttonClass = style;
						}

						if (status == 'add') {
							if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));
						} else if (status == 'remove') {
							if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));
						} else {
							if (style) button.classList.remove.apply(button.classList, style.split(' '));
							if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));
						}
					},
					liHeight: function liHeight(refresh) {
						if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;
						var newElement = elementTemplates.div.cloneNode(false),
							menu = elementTemplates.div.cloneNode(false),
							menuInner = elementTemplates.div.cloneNode(false),
							menuInnerInner = document.createElement('ul'),
							divider = elementTemplates.li.cloneNode(false),
							dropdownHeader = elementTemplates.li.cloneNode(false),
							li,
							a = elementTemplates.a.cloneNode(false),
							text = elementTemplates.span.cloneNode(false),
							header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,
							search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,
							actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,
							doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,
							firstOption = this.$element.find('option')[0];
						this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;
						text.className = 'text';
						a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');
						newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;
						newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating

						if (this.options.width === 'auto') menu.style.minWidth = 0;
						menu.className = classNames.MENU + ' ' + classNames.SHOW;
						menuInner.className = 'inner ' + classNames.SHOW;
						menuInnerInner.className = classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '');
						divider.className = classNames.DIVIDER;
						dropdownHeader.className = 'dropdown-header';
						text.appendChild(document.createTextNode("\u200B"));

						if (this.selectpicker.current.data.length) {
							for (var i = 0; i < this.selectpicker.current.data.length; i++) {
								var data = this.selectpicker.current.data[i];

								if (data.type === 'option') {
									li = data.element;
									break;
								}
							}
						} else {
							li = elementTemplates.li.cloneNode(false);
							a.appendChild(text);
							li.appendChild(a);
						}

						dropdownHeader.appendChild(text.cloneNode(true));

						if (this.selectpicker.view.widestOption) {
							menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));
						}

						menuInnerInner.appendChild(li);
						menuInnerInner.appendChild(divider);
						menuInnerInner.appendChild(dropdownHeader);
						if (header) menu.appendChild(header);

						if (search) {
							var input = document.createElement('input');
							search.className = 'bs-searchbox';
							input.className = 'form-control';
							search.appendChild(input);
							menu.appendChild(search);
						}

						if (actions) menu.appendChild(actions);
						menuInner.appendChild(menuInnerInner);
						menu.appendChild(menuInner);
						if (doneButton) menu.appendChild(doneButton);
						newElement.appendChild(menu);
						document.body.appendChild(newElement);
						var liHeight = li.offsetHeight,
							dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,
							headerHeight = header ? header.offsetHeight : 0,
							searchHeight = search ? search.offsetHeight : 0,
							actionsHeight = actions ? actions.offsetHeight : 0,
							doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,
							dividerHeight = $(divider).outerHeight(true),
							// fall back to jQuery if getComputedStyle is not supported
							menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,
							menuWidth = menu.offsetWidth,
							$menu = menuStyle ? null : $(menu),
							menuPadding = {
								vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) + toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) + toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) + toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),
								horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) + toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) + toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) + toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))
							},
							menuExtras = {
								vert: menuPadding.vert + toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) + toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,
								horiz: menuPadding.horiz + toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) + toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2
							},
							scrollBarWidth;
						menuInner.style.overflowY = 'scroll';
						scrollBarWidth = menu.offsetWidth - menuWidth;
						document.body.removeChild(newElement);
						this.sizeInfo.liHeight = liHeight;
						this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;
						this.sizeInfo.headerHeight = headerHeight;
						this.sizeInfo.searchHeight = searchHeight;
						this.sizeInfo.actionsHeight = actionsHeight;
						this.sizeInfo.doneButtonHeight = doneButtonHeight;
						this.sizeInfo.dividerHeight = dividerHeight;
						this.sizeInfo.menuPadding = menuPadding;
						this.sizeInfo.menuExtras = menuExtras;
						this.sizeInfo.menuWidth = menuWidth;
						this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;
						this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;
						this.sizeInfo.scrollBarWidth = scrollBarWidth;
						this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;
						this.setPositionData();
					},
					getSelectPosition: function getSelectPosition() {
						var that = this,
							$window = $(window),
							pos = that.$newElement.offset(),
							$container = $(that.options.container),
							containerPos;

						if (that.options.container && $container.length && !$container.is('body')) {
							containerPos = $container.offset();
							containerPos.top += parseInt($container.css('borderTopWidth'));
							containerPos.left += parseInt($container.css('borderLeftWidth'));
						} else {
							containerPos = {
								top: 0,
								left: 0
							};
						}

						var winPad = that.options.windowPadding;
						this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();
						this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];
						this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();
						this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];
						this.sizeInfo.selectOffsetTop -= winPad[0];
						this.sizeInfo.selectOffsetLeft -= winPad[3];
					},
					setMenuSize: function setMenuSize(isAuto) {
						this.getSelectPosition();

						var selectWidth = this.sizeInfo.selectWidth,
							liHeight = this.sizeInfo.liHeight,
							headerHeight = this.sizeInfo.headerHeight,
							searchHeight = this.sizeInfo.searchHeight,
							actionsHeight = this.sizeInfo.actionsHeight,
							doneButtonHeight = this.sizeInfo.doneButtonHeight,
							divHeight = this.sizeInfo.dividerHeight,
							menuPadding = this.sizeInfo.menuPadding,
							menuInnerHeight,
							menuHeight,
							divLength = 0,
							minHeight,
							_minHeight,
							maxHeight,
							menuInnerMinHeight,
							estimate,
							isDropup;

						if (this.options.dropupAuto) {
							// Get the estimated height of the menu without scrollbars.
							// This is useful for smaller menus, where there might be plenty of room
							// below the button without setting dropup, but we can't know
							// the exact height of the menu until createView is called later
							estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;
							isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot; // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)

							if (this.selectpicker.isSearching === true) {
								isDropup = this.selectpicker.dropup;
							}

							this.$newElement.toggleClass(classNames.DROPUP, isDropup);
							this.selectpicker.dropup = isDropup;
						}

						if (this.options.size === 'auto') {
							_minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;
							menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;
							minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
							menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);

							if (this.$newElement.hasClass(classNames.DROPUP)) {
								menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;
							}

							maxHeight = menuHeight;
							menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;
						} else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
							for (var i = 0; i < this.options.size; i++) {
								if (this.selectpicker.current.data[i].type === 'divider') divLength++;
							}

							menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;
							menuInnerHeight = menuHeight - menuPadding.vert;
							maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;
							minHeight = menuInnerMinHeight = '';
						}

						this.$menu.css({
							'max-height': maxHeight + 'px',
							'overflow': 'hidden',
							'min-height': minHeight + 'px'
						});
						this.$menuInner.css({
							'max-height': menuInnerHeight + 'px',
							'overflow-y': 'auto',
							'min-height': menuInnerMinHeight + 'px'
						}); // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView

						this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);

						if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {
							this.sizeInfo.hasScrollBar = true;
							this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;
						}

						if (this.options.dropdownAlignRight === 'auto') {
							this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < this.sizeInfo.totalMenuWidth - selectWidth);
						}

						if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();
					},
					setSize: function setSize(refresh) {
						this.liHeight(refresh);
						if (this.options.header) this.$menu.css('padding-top', 0);

						if (this.options.size !== false) {
							var that = this,
								$window = $(window);
							this.setMenuSize();

							if (this.options.liveSearch) {
								this.$searchbox.off('input.setMenuSize propertychange.setMenuSize').on('input.setMenuSize propertychange.setMenuSize', function () {
									return that.setMenuSize();
								});
							}

							if (this.options.size === 'auto') {
								$window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize').on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {
									return that.setMenuSize();
								});
							} else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {
								$window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');
							}
						}

						this.createView(false, true, refresh);
					},
					setWidth: function setWidth() {
						var that = this;

						if (this.options.width === 'auto') {
							requestAnimationFrame(function () {
								that.$menu.css('min-width', '0');
								that.$element.on('loaded' + EVENT_KEY, function () {
									that.liHeight();
									that.setMenuSize(); // Get correct width if element is hidden

									var $selectClone = that.$newElement.clone().appendTo('body'),
										btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();
									$selectClone.remove(); // Set width to whatever's larger, button title or longest option

									that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);
									that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');
								});
							});
						} else if (this.options.width === 'fit') {
							// Remove inline min-width so width can be changed from 'auto'
							this.$menu.css('min-width', '');
							this.$newElement.css('width', '').addClass('fit-width');
						} else if (this.options.width) {
							// Remove inline min-width so width can be changed from 'auto'
							this.$menu.css('min-width', '');
							this.$newElement.css('width', this.options.width);
						} else {
							// Remove inline min-width/width so width can be changed
							this.$menu.css('min-width', '');
							this.$newElement.css('width', '');
						} // Remove fit-width class if width is changed programmatically


						if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
							this.$newElement[0].classList.remove('fit-width');
						}
					},
					selectPosition: function selectPosition() {
						this.$bsContainer = $('<div class="bs-container" />');

						var that = this,
							$container = $(this.options.container),
							pos,
							containerPos,
							actualHeight,
							getPlacement = function getPlacement($element) {
								var containerPosition = {},
									// fall back to dropdown's default display setting if display is not manually set
									display = that.options.display || ( // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default
										$.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display : false);
								that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));
								pos = $element.offset();

								if (!$container.is('body')) {
									containerPos = $container.offset();
									containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();
									containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();
								} else {
									containerPos = {
										top: 0,
										left: 0
									};
								}

								actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight; // Bootstrap 4+ uses Popper for menu positioning

								if (version.major < 4 || display === 'static') {
									containerPosition.top = pos.top - containerPos.top + actualHeight;
									containerPosition.left = pos.left - containerPos.left;
								}

								containerPosition.width = $element[0].offsetWidth;
								that.$bsContainer.css(containerPosition);
							};

						this.$button.on('click.bs.dropdown.data-api', function () {
							if (that.isDisabled()) {
								return;
							}

							getPlacement(that.$newElement);
							that.$bsContainer.appendTo(that.options.container).toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW)).append(that.$menu);
						});
						$(window).off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId).on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {
							var isActive = that.$newElement.hasClass(classNames.SHOW);
							if (isActive) getPlacement(that.$newElement);
						});
						this.$element.on('hide' + EVENT_KEY, function () {
							that.$menu.data('height', that.$menu.height());
							that.$bsContainer.detach();
						});
					},
					setOptionStatus: function setOptionStatus(selectedOnly) {
						var that = this;
						that.noScroll = false;

						if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {
							for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {
								var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],
									option = liData.option;

								if (option) {
									if (selectedOnly !== true) {
										that.setDisabled(liData.index, liData.disabled);
									}

									that.setSelected(liData.index, option.selected);
								}
							}
						}
					},

					/**
					 * @param {number} index - the index of the option that is being changed
					 * @param {boolean} selected - true if the option is being selected, false if being deselected
					 */
					setSelected: function setSelected(index, selected) {
						var li = this.selectpicker.main.elements[index],
							liData = this.selectpicker.main.data[index],
							activeIndexIsSet = this.activeIndex !== undefined,
							thisIsActive = this.activeIndex === index,
							prevActive,
							a,
							// if current option is already active
							// OR
							// if the current option is being selected, it's NOT multiple, and
							// activeIndex is undefined:
							//  - when the menu is first being opened, OR
							//  - after a search has been performed, OR
							//  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeIndex)
							keepActive = thisIsActive || selected && !this.multiple && !activeIndexIsSet;
						liData.selected = selected;
						a = li.firstChild;

						if (selected) {
							this.selectedIndex = index;
						}

						li.classList.toggle('selected', selected);

						if (keepActive) {
							this.focusItem(li, liData);
							this.selectpicker.view.currentActive = li;
							this.activeIndex = index;
						} else {
							this.defocusItem(li);
						}

						if (a) {
							a.classList.toggle('selected', selected);

							if (selected) {
								a.setAttribute('aria-selected', true);
							} else {
								if (this.multiple) {
									a.setAttribute('aria-selected', false);
								} else {
									a.removeAttribute('aria-selected');
								}
							}
						}

						if (!keepActive && !activeIndexIsSet && selected && this.prevActiveIndex !== undefined) {
							prevActive = this.selectpicker.main.elements[this.prevActiveIndex];
							this.defocusItem(prevActive);
						}
					},

					/**
					 * @param {number} index - the index of the option that is being disabled
					 * @param {boolean} disabled - true if the option is being disabled, false if being enabled
					 */
					setDisabled: function setDisabled(index, disabled) {
						var li = this.selectpicker.main.elements[index],
							a;
						this.selectpicker.main.data[index].disabled = disabled;
						a = li.firstChild;
						li.classList.toggle(classNames.DISABLED, disabled);

						if (a) {
							if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);

							if (disabled) {
								a.setAttribute('aria-disabled', disabled);
								a.setAttribute('tabindex', -1);
							} else {
								a.removeAttribute('aria-disabled');
								a.setAttribute('tabindex', 0);
							}
						}
					},
					isDisabled: function isDisabled() {
						return this.$element[0].disabled;
					},
					checkDisabled: function checkDisabled() {
						if (this.isDisabled()) {
							this.$newElement[0].classList.add(classNames.DISABLED);
							this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);
						} else {
							if (this.$button[0].classList.contains(classNames.DISABLED)) {
								this.$newElement[0].classList.remove(classNames.DISABLED);
								this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);
							}
						}
					},
					clickListener: function clickListener() {
						var that = this,
							$document = $(document);
						$document.data('spaceSelect', false);
						this.$button.on('keyup', function (e) {
							if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {
								e.preventDefault();
								$document.data('spaceSelect', false);
							}
						});
						this.$newElement.on('show.bs.dropdown', function () {
							if (version.major > 3 && !that.dropdown) {
								that.dropdown = that.$button.data('bs.dropdown');
								that.dropdown._menu = that.$menu[0];
							}
						});
						this.$button.on('click.bs.dropdown.data-api', function () {
							if (!that.$newElement.hasClass(classNames.SHOW)) {
								that.setSize();
							}
						});

						function setFocus() {
							if (that.options.liveSearch) {
								that.$searchbox.trigger('focus');
							} else {
								that.$menuInner.trigger('focus');
							}
						}

						function checkPopperExists() {
							if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state.isCreated) {
								setFocus();
							} else {
								requestAnimationFrame(checkPopperExists);
							}
						}

						this.$element.on('shown' + EVENT_KEY, function () {
							if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {
								that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;
							}

							if (version.major > 3) {
								requestAnimationFrame(checkPopperExists);
							} else {
								setFocus();
							}
						}); // ensure posinset and setsize are correct before selecting an option via a click

						this.$menuInner.on('mouseenter', 'li a', function (e) {
							var hoverLi = this.parentElement,
								position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,
								index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),
								hoverData = that.selectpicker.current.data[index + position0];
							that.focusItem(hoverLi, hoverData, true);
						});
						this.$menuInner.on('click', 'li a', function (e, retainActive) {
							var $this = $(this),
								element = that.$element[0],
								position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,
								clickedData = that.selectpicker.current.data[$this.parent().index() + position0],
								clickedIndex = clickedData.index,
								prevValue = getSelectValues(element),
								prevIndex = element.selectedIndex,
								prevOption = element.options[prevIndex],
								triggerChange = true; // Don't close on multi choice menu

							if (that.multiple && that.options.maxOptions !== 1) {
								e.stopPropagation();
							}

							e.preventDefault(); // Don't run if the select is disabled

							if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {
								var option = clickedData.option,
									$option = $(option),
									state = option.selected,
									$optgroup = $option.parent('optgroup'),
									$optgroupOptions = $optgroup.find('option'),
									maxOptions = that.options.maxOptions,
									maxOptionsGrp = $optgroup.data('maxOptions') || false;
								if (clickedIndex === that.activeIndex) retainActive = true;

								if (!retainActive) {
									that.prevActiveIndex = that.activeIndex;
									that.activeIndex = undefined;
								}

								if (!that.multiple) {
									// Deselect all others if not multi select box
									if (prevOption) prevOption.selected = false;
									option.selected = true;
									that.setSelected(clickedIndex, true);
								} else {
									// Toggle the one we have chosen if we are multi select.
									option.selected = !state;
									that.setSelected(clickedIndex, !state);
									that.focusedParent.focus();

									if (maxOptions !== false || maxOptionsGrp !== false) {
										var maxReached = maxOptions < getSelectedOptions(element).length,
											maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;

										if (maxOptions && maxReached || maxOptionsGrp && maxReachedGrp) {
											if (maxOptions && maxOptions == 1) {
												element.selectedIndex = -1;
												option.selected = true;
												that.setOptionStatus(true);
											} else if (maxOptionsGrp && maxOptionsGrp == 1) {
												for (var i = 0; i < $optgroupOptions.length; i++) {
													var _option = $optgroupOptions[i];
													_option.selected = false;
													that.setSelected(_option.liIndex, false);
												}

												option.selected = true;
												that.setSelected(clickedIndex, true);
											} else {
												var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,
													maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,
													maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
													maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
													$notify = $('<div class="notify"></div>'); // If {var} is set in array, replace it

												/** @deprecated */

												if (maxOptionsArr[2]) {
													maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
													maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
												}

												option.selected = false;
												that.$menu.append($notify);

												if (maxOptions && maxReached) {
													$notify.append($('<div>' + maxTxt + '</div>'));
													triggerChange = false;
													that.$element.trigger('maxReached' + EVENT_KEY);
												}

												if (maxOptionsGrp && maxReachedGrp) {
													$notify.append($('<div>' + maxTxtGrp + '</div>'));
													triggerChange = false;
													that.$element.trigger('maxReachedGrp' + EVENT_KEY);
												}

												setTimeout(function () {
													that.setSelected(clickedIndex, false);
												}, 10);
												$notify[0].classList.add('fadeOut');
												setTimeout(function () {
													$notify.remove();
												}, 1050);
											}
										}
									}
								}

								if (!that.multiple || that.multiple && that.options.maxOptions === 1) {
									that.$button.trigger('focus');
								} else if (that.options.liveSearch) {
									that.$searchbox.trigger('focus');
								} // Trigger select 'change'


								if (triggerChange) {
									if (that.multiple || prevIndex !== element.selectedIndex) {
										// $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.
										changedArguments = [option.index, $option.prop('selected'), prevValue];
										that.$element.triggerNative('change');
									}
								}
							}
						});
						this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {
							if (e.currentTarget == this) {
								e.preventDefault();
								e.stopPropagation();

								if (that.options.liveSearch && !$(e.target).hasClass('close')) {
									that.$searchbox.trigger('focus');
								} else {
									that.$button.trigger('focus');
								}
							}
						});
						this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {
							e.preventDefault();
							e.stopPropagation();

							if (that.options.liveSearch) {
								that.$searchbox.trigger('focus');
							} else {
								that.$button.trigger('focus');
							}
						});
						this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {
							that.$button.trigger('click');
						});
						this.$searchbox.on('click', function (e) {
							e.stopPropagation();
						});
						this.$menu.on('click', '.actions-btn', function (e) {
							if (that.options.liveSearch) {
								that.$searchbox.trigger('focus');
							} else {
								that.$button.trigger('focus');
							}

							e.preventDefault();
							e.stopPropagation();

							if ($(this).hasClass('bs-select-all')) {
								that.selectAll();
							} else {
								that.deselectAll();
							}
						});
						this.$button.on('focus' + EVENT_KEY, function (e) {
							var tabindex = that.$element[0].getAttribute('tabindex'); // only change when button is actually focused

							if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {
								// apply select element's tabindex to ensure correct order is followed when tabbing to the next element
								this.setAttribute('tabindex', tabindex); // set element's tabindex to -1 to allow for reverse tabbing

								that.$element[0].setAttribute('tabindex', -1);
								that.selectpicker.view.tabindex = tabindex;
							}
						}).on('blur' + EVENT_KEY, function (e) {
							// revert everything to original tabindex
							if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {
								that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);
								this.setAttribute('tabindex', -1);
								that.selectpicker.view.tabindex = undefined;
							}
						});
						this.$element.on('change' + EVENT_KEY, function () {
							that.render();
							that.$element.trigger('changed' + EVENT_KEY, changedArguments);
							changedArguments = null;
						}).on('focus' + EVENT_KEY, function () {
							if (!that.options.mobile) that.$button[0].focus();
						});
					},
					liveSearchListener: function liveSearchListener() {
						var that = this;
						this.$button.on('click.bs.dropdown.data-api', function () {
							if (!!that.$searchbox.val()) {
								that.$searchbox.val('');
								that.selectpicker.search.previousValue = undefined;
							}
						});
						this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {
							e.stopPropagation();
						});
						this.$searchbox.on('input propertychange', function () {
							var searchValue = that.$searchbox[0].value;
							that.selectpicker.search.elements = [];
							that.selectpicker.search.data = [];

							if (searchValue) {
								var i,
									searchMatch = [],
									q = searchValue.toUpperCase(),
									cache = {},
									cacheArr = [],
									searchStyle = that._searchStyle(),
									normalizeSearch = that.options.liveSearchNormalize;

								if (normalizeSearch) q = normalizeToBase(q);

								for (var i = 0; i < that.selectpicker.main.data.length; i++) {
									var li = that.selectpicker.main.data[i];

									if (!cache[i]) {
										cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);
									}

									if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {
										if (li.headerIndex > 0) {
											cache[li.headerIndex - 1] = true;
											cacheArr.push(li.headerIndex - 1);
										}

										cache[li.headerIndex] = true;
										cacheArr.push(li.headerIndex);
										cache[li.lastIndex + 1] = true;
									}

									if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);
								}

								for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {
									var index = cacheArr[i],
										prevIndex = cacheArr[i - 1],
										li = that.selectpicker.main.data[index],
										liPrev = that.selectpicker.main.data[prevIndex];

									if (li.type !== 'divider' || li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i) {
										that.selectpicker.search.data.push(li);
										searchMatch.push(that.selectpicker.main.elements[index]);
									}
								}

								that.activeIndex = undefined;
								that.noScroll = true;
								that.$menuInner.scrollTop(0);
								that.selectpicker.search.elements = searchMatch;
								that.createView(true);
								showNoResults.call(that, searchMatch, searchValue);
							} else if (that.selectpicker.search.previousValue) {
								// for IE11 (#2402)
								that.$menuInner.scrollTop(0);
								that.createView(false);
							}

							that.selectpicker.search.previousValue = searchValue;
						});
					},
					_searchStyle: function _searchStyle() {
						return this.options.liveSearchStyle || 'contains';
					},
					val: function val(value) {
						var element = this.$element[0];

						if (typeof value !== 'undefined') {
							var prevValue = getSelectValues(element);
							changedArguments = [null, null, prevValue];
							this.$element.val(value).trigger('changed' + EVENT_KEY, changedArguments);

							if (this.$newElement.hasClass(classNames.SHOW)) {
								if (this.multiple) {
									this.setOptionStatus(true);
								} else {
									var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;

									if (typeof liSelectedIndex === 'number') {
										this.setSelected(this.selectedIndex, false);
										this.setSelected(liSelectedIndex, true);
									}
								}
							}

							this.render();
							changedArguments = null;
							return this.$element;
						} else {
							return this.$element.val();
						}
					},
					changeAll: function changeAll(status) {
						if (!this.multiple) return;
						if (typeof status === 'undefined') status = true;
						var element = this.$element[0],
							previousSelected = 0,
							currentSelected = 0,
							prevValue = getSelectValues(element);
						element.classList.add('bs-select-hidden');

						for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {
							var liData = data[i],
								option = liData.option;

							if (option && !liData.disabled && liData.type !== 'divider') {
								if (liData.selected) previousSelected++;
								option.selected = status;
								if (status === true) currentSelected++;
							}
						}

						element.classList.remove('bs-select-hidden');
						if (previousSelected === currentSelected) return;
						this.setOptionStatus();
						changedArguments = [null, null, prevValue];
						this.$element.triggerNative('change');
					},
					selectAll: function selectAll() {
						return this.changeAll(true);
					},
					deselectAll: function deselectAll() {
						return this.changeAll(false);
					},
					toggle: function toggle(e) {
						e = e || window.event;
						if (e) e.stopPropagation();
						this.$button.trigger('click.bs.dropdown.data-api');
					},
					keydown: function keydown(e) {
						var $this = $(this),
							isToggle = $this.hasClass('dropdown-toggle'),
							$parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),
							that = $parent.data('this'),
							$items = that.findLis(),
							index,
							isActive,
							liActive,
							activeLi,
							offset,
							updateScroll = false,
							downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,
							isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,
							scrollTop = that.$menuInner[0].scrollTop,
							isVirtual = that.isVirtual(),
							position0 = isVirtual === true ? that.selectpicker.view.position0 : 0; // do nothing if a function key is pressed

						if (e.which >= 112 && e.which <= 123) return;
						isActive = that.$newElement.hasClass(classNames.SHOW);

						if (!isActive && (isArrowKey || e.which >= 48 && e.which <= 57 || e.which >= 96 && e.which <= 105 || e.which >= 65 && e.which <= 90)) {
							that.$button.trigger('click.bs.dropdown.data-api');

							if (that.options.liveSearch) {
								that.$searchbox.trigger('focus');
								return;
							}
						}

						if (e.which === keyCodes.ESCAPE && isActive) {
							e.preventDefault();
							that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');
						}

						if (isArrowKey) {
							// if up or down
							if (!$items.length) return;
							liActive = that.selectpicker.main.elements[that.activeIndex];
							index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;

							if (index !== -1) {
								that.defocusItem(liActive);
							}

							if (e.which === keyCodes.ARROW_UP) {
								// up
								if (index !== -1) index--;
								if (index + position0 < 0) index += $items.length;

								if (!that.selectpicker.view.canHighlight[index + position0]) {
									index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;
									if (index === -1) index = $items.length - 1;
								}
							} else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {
								// down
								index++;
								if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;

								if (!that.selectpicker.view.canHighlight[index + position0]) {
									index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);
								}
							}

							e.preventDefault();
							var liActiveIndex = position0 + index;

							if (e.which === keyCodes.ARROW_UP) {
								// up
								// scroll to bottom and highlight last option
								if (position0 === 0 && index === $items.length - 1) {
									that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;
									liActiveIndex = that.selectpicker.current.elements.length - 1;
								} else {
									activeLi = that.selectpicker.current.data[liActiveIndex];
									offset = activeLi.position - activeLi.height;
									updateScroll = offset < scrollTop;
								}
							} else if (e.which === keyCodes.ARROW_DOWN || downOnTab) {
								// down
								// scroll to top and highlight first option
								if (index === that.selectpicker.view.firstHighlightIndex) {
									that.$menuInner[0].scrollTop = 0;
									liActiveIndex = that.selectpicker.view.firstHighlightIndex;
								} else {
									activeLi = that.selectpicker.current.data[liActiveIndex];
									offset = activeLi.position - that.sizeInfo.menuInnerHeight;
									updateScroll = offset > scrollTop;
								}
							}

							liActive = that.selectpicker.current.elements[liActiveIndex];
							that.activeIndex = that.selectpicker.current.data[liActiveIndex].index;
							that.focusItem(liActive);
							that.selectpicker.view.currentActive = liActive;
							if (updateScroll) that.$menuInner[0].scrollTop = offset;

							if (that.options.liveSearch) {
								that.$searchbox.trigger('focus');
							} else {
								$this.trigger('focus');
							}
						} else if (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which) || e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory) {
							var searchMatch,
								matches = [],
								keyHistory;
							e.preventDefault();
							that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];
							if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);
							that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();
							keyHistory = that.selectpicker.keydown.keyHistory; // if all letters are the same, set keyHistory to just the first character when searching

							if (/^(.)\1+$/.test(keyHistory)) {
								keyHistory = keyHistory.charAt(0);
							} // find matches


							for (var i = 0; i < that.selectpicker.current.data.length; i++) {
								var li = that.selectpicker.current.data[i],
									hasMatch;
								hasMatch = stringSearch(li, keyHistory, 'startsWith', true);

								if (hasMatch && that.selectpicker.view.canHighlight[i]) {
									matches.push(li.index);
								}
							}

							if (matches.length) {
								var matchIndex = 0;
								$items.removeClass('active').find('a').removeClass('active'); // either only one key has been pressed or they are all the same key

								if (keyHistory.length === 1) {
									matchIndex = matches.indexOf(that.activeIndex);

									if (matchIndex === -1 || matchIndex === matches.length - 1) {
										matchIndex = 0;
									} else {
										matchIndex++;
									}
								}

								searchMatch = matches[matchIndex];
								activeLi = that.selectpicker.main.data[searchMatch];

								if (scrollTop - activeLi.position > 0) {
									offset = activeLi.position - activeLi.height;
									updateScroll = true;
								} else {
									offset = activeLi.position - that.sizeInfo.menuInnerHeight; // if the option is already visible at the current scroll position, just keep it the same

									updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;
								}

								liActive = that.selectpicker.main.elements[searchMatch];
								that.activeIndex = matches[matchIndex];
								that.focusItem(liActive);
								if (liActive) liActive.firstChild.focus();
								if (updateScroll) that.$menuInner[0].scrollTop = offset;
								$this.trigger('focus');
							}
						} // Select focused option if "Enter", "Spacebar" or "Tab" (when selectOnTab is true) are pressed inside the menu.


						if (isActive && (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory || e.which === keyCodes.ENTER || e.which === keyCodes.TAB && that.options.selectOnTab)) {
							if (e.which !== keyCodes.SPACE) e.preventDefault();

							if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {
								that.$menuInner.find('.active a').trigger('click', true); // retain active class

								$this.trigger('focus');

								if (!that.options.liveSearch) {
									// Prevent screen from scrolling if the user hits the spacebar
									e.preventDefault(); // Fixes spacebar selection of dropdown items in FF & IE

									$(document).data('spaceSelect', true);
								}
							}
						}
					},
					mobile: function mobile() {
						// ensure mobile is set to true if mobile function is called after init
						this.options.mobile = true;
						this.$element[0].classList.add('mobile-device');
					},
					refresh: function refresh() {
						// update options if data attributes have been changed
						var config = $.extend({}, this.options, this.$element.data());
						this.options = config;
						this.checkDisabled();
						this.buildData();
						this.setStyle();
						this.render();
						this.buildList();
						this.setWidth();
						this.setSize(true);
						this.$element.trigger('refreshed' + EVENT_KEY);
					},
					hide: function hide() {
						this.$newElement.hide();
					},
					show: function show() {
						this.$newElement.show();
					},
					remove: function remove() {
						this.$newElement.remove();
						this.$element.remove();
					},
					destroy: function destroy() {
						this.$newElement.before(this.$element).remove();

						if (this.$bsContainer) {
							this.$bsContainer.remove();
						} else {
							this.$menu.remove();
						}

						if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {
							this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);
						}

						this.$element.off(EVENT_KEY).removeData('selectpicker').removeClass('bs-select-hidden selectpicker');
						$(window).off(EVENT_KEY + '.' + this.selectId);
					}
				}; // SELECTPICKER PLUGIN DEFINITION
				// ==============================

				function Plugin(option) {
					// get the args of the outer function..
					var args = arguments; // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them
					// to get lost/corrupted in android 2.3 and IE9 #715 #775

					var _option = option;
					[].shift.apply(args); // if the version was not set successfully

					if (!version.success) {
						// try to retreive it again
						try {
							version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');
						} catch (err) {
							// fall back to use BootstrapVersion if set
							if (Selectpicker.BootstrapVersion) {
								version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');
							} else {
								version.full = [version.major, '0', '0'];
								console.warn('There was an issue retrieving Bootstrap\'s version. ' + 'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' + 'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.', err);
							}
						}

						version.major = version.full[0];
						version.success = true;
					}

					if (version.major === '4') {
						// some defaults need to be changed if using Bootstrap 4
						// check to see if they have already been manually changed before forcing them to update
						var toUpdate = [];
						if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({
							name: 'style',
							className: 'BUTTONCLASS'
						});
						if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({
							name: 'iconBase',
							className: 'ICONBASE'
						});
						if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({
							name: 'tickIcon',
							className: 'TICKICON'
						});
						classNames.DIVIDER = 'dropdown-divider';
						classNames.SHOW = 'show';
						classNames.BUTTONCLASS = 'btn-light';
						classNames.POPOVERHEADER = 'popover-header';
						classNames.ICONBASE = '';
						classNames.TICKICON = 'bs-ok-default';

						for (var i = 0; i < toUpdate.length; i++) {
							var option = toUpdate[i];
							Selectpicker.DEFAULTS[option.name] = classNames[option.className];
						}
					}

					var value;
					var chain = this.each(function () {
						var $this = $(this);

						if ($this.is('select')) {
							var data = $this.data('selectpicker'),
								options = _typeof(_option) == 'object' && _option;

							if (!data) {
								var dataAttributes = $this.data();

								for (var dataAttr in dataAttributes) {
									if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
										delete dataAttributes[dataAttr];
									}
								}

								var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);
								config.template = $.extend({}, Selectpicker.DEFAULTS.template, $.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}, dataAttributes.template, options.template);
								$this.data('selectpicker', data = new Selectpicker(this, config));
							} else if (options) {
								for (var i in options) {
									if (Object.prototype.hasOwnProperty.call(options, i)) {
										data.options[i] = options[i];
									}
								}
							}

							if (typeof _option == 'string') {
								if (data[_option] instanceof Function) {
									value = data[_option].apply(data, args);
								} else {
									value = data.options[_option];
								}
							}
						}
					});

					if (typeof value !== 'undefined') {
						// noinspection JSUnusedAssignment
						return value;
					} else {
						return chain;
					}
				}

				var old = $.fn.selectpicker;
				$.fn.selectpicker = Plugin;
				$.fn.selectpicker.Constructor = Selectpicker; // SELECTPICKER NO CONFLICT
				// ========================

				$.fn.selectpicker.noConflict = function () {
					$.fn.selectpicker = old;
					return this;
				}; // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3


				function keydownHandler() {
					if ($.fn.dropdown) {
						// wait to define until function is called in case Bootstrap isn't loaded yet
						var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;
						return bootstrapKeydown.apply(this, arguments);
					}
				}

				$(document).off('keydown.bs.dropdown.data-api').on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [data-toggle="dropdown"]', keydownHandler).on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler).on('keydown' + EVENT_KEY, '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown).on('focusin.modal', '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', function (e) {
					e.stopPropagation();
				}); // SELECTPICKER DATA-API
				// =====================

				$(window).on('load' + EVENT_KEY + '.data-api', function () {
					$('.selectpicker').each(function () {
						var $selectpicker = $(this);
						Plugin.call($selectpicker, $selectpicker.data());
					});
				});
			})(jQuery);
		});

		/***/
	}),
	/* 13 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*! lightgallery - v1.10.0 - 2020-11-07
* http://sachinchoolur.github.io/lightGallery/
* Copyright (c) 2020 Sachin N; Licensed GPLv3 */
		(function (root, factory) {
			if (true) {
				// AMD. Register as an anonymous module unless amdModuleId is set
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (a0) {
					return factory(a0);
				}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(this, function ($) {
			(function () {
				'use strict';

				var defaults = {
					mode: 'lg-slide',
					// Ex : 'ease'
					cssEasing: 'ease',
					//'for jquery animation'
					easing: 'linear',
					speed: 600,
					height: '100%',
					width: '100%',
					addClass: '',
					startClass: 'lg-start-zoom',
					backdropDuration: 150,
					// Set 0, if u don't want to hide the controls
					hideBarsDelay: 6000,
					useLeft: false,
					// aria-labelledby attribute fot gallery
					ariaLabelledby: '',
					//aria-describedby attribute for gallery
					ariaDescribedby: '',
					closable: true,
					loop: true,
					escKey: true,
					keyPress: true,
					controls: true,
					slideEndAnimatoin: true,
					hideControlOnEnd: false,
					mousewheel: true,
					getCaptionFromTitleOrAlt: true,
					// .lg-item || '.lg-sub-html'
					appendSubHtmlTo: '.lg-sub-html',
					subHtmlSelectorRelative: false,

					/**
					 * @desc number of preload slides
					 * will execute only after the current slide is fully loaded.
					 *
					 * @ex you clicked on 4th image and if preload = 1 then 3rd slide and 5th
					 * slide will be loaded in the background after the 4th slide is fully loaded..
					 * if preload is 2 then 2nd 3rd 5th 6th slides will be preloaded.. ... ...
					 *
					 */
					preload: 1,
					showAfterLoad: true,
					selector: '',
					selectWithin: '',
					nextHtml: '',
					prevHtml: '',
					// 0, 1
					index: false,
					iframeMaxWidth: '100%',
					download: true,
					counter: true,
					appendCounterTo: '.lg-toolbar',
					swipeThreshold: 50,
					enableSwipe: true,
					enableDrag: true,
					dynamic: false,
					dynamicEl: [],
					galleryId: 1,
					supportLegacyBrowser: true
				};

				function Plugin(element, options) {
					// Current lightGallery element
					this.el = element; // Current jquery element

					this.$el = $(element); // lightGallery settings

					this.s = $.extend({}, defaults, options); // When using dynamic mode, ensure dynamicEl is an array

					if (this.s.dynamic && this.s.dynamicEl !== 'undefined' && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) {
						throw 'When using dynamic mode, you must also define dynamicEl as an Array.';
					} // lightGallery modules


					this.modules = {}; // false when lightgallery complete first slide;

					this.lGalleryOn = false;
					this.lgBusy = false; // Timeout function for hiding controls;

					this.hideBarTimeout = false; // To determine browser supports for touch events;

					this.isTouch = 'ontouchstart' in document.documentElement; // Disable hideControlOnEnd if sildeEndAnimation is true

					if (this.s.slideEndAnimatoin) {
						this.s.hideControlOnEnd = false;
					} // Gallery items


					if (this.s.dynamic) {
						this.$items = this.s.dynamicEl;
					} else {
						if (this.s.selector === 'this') {
							this.$items = this.$el;
						} else if (this.s.selector !== '') {
							if (this.s.selectWithin) {
								this.$items = $(this.s.selectWithin).find(this.s.selector);
							} else {
								this.$items = this.$el.find($(this.s.selector));
							}
						} else {
							this.$items = this.$el.children();
						}
					} // .lg-item


					this.$slide = ''; // .lg-outer

					this.$outer = '';
					this.init();
					return this;
				}

				Plugin.prototype.init = function () {
					var _this = this; // s.preload should not be more than $item.length


					if (_this.s.preload > _this.$items.length) {
						_this.s.preload = _this.$items.length;
					} // if dynamic option is enabled execute immediately


					var _hash = window.location.hash;

					if (_hash.indexOf('lg=' + this.s.galleryId) > 0) {
						_this.index = parseInt(_hash.split('&slide=')[1], 10);
						$('body').addClass('lg-from-hash');

						if (!$('body').hasClass('lg-on')) {
							setTimeout(function () {
								_this.build(_this.index);
							});
							$('body').addClass('lg-on');
						}
					}

					if (_this.s.dynamic) {
						_this.$el.trigger('onBeforeOpen.lg');

						_this.index = _this.s.index || 0; // prevent accidental double execution

						if (!$('body').hasClass('lg-on')) {
							setTimeout(function () {
								_this.build(_this.index);

								$('body').addClass('lg-on');
							});
						}
					} else {
						// Using different namespace for click because click event should not unbind if selector is same object('this')
						_this.$items.on('click.lgcustom', function (event) {
							// For IE8
							try {
								event.preventDefault();
								event.preventDefault();
							} catch (er) {
								event.returnValue = false;
							}

							_this.$el.trigger('onBeforeOpen.lg');

							_this.index = _this.s.index || _this.$items.index(this); // prevent accidental double execution

							if (!$('body').hasClass('lg-on')) {
								_this.build(_this.index);

								$('body').addClass('lg-on');
							}
						});
					}
				};

				Plugin.prototype.build = function (index) {
					var _this = this;

					_this.structure(); // module constructor


					$.each($.fn.lightGallery.modules, function (key) {
						_this.modules[key] = new $.fn.lightGallery.modules[key](_this.el);
					}); // initiate slide function

					_this.slide(index, false, false, false);

					if (_this.s.keyPress) {
						_this.keyPress();
					}

					if (_this.$items.length > 1) {
						_this.arrow();

						setTimeout(function () {
							_this.enableDrag();

							_this.enableSwipe();
						}, 50);

						if (_this.s.mousewheel) {
							_this.mousewheel();
						}
					} else {
						_this.$slide.on('click.lg', function () {
							_this.$el.trigger('onSlideClick.lg');
						});
					}

					_this.counter();

					_this.closeGallery();

					_this.$el.trigger('onAfterOpen.lg'); // Hide controllers if mouse doesn't move for some period


					if (_this.s.hideBarsDelay > 0) {
						// Hide controllers if mouse doesn't move for some period
						_this.$outer.on('mousemove.lg click.lg touchstart.lg', function () {
							_this.$outer.removeClass('lg-hide-items');

							clearTimeout(_this.hideBarTimeout); // Timeout will be cleared on each slide movement also

							_this.hideBarTimeout = setTimeout(function () {
								_this.$outer.addClass('lg-hide-items');
							}, _this.s.hideBarsDelay);
						});
					}

					_this.$outer.trigger('mousemove.lg');
				};

				Plugin.prototype.structure = function () {
					var list = '';
					var controls = '';
					var i = 0;
					var subHtmlCont = '';
					var template;

					var _this = this;

					$('body').append('<div class="lg-backdrop"></div>');
					$('.lg-backdrop').css('transition-duration', this.s.backdropDuration + 'ms'); // Create gallery items

					for (i = 0; i < this.$items.length; i++) {
						list += '<div class="lg-item"></div>';
					} // Create controlls


					if (this.s.controls && this.$items.length > 1) {
						controls = '<div class="lg-actions">' + '<button type="button" aria-label="Previous slide" class="lg-prev lg-icon">' + this.s.prevHtml + '</button>' + '<button type="button" aria-label="Next slide" class="lg-next lg-icon">' + this.s.nextHtml + '</button>' + '</div>';
					}

					if (this.s.appendSubHtmlTo === '.lg-sub-html') {
						subHtmlCont = '<div role="status" aria-live="polite" class="lg-sub-html"></div>';
					}

					var ariaLabelledby = this.s.ariaLabelledby ? 'aria-labelledby="' + this.s.ariaLabelledby + '"' : '';
					var ariaDescribedby = this.s.ariaDescribedby ? 'aria-describedby="' + this.s.ariaDescribedby + '"' : '';
					template = '<div tabindex="-1" aria-modal="true" ' + ariaLabelledby + ' ' + ariaDescribedby + ' role="dialog" class="lg-outer ' + this.s.addClass + ' ' + this.s.startClass + '">' + '<div class="lg" style="width:' + this.s.width + '; height:' + this.s.height + '">' + '<div class="lg-inner">' + list + '</div>' + '<div class="lg-toolbar lg-group">' + '<button type="button" aria-label="Close gallery" class="lg-close lg-icon"></button>' + '</div>' + controls + subHtmlCont + '</div>' + '</div>';
					$('body').append(template);
					this.$outer = $('.lg-outer');
					this.$outer.focus();
					this.$slide = this.$outer.find('.lg-item');

					if (this.s.useLeft) {
						this.$outer.addClass('lg-use-left'); // Set mode lg-slide if use left is true;

						this.s.mode = 'lg-slide';
					} else {
						this.$outer.addClass('lg-use-css3');
					} // For fixed height gallery


					_this.setTop();

					$(window).on('resize.lg orientationchange.lg', function () {
						setTimeout(function () {
							_this.setTop();
						}, 100);
					}); // add class lg-current to remove initial transition

					this.$slide.eq(this.index).addClass('lg-current'); // add Class for css support and transition mode

					if (this.doCss()) {
						this.$outer.addClass('lg-css3');
					} else {
						this.$outer.addClass('lg-css'); // Set speed 0 because no animation will happen if browser doesn't support css3

						this.s.speed = 0;
					}

					this.$outer.addClass(this.s.mode);

					if (this.s.enableDrag && this.$items.length > 1) {
						this.$outer.addClass('lg-grab');
					}

					if (this.s.showAfterLoad) {
						this.$outer.addClass('lg-show-after-load');
					}

					if (this.doCss()) {
						var $inner = this.$outer.find('.lg-inner');
						$inner.css('transition-timing-function', this.s.cssEasing);
						$inner.css('transition-duration', this.s.speed + 'ms');
					}

					setTimeout(function () {
						$('.lg-backdrop').addClass('in');
					});
					setTimeout(function () {
						_this.$outer.addClass('lg-visible');
					}, this.s.backdropDuration);

					if (this.s.download) {
						this.$outer.find('.lg-toolbar').append('<a id="lg-download" aria-label="Download" target="_blank" download class="lg-download lg-icon"></a>');
					} // Store the current scroll top value to scroll back after closing the gallery..


					this.prevScrollTop = $(window).scrollTop();
				}; // For fixed height gallery


				Plugin.prototype.setTop = function () {
					if (this.s.height !== '100%') {
						var wH = $(window).height();
						var top = (wH - parseInt(this.s.height, 10)) / 2;
						var $lGallery = this.$outer.find('.lg');

						if (wH >= parseInt(this.s.height, 10)) {
							$lGallery.css('top', top + 'px');
						} else {
							$lGallery.css('top', '0px');
						}
					}
				}; // Find css3 support


				Plugin.prototype.doCss = function () {
					// check for css animation support
					var support = function support() {
						var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
						var root = document.documentElement;
						var i = 0;

						for (i = 0; i < transition.length; i++) {
							if (transition[i] in root.style) {
								return true;
							}
						}
					};

					if (support()) {
						return true;
					}

					return false;
				};
				/**
				 *  @desc Check the given src is video
				 *  @param {String} src
				 *  @return {Object} video type
				 *  Ex:{ youtube  :  ["//www.youtube.com/watch?v=c0asJgSyxcY", "c0asJgSyxcY"] }
				 */


				Plugin.prototype.isVideo = function (src, index) {
					var html;

					if (this.s.dynamic) {
						html = this.s.dynamicEl[index].html;
					} else {
						html = this.$items.eq(index).attr('data-html');
					}

					if (!src) {
						if (html) {
							return {
								html5: true
							};
						} else {
							console.error('lightGallery :- data-src is not provided on slide item ' + (index + 1) + '. Please make sure the selector property is properly configured. More info - http://sachinchoolur.github.io/lightGallery/demos/html-markup.html');
							return false;
						}
					}

					var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i);
					var vimeo = src.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)/i);
					var dailymotion = src.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i);
					var vk = src.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);

					if (youtube) {
						return {
							youtube: youtube
						};
					} else if (vimeo) {
						return {
							vimeo: vimeo
						};
					} else if (dailymotion) {
						return {
							dailymotion: dailymotion
						};
					} else if (vk) {
						return {
							vk: vk
						};
					}
				};
				/**
				 *  @desc Create image counter
				 *  Ex: 1/10
				 */


				Plugin.prototype.counter = function () {
					if (this.s.counter) {
						$(this.s.appendCounterTo).append('<div id="lg-counter" role="status" aria-live="polite"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.$items.length + '</span></div>');
					}
				};
				/**
				 *  @desc add sub-html into the slide
				 *  @param {Number} index - index of the slide
				 */


				Plugin.prototype.addHtml = function (index) {
					var subHtml = null;
					var subHtmlUrl;
					var $currentEle;

					if (this.s.dynamic) {
						if (this.s.dynamicEl[index].subHtmlUrl) {
							subHtmlUrl = this.s.dynamicEl[index].subHtmlUrl;
						} else {
							subHtml = this.s.dynamicEl[index].subHtml;
						}
					} else {
						$currentEle = this.$items.eq(index);

						if ($currentEle.attr('data-sub-html-url')) {
							subHtmlUrl = $currentEle.attr('data-sub-html-url');
						} else {
							subHtml = $currentEle.attr('data-sub-html');

							if (this.s.getCaptionFromTitleOrAlt && !subHtml) {
								subHtml = $currentEle.attr('title') || $currentEle.find('img').first().attr('alt');
							}
						}
					}

					if (!subHtmlUrl) {
						if (typeof subHtml !== 'undefined' && subHtml !== null) {
							// get first letter of subhtml
							// if first letter starts with . or # get the html form the jQuery object
							var fL = subHtml.substring(0, 1);

							if (fL === '.' || fL === '#') {
								if (this.s.subHtmlSelectorRelative && !this.s.dynamic) {
									subHtml = $currentEle.find(subHtml).html();
								} else {
									subHtml = $(subHtml).html();
								}
							}
						} else {
							subHtml = '';
						}
					}

					if (this.s.appendSubHtmlTo === '.lg-sub-html') {
						if (subHtmlUrl) {
							this.$outer.find(this.s.appendSubHtmlTo).load(subHtmlUrl);
						} else {
							this.$outer.find(this.s.appendSubHtmlTo).html(subHtml);
						}
					} else {
						if (subHtmlUrl) {
							this.$slide.eq(index).load(subHtmlUrl);
						} else {
							this.$slide.eq(index).append(subHtml);
						}
					} // Add lg-empty-html class if title doesn't exist


					if (typeof subHtml !== 'undefined' && subHtml !== null) {
						if (subHtml === '') {
							this.$outer.find(this.s.appendSubHtmlTo).addClass('lg-empty-html');
						} else {
							this.$outer.find(this.s.appendSubHtmlTo).removeClass('lg-empty-html');
						}
					}

					this.$el.trigger('onAfterAppendSubHtml.lg', [index]);
				};
				/**
				 *  @desc Preload slides
				 *  @param {Number} index - index of the slide
				 */


				Plugin.prototype.preload = function (index) {
					var i = 1;
					var j = 1;

					for (i = 1; i <= this.s.preload; i++) {
						if (i >= this.$items.length - index) {
							break;
						}

						this.loadContent(index + i, false, 0);
					}

					for (j = 1; j <= this.s.preload; j++) {
						if (index - j < 0) {
							break;
						}

						this.loadContent(index - j, false, 0);
					}
				};
				/**
				 *  @desc Load slide content into slide.
				 *  @param {Number} index - index of the slide.
				 *  @param {Boolean} rec - if true call loadcontent() function again.
				 *  @param {Boolean} delay - delay for adding complete class. it is 0 except first time.
				 */


				Plugin.prototype.loadContent = function (index, rec, delay) {
					var _this = this;

					var _hasPoster = false;

					var _$img;

					var _src;

					var _poster;

					var _srcset;

					var _sizes;

					var _html;

					var _alt;

					var getResponsiveSrc = function getResponsiveSrc(srcItms) {
						var rsWidth = [];
						var rsSrc = [];

						for (var i = 0; i < srcItms.length; i++) {
							var __src = srcItms[i].split(' '); // Manage empty space


							if (__src[0] === '') {
								__src.splice(0, 1);
							}

							rsSrc.push(__src[0]);
							rsWidth.push(__src[1]);
						}

						var wWidth = $(window).width();

						for (var j = 0; j < rsWidth.length; j++) {
							if (parseInt(rsWidth[j], 10) > wWidth) {
								_src = rsSrc[j];
								break;
							}
						}
					};

					if (_this.s.dynamic) {
						if (_this.s.dynamicEl[index].poster) {
							_hasPoster = true;
							_poster = _this.s.dynamicEl[index].poster;
						}

						_html = _this.s.dynamicEl[index].html;
						_src = _this.s.dynamicEl[index].src;
						_alt = _this.s.dynamicEl[index].alt;

						if (_this.s.dynamicEl[index].responsive) {
							var srcDyItms = _this.s.dynamicEl[index].responsive.split(',');

							getResponsiveSrc(srcDyItms);
						}

						_srcset = _this.s.dynamicEl[index].srcset;
						_sizes = _this.s.dynamicEl[index].sizes;
					} else {
						var $currentEle = _this.$items.eq(index);

						if ($currentEle.attr('data-poster')) {
							_hasPoster = true;
							_poster = $currentEle.attr('data-poster');
						}

						_html = $currentEle.attr('data-html');
						_src = $currentEle.attr('href') || $currentEle.attr('data-src');
						_alt = $currentEle.attr('title') || $currentEle.find('img').first().attr('alt');

						if ($currentEle.attr('data-responsive')) {
							var srcItms = $currentEle.attr('data-responsive').split(',');
							getResponsiveSrc(srcItms);
						}

						_srcset = $currentEle.attr('data-srcset');
						_sizes = $currentEle.attr('data-sizes');
					} //if (_src || _srcset || _sizes || _poster) {


					var iframe = false;

					if (_this.s.dynamic) {
						if (_this.s.dynamicEl[index].iframe) {
							iframe = true;
						}
					} else {
						if (_this.$items.eq(index).attr('data-iframe') === 'true') {
							iframe = true;
						}
					}

					var _isVideo = _this.isVideo(_src, index);

					if (!_this.$slide.eq(index).hasClass('lg-loaded')) {
						if (iframe) {
							_this.$slide.eq(index).prepend('<div class="lg-video-cont lg-has-iframe" style="max-width:' + _this.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + _src + '"  allowfullscreen="true"></iframe></div></div>');
						} else if (_hasPoster) {
							var videoClass = '';

							if (_isVideo && _isVideo.youtube) {
								videoClass = 'lg-has-youtube';
							} else if (_isVideo && _isVideo.vimeo) {
								videoClass = 'lg-has-vimeo';
							} else {
								videoClass = 'lg-has-html5';
							}

							_this.$slide.eq(index).prepend('<div class="lg-video-cont ' + videoClass + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + _poster + '" /></div></div>');
						} else if (_isVideo) {
							_this.$slide.eq(index).prepend('<div class="lg-video-cont "><div class="lg-video"></div></div>');

							_this.$el.trigger('hasVideo.lg', [index, _src, _html]);
						} else {
							_alt = _alt ? 'alt="' + _alt + '"' : '';

							_this.$slide.eq(index).prepend('<div class="lg-img-wrap"><img class="lg-object lg-image" ' + _alt + ' src="' + _src + '" /></div>');
						}

						_this.$el.trigger('onAferAppendSlide.lg', [index]);

						_$img = _this.$slide.eq(index).find('.lg-object');

						if (_sizes) {
							_$img.attr('sizes', _sizes);
						}

						if (_srcset) {
							_$img.attr('srcset', _srcset);

							if (this.s.supportLegacyBrowser) {
								try {
									picturefill({
										elements: [_$img[0]]
									});
								} catch (e) {
									console.warn('lightGallery :- If you want srcset to be supported for older browser please include picturefil version 2 javascript library in your document.');
								}
							}
						}

						if (this.s.appendSubHtmlTo !== '.lg-sub-html') {
							_this.addHtml(index);
						}

						_this.$slide.eq(index).addClass('lg-loaded');
					}

					_this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function () {
						// For first time add some delay for displaying the start animation.
						var _speed = 0; // Do not change the delay value because it is required for zoom plugin.
						// If gallery opened from direct url (hash) speed value should be 0

						if (delay && !$('body').hasClass('lg-from-hash')) {
							_speed = delay;
						}

						setTimeout(function () {
							_this.$slide.eq(index).addClass('lg-complete');

							_this.$el.trigger('onSlideItemLoad.lg', [index, delay || 0]);
						}, _speed);
					}); // @todo check load state for html5 videos


					if (_isVideo && _isVideo.html5 && !_hasPoster) {
						_this.$slide.eq(index).addClass('lg-complete');
					}

					if (rec === true) {
						if (!_this.$slide.eq(index).hasClass('lg-complete')) {
							_this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function () {
								_this.preload(index);
							});
						} else {
							_this.preload(index);
						}
					} //}

				};
				/**
				 *   @desc slide function for lightgallery
				 ** Slide() gets call on start
				 ** ** Set lg.on true once slide() function gets called.
				 ** Call loadContent() on slide() function inside setTimeout
				 ** ** On first slide we do not want any animation like slide of fade
				 ** ** So on first slide( if lg.on if false that is first slide) loadContent() should start loading immediately
				 ** ** Else loadContent() should wait for the transition to complete.
				 ** ** So set timeout s.speed + 50
    <=> ** loadContent() will load slide content in to the particular slide
				 ** ** It has recursion (rec) parameter. if rec === true loadContent() will call preload() function.
				 ** ** preload will execute only when the previous slide is fully loaded (images iframe)
				 ** ** avoid simultaneous image load
    <=> ** Preload() will check for s.preload value and call loadContent() again accoring to preload value
				 ** loadContent()  <====> Preload();
				 *   @param {Number} index - index of the slide
				 *   @param {Boolean} fromTouch - true if slide function called via touch event or mouse drag
				 *   @param {Boolean} fromThumb - true if slide function called via thumbnail click
				 *   @param {String} direction - Direction of the slide(next/prev)
				 */


				Plugin.prototype.slide = function (index, fromTouch, fromThumb, direction) {
					var _prevIndex = this.$outer.find('.lg-current').index();

					var _this = this; // Prevent if multiple call
					// Required for hsh plugin


					if (_this.lGalleryOn && _prevIndex === index) {
						return;
					}

					var _length = this.$slide.length;

					var _time = _this.lGalleryOn ? this.s.speed : 0;

					if (!_this.lgBusy) {
						if (this.s.download) {
							var _src;

							if (_this.s.dynamic) {
								_src = _this.s.dynamicEl[index].downloadUrl !== false && (_this.s.dynamicEl[index].downloadUrl || _this.s.dynamicEl[index].src);
							} else {
								_src = _this.$items.eq(index).attr('data-download-url') !== 'false' && (_this.$items.eq(index).attr('data-download-url') || _this.$items.eq(index).attr('href') || _this.$items.eq(index).attr('data-src'));
							}

							if (_src) {
								$('#lg-download').attr('href', _src);

								_this.$outer.removeClass('lg-hide-download');
							} else {
								_this.$outer.addClass('lg-hide-download');
							}
						}

						this.$el.trigger('onBeforeSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);
						_this.lgBusy = true;
						clearTimeout(_this.hideBarTimeout); // Add title if this.s.appendSubHtmlTo === lg-sub-html

						if (this.s.appendSubHtmlTo === '.lg-sub-html') {
							// wait for slide animation to complete
							setTimeout(function () {
								_this.addHtml(index);
							}, _time);
						}

						this.arrowDisable(index);

						if (!direction) {
							if (index < _prevIndex) {
								direction = 'prev';
							} else if (index > _prevIndex) {
								direction = 'next';
							}
						}

						if (!fromTouch) {
							// remove all transitions
							_this.$outer.addClass('lg-no-trans');

							this.$slide.removeClass('lg-prev-slide lg-next-slide');

							if (direction === 'prev') {
								//prevslide
								this.$slide.eq(index).addClass('lg-prev-slide');
								this.$slide.eq(_prevIndex).addClass('lg-next-slide');
							} else {
								// next slide
								this.$slide.eq(index).addClass('lg-next-slide');
								this.$slide.eq(_prevIndex).addClass('lg-prev-slide');
							} // give 50 ms for browser to add/remove class


							setTimeout(function () {
								_this.$slide.removeClass('lg-current'); //_this.$slide.eq(_prevIndex).removeClass('lg-current');


								_this.$slide.eq(index).addClass('lg-current'); // reset all transitions


								_this.$outer.removeClass('lg-no-trans');
							}, 50);
						} else {
							this.$slide.removeClass('lg-prev-slide lg-current lg-next-slide');
							var touchPrev;
							var touchNext;

							if (_length > 2) {
								touchPrev = index - 1;
								touchNext = index + 1;

								if (index === 0 && _prevIndex === _length - 1) {
									// next slide
									touchNext = 0;
									touchPrev = _length - 1;
								} else if (index === _length - 1 && _prevIndex === 0) {
									// prev slide
									touchNext = 0;
									touchPrev = _length - 1;
								}
							} else {
								touchPrev = 0;
								touchNext = 1;
							}

							if (direction === 'prev') {
								_this.$slide.eq(touchNext).addClass('lg-next-slide');
							} else {
								_this.$slide.eq(touchPrev).addClass('lg-prev-slide');
							}

							_this.$slide.eq(index).addClass('lg-current');
						}

						if (_this.lGalleryOn) {
							setTimeout(function () {
								_this.loadContent(index, true, 0);
							}, this.s.speed + 50);
							setTimeout(function () {
								_this.lgBusy = false;

								_this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);
							}, this.s.speed);
						} else {
							_this.loadContent(index, true, _this.s.backdropDuration);

							_this.lgBusy = false;

							_this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);
						}

						_this.lGalleryOn = true;

						if (this.s.counter) {
							$('#lg-counter-current').text(index + 1);
						}
					}

					_this.index = index;
				};
				/**
				 *  @desc Go to next slide
				 *  @param {Boolean} fromTouch - true if slide function called via touch event
				 */


				Plugin.prototype.goToNextSlide = function (fromTouch) {
					var _this = this;

					var _loop = _this.s.loop;

					if (fromTouch && _this.$slide.length < 3) {
						_loop = false;
					}

					if (!_this.lgBusy) {
						if (_this.index + 1 < _this.$slide.length) {
							_this.index++;

							_this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);

							_this.slide(_this.index, fromTouch, false, 'next');
						} else {
							if (_loop) {
								_this.index = 0;

								_this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);

								_this.slide(_this.index, fromTouch, false, 'next');
							} else if (_this.s.slideEndAnimatoin && !fromTouch) {
								_this.$outer.addClass('lg-right-end');

								setTimeout(function () {
									_this.$outer.removeClass('lg-right-end');
								}, 400);
							}
						}
					}
				};
				/**
				 *  @desc Go to previous slide
				 *  @param {Boolean} fromTouch - true if slide function called via touch event
				 */


				Plugin.prototype.goToPrevSlide = function (fromTouch) {
					var _this = this;

					var _loop = _this.s.loop;

					if (fromTouch && _this.$slide.length < 3) {
						_loop = false;
					}

					if (!_this.lgBusy) {
						if (_this.index > 0) {
							_this.index--;

							_this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);

							_this.slide(_this.index, fromTouch, false, 'prev');
						} else {
							if (_loop) {
								_this.index = _this.$items.length - 1;

								_this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);

								_this.slide(_this.index, fromTouch, false, 'prev');
							} else if (_this.s.slideEndAnimatoin && !fromTouch) {
								_this.$outer.addClass('lg-left-end');

								setTimeout(function () {
									_this.$outer.removeClass('lg-left-end');
								}, 400);
							}
						}
					}
				};

				Plugin.prototype.keyPress = function () {
					var _this = this;

					if (this.$items.length > 1) {
						$(window).on('keyup.lg', function (e) {
							if (_this.$items.length > 1) {
								if (e.keyCode === 37) {
									e.preventDefault();

									_this.goToPrevSlide();
								}

								if (e.keyCode === 39) {
									e.preventDefault();

									_this.goToNextSlide();
								}
							}
						});
					}

					$(window).on('keydown.lg', function (e) {
						if (_this.s.escKey === true && e.keyCode === 27) {
							e.preventDefault();

							if (!_this.$outer.hasClass('lg-thumb-open')) {
								_this.destroy();
							} else {
								_this.$outer.removeClass('lg-thumb-open');
							}
						}
					});
				};

				Plugin.prototype.arrow = function () {
					var _this = this;

					this.$outer.find('.lg-prev').on('click.lg', function () {
						_this.goToPrevSlide();
					});
					this.$outer.find('.lg-next').on('click.lg', function () {
						_this.goToNextSlide();
					});
				};

				Plugin.prototype.arrowDisable = function (index) {
					// Disable arrows if s.hideControlOnEnd is true
					if (!this.s.loop && this.s.hideControlOnEnd) {
						if (index + 1 < this.$slide.length) {
							this.$outer.find('.lg-next').removeAttr('disabled').removeClass('disabled');
						} else {
							this.$outer.find('.lg-next').attr('disabled', 'disabled').addClass('disabled');
						}

						if (index > 0) {
							this.$outer.find('.lg-prev').removeAttr('disabled').removeClass('disabled');
						} else {
							this.$outer.find('.lg-prev').attr('disabled', 'disabled').addClass('disabled');
						}
					}
				};

				Plugin.prototype.setTranslate = function ($el, xValue, yValue) {
					// jQuery supports Automatic CSS prefixing since jQuery 1.8.0
					if (this.s.useLeft) {
						$el.css('left', xValue);
					} else {
						$el.css({
							transform: 'translate3d(' + xValue + 'px, ' + yValue + 'px, 0px)'
						});
					}
				};

				Plugin.prototype.touchMove = function (startCoords, endCoords) {
					var distance = endCoords - startCoords;

					if (Math.abs(distance) > 15) {
						// reset opacity and transition duration
						this.$outer.addClass('lg-dragging'); // move current slide

						this.setTranslate(this.$slide.eq(this.index), distance, 0); // move next and prev slide with current slide

						this.setTranslate($('.lg-prev-slide'), -this.$slide.eq(this.index).width() + distance, 0);
						this.setTranslate($('.lg-next-slide'), this.$slide.eq(this.index).width() + distance, 0);
					}
				};

				Plugin.prototype.touchEnd = function (distance) {
					var _this = this; // keep slide animation for any mode while dragg/swipe


					if (_this.s.mode !== 'lg-slide') {
						_this.$outer.addClass('lg-slide');
					}

					this.$slide.not('.lg-current, .lg-prev-slide, .lg-next-slide').css('opacity', '0'); // set transition duration

					setTimeout(function () {
						_this.$outer.removeClass('lg-dragging');

						if (distance < 0 && Math.abs(distance) > _this.s.swipeThreshold) {
							_this.goToNextSlide(true);
						} else if (distance > 0 && Math.abs(distance) > _this.s.swipeThreshold) {
							_this.goToPrevSlide(true);
						} else if (Math.abs(distance) < 5) {
							// Trigger click if distance is less than 5 pix
							_this.$el.trigger('onSlideClick.lg');
						}

						_this.$slide.removeAttr('style');
					}); // remove slide class once drag/swipe is completed if mode is not slide

					setTimeout(function () {
						if (!_this.$outer.hasClass('lg-dragging') && _this.s.mode !== 'lg-slide') {
							_this.$outer.removeClass('lg-slide');
						}
					}, _this.s.speed + 100);
				};

				Plugin.prototype.enableSwipe = function () {
					var _this = this;

					var startCoords = 0;
					var endCoords = 0;
					var isMoved = false;

					if (_this.s.enableSwipe && _this.doCss()) {
						_this.$slide.on('touchstart.lg', function (e) {
							if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy) {
								e.preventDefault();

								_this.manageSwipeClass();

								startCoords = e.originalEvent.targetTouches[0].pageX;
							}
						});

						_this.$slide.on('touchmove.lg', function (e) {
							if (!_this.$outer.hasClass('lg-zoomed')) {
								e.preventDefault();
								endCoords = e.originalEvent.targetTouches[0].pageX;

								_this.touchMove(startCoords, endCoords);

								isMoved = true;
							}
						});

						_this.$slide.on('touchend.lg', function () {
							if (!_this.$outer.hasClass('lg-zoomed')) {
								if (isMoved) {
									isMoved = false;

									_this.touchEnd(endCoords - startCoords);
								} else {
									_this.$el.trigger('onSlideClick.lg');
								}
							}
						});
					}
				};

				Plugin.prototype.enableDrag = function () {
					var _this = this;

					var startCoords = 0;
					var endCoords = 0;
					var isDraging = false;
					var isMoved = false;

					if (_this.s.enableDrag && _this.doCss()) {
						_this.$slide.on('mousedown.lg', function (e) {
							if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy && !$(e.target).text().trim()) {
								e.preventDefault();

								_this.manageSwipeClass();

								startCoords = e.pageX;
								isDraging = true; // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723

								_this.$outer.scrollLeft += 1;
								_this.$outer.scrollLeft -= 1; // *

								_this.$outer.removeClass('lg-grab').addClass('lg-grabbing');

								_this.$el.trigger('onDragstart.lg');
							}
						});

						$(window).on('mousemove.lg', function (e) {
							if (isDraging) {
								isMoved = true;
								endCoords = e.pageX;

								_this.touchMove(startCoords, endCoords);

								_this.$el.trigger('onDragmove.lg');
							}
						});
						$(window).on('mouseup.lg', function (e) {
							if (isMoved) {
								isMoved = false;

								_this.touchEnd(endCoords - startCoords);

								_this.$el.trigger('onDragend.lg');
							} else if ($(e.target).hasClass('lg-object') || $(e.target).hasClass('lg-video-play')) {
								_this.$el.trigger('onSlideClick.lg');
							} // Prevent execution on click


							if (isDraging) {
								isDraging = false;

								_this.$outer.removeClass('lg-grabbing').addClass('lg-grab');
							}
						});
					}
				};

				Plugin.prototype.manageSwipeClass = function () {
					var _touchNext = this.index + 1;

					var _touchPrev = this.index - 1;

					if (this.s.loop && this.$slide.length > 2) {
						if (this.index === 0) {
							_touchPrev = this.$slide.length - 1;
						} else if (this.index === this.$slide.length - 1) {
							_touchNext = 0;
						}
					}

					this.$slide.removeClass('lg-next-slide lg-prev-slide');

					if (_touchPrev > -1) {
						this.$slide.eq(_touchPrev).addClass('lg-prev-slide');
					}

					this.$slide.eq(_touchNext).addClass('lg-next-slide');
				};

				Plugin.prototype.mousewheel = function () {
					var _this = this;

					_this.$outer.on('mousewheel.lg', function (e) {
						if (!e.deltaY) {
							return;
						}

						if (e.deltaY > 0) {
							_this.goToPrevSlide();
						} else {
							_this.goToNextSlide();
						}

						e.preventDefault();
					});
				};

				Plugin.prototype.closeGallery = function () {
					var _this = this;

					var mousedown = false;
					this.$outer.find('.lg-close').on('click.lg', function () {
						_this.destroy();
					});

					if (_this.s.closable) {
						// If you drag the slide and release outside gallery gets close on chrome
						// for preventing this check mousedown and mouseup happened on .lg-item or lg-outer
						_this.$outer.on('mousedown.lg', function (e) {
							if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap')) {
								mousedown = true;
							} else {
								mousedown = false;
							}
						});

						_this.$outer.on('mousemove.lg', function () {
							mousedown = false;
						});

						_this.$outer.on('mouseup.lg', function (e) {
							if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap') && mousedown) {
								if (!_this.$outer.hasClass('lg-dragging')) {
									_this.destroy();
								}
							}
						});
					}
				};

				Plugin.prototype.destroy = function (d) {
					var _this = this;

					if (!d) {
						_this.$el.trigger('onBeforeClose.lg');

						$(window).scrollTop(_this.prevScrollTop);
					}
					/**
					 * if d is false or undefined destroy will only close the gallery
					 * plugins instance remains with the element
					 *
					 * if d is true destroy will completely remove the plugin
					 */


					if (d) {
						if (!_this.s.dynamic) {
							// only when not using dynamic mode is $items a jquery collection
							this.$items.off('click.lg click.lgcustom');
						}

						$.removeData(_this.el, 'lightGallery');
					} // Unbind all events added by lightGallery


					this.$el.off('.lg.tm'); // destroy all lightGallery modules

					$.each($.fn.lightGallery.modules, function (key) {
						if (_this.modules[key]) {
							_this.modules[key].destroy();
						}
					});
					this.lGalleryOn = false;
					clearTimeout(_this.hideBarTimeout);
					this.hideBarTimeout = false;
					$(window).off('.lg');
					$('body').removeClass('lg-on lg-from-hash');

					if (_this.$outer) {
						_this.$outer.removeClass('lg-visible');
					}

					$('.lg-backdrop').removeClass('in');
					setTimeout(function () {
						if (_this.$outer) {
							_this.$outer.remove();
						}

						$('.lg-backdrop').remove();

						if (!d) {
							_this.$el.trigger('onCloseAfter.lg');
						}

						_this.$el.focus();
					}, _this.s.backdropDuration + 50);
				};

				$.fn.lightGallery = function (options) {
					return this.each(function () {
						if (!$.data(this, 'lightGallery')) {
							$.data(this, 'lightGallery', new Plugin(this, options));
						} else {
							try {
								$(this).data('lightGallery').init();
							} catch (err) {
								console.error('lightGallery has not initiated properly', err);
							}
						}
					});
				};

				$.fn.lightGallery.modules = {};
			})();
		});

		/***/
	}),
	/* 14 */
	/***/ (function (module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

		function _typeof(obj) {
			"@babel/helpers - typeof";
			if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
				_typeof = function _typeof(obj) {
					return typeof obj;
				};
			} else {
				_typeof = function _typeof(obj) {
					return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
				};
			}
			return _typeof(obj);
		}

		/*! lg-video - v1.4.0 - November-07-2020
* http://sachinchoolur.github.io/lightGallery
* Copyright (c) 2020 Sachin N; Licensed GPLv3 */
		(function (root, factory) {
			if (true) {
				// AMD. Register as an anonymous module unless amdModuleId is set
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (a0) {
					return factory(a0);
				}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
			}
		})(this, function ($) {
			(function () {
				'use strict';

				var defaults = {
					videoMaxWidth: '855px',
					autoplayFirstVideo: true,
					youtubePlayerParams: false,
					vimeoPlayerParams: false,
					dailymotionPlayerParams: false,
					vkPlayerParams: false,
					videojs: false,
					videojsOptions: {}
				};

				var Video = function Video(element) {
					this.core = $(element).data('lightGallery');
					this.$el = $(element);
					this.core.s = $.extend({}, defaults, this.core.s);
					this.videoLoaded = false;
					this.init();
					return this;
				};

				Video.prototype.init = function () {
					var _this = this; // Event triggered when video url found without poster


					_this.core.$el.on('hasVideo.lg.tm', onHasVideo.bind(this)); // Set max width for video


					_this.core.$el.on('onAferAppendSlide.lg.tm', onAferAppendSlide.bind(this));

					if (_this.core.doCss() && _this.core.$items.length > 1 && (_this.core.s.enableSwipe || _this.core.s.enableDrag)) {
						_this.core.$el.on('onSlideClick.lg.tm', function () {
							var $el = _this.core.$slide.eq(_this.core.index);

							_this.loadVideoOnclick($el);
						});
					} else {
						// For IE 9 and bellow
						_this.core.$slide.on('click.lg', function () {
							_this.loadVideoOnclick($(this));
						});
					}

					_this.core.$el.on('onBeforeSlide.lg.tm', onBeforeSlide.bind(this));

					_this.core.$el.on('onAfterSlide.lg.tm', function (event, prevIndex) {
						_this.core.$slide.eq(prevIndex).removeClass('lg-video-playing');
					});

					if (_this.core.s.autoplayFirstVideo) {
						_this.core.$el.on('onAferAppendSlide.lg.tm', function (e, index) {
							if (!_this.core.lGalleryOn) {
								var $el = _this.core.$slide.eq(index);

								setTimeout(function () {
									_this.loadVideoOnclick($el);
								}, 100);
							}
						});
					}
				};

				Video.prototype.loadVideo = function (src, addClass, noPoster, index, html) {
					var _this = this;

					var video = '';
					var autoplay = 1;
					var a = '';
					var isVideo = this.core.isVideo(src, index) || {};
					var videoTitle;

					if (_this.core.s.dynamic) {
						videoTitle = _this.core.s.dynamicEl[_this.core.index].title;
					} else {
						videoTitle = _this.core.$items.eq(_this.core.index).attr('title') || _this.core.$items.eq(_this.core.index).find('img').first().attr('alt');
					}

					videoTitle = videoTitle ? 'title="' + videoTitle + '"' : ''; // Enable autoplay based on setting for first video if poster doesn't exist

					if (noPoster) {
						if (this.videoLoaded) {
							autoplay = 0;
						} else {
							autoplay = this.core.s.autoplayFirstVideo ? 1 : 0;
						}
					}

					if (isVideo.youtube) {
						a = '?wmode=opaque&autoplay=' + autoplay + '&enablejsapi=1';

						if (this.core.s.youtubePlayerParams) {
							a = a + '&' + $.param(this.core.s.youtubePlayerParams);
						}

						video = '<iframe allow="autoplay" class="lg-video-object lg-youtube ' + addClass + '" ' + videoTitle + ' width="560" height="315" src="//www.youtube.com/embed/' + isVideo.youtube[1] + a + '" frameborder="0" allowfullscreen></iframe>';
					} else if (isVideo.vimeo) {
						a = '?autoplay=' + autoplay;

						if (this.core.s.vimeoPlayerParams) {
							a = a + '&' + $.param(this.core.s.vimeoPlayerParams);
						}

						video = '<iframe allow="autoplay" class="lg-video-object lg-vimeo ' + addClass + '" ' + videoTitle + ' width="560" height="315"  src="//player.vimeo.com/video/' + isVideo.vimeo[1] + a + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';
					} else if (isVideo.dailymotion) {
						a = '?wmode=opaque&autoplay=' + autoplay + '&api=postMessage';

						if (this.core.s.dailymotionPlayerParams) {
							a = a + '&' + $.param(this.core.s.dailymotionPlayerParams);
						}

						video = '<iframe allow="autoplay" class="lg-video-object lg-dailymotion ' + addClass + '" ' + videoTitle + ' width="560" height="315" src="//www.dailymotion.com/embed/video/' + isVideo.dailymotion[1] + a + '" frameborder="0" allowfullscreen></iframe>';
					} else if (isVideo.html5) {
						var fL = html.substring(0, 1);

						if (fL === '.' || fL === '#') {
							html = $(html).html();
						}

						video = html;
					} else if (isVideo.vk) {
						a = '&autoplay=' + autoplay;

						if (this.core.s.vkPlayerParams) {
							a = a + '&' + $.param(this.core.s.vkPlayerParams);
						}

						video = '<iframe allow="autoplay" class="lg-video-object lg-vk ' + addClass + '" ' + videoTitle + ' width="560" height="315" src="//vk.com/video_ext.php?' + isVideo.vk[1] + a + '" frameborder="0" allowfullscreen></iframe>';
					}

					return video;
				};

				Video.prototype.loadVideoOnclick = function ($el) {
					var _this = this; // check slide has poster


					if ($el.find('.lg-object').hasClass('lg-has-poster') && $el.find('.lg-object').is(':visible')) {
						// check already video element present
						if (!$el.hasClass('lg-has-video')) {
							$el.addClass('lg-video-playing lg-has-video');

							var _src;

							var _html;

							var _loadVideo = function _loadVideo(_src, _html) {
								$el.find('.lg-video').append(_this.loadVideo(_src, '', false, _this.core.index, _html));

								if (_html) {
									if (_this.core.s.videojs) {
										try {
											videojs(_this.core.$slide.eq(_this.core.index).find('.lg-html5').get(0), _this.core.s.videojsOptions, function () {
												this.play();
											});
										} catch (e) {
											console.error('lightGallery:- Make sure you have included videojs');
										}
									} else {
										_this.core.$slide.eq(_this.core.index).find('.lg-html5').get(0).play();
									}
								}
							};

							if (_this.core.s.dynamic) {
								_src = _this.core.s.dynamicEl[_this.core.index].src;
								_html = _this.core.s.dynamicEl[_this.core.index].html;

								_loadVideo(_src, _html);
							} else {
								_src = _this.core.$items.eq(_this.core.index).attr('href') || _this.core.$items.eq(_this.core.index).attr('data-src');
								_html = _this.core.$items.eq(_this.core.index).attr('data-html');

								_loadVideo(_src, _html);
							}

							var $tempImg = $el.find('.lg-object');
							$el.find('.lg-video').append($tempImg); // @todo loading icon for html5 videos also
							// for showing the loading indicator while loading video

							if (!$el.find('.lg-video-object').hasClass('lg-html5')) {
								$el.removeClass('lg-complete');
								$el.find('.lg-video-object').on('load.lg error.lg', function () {
									$el.addClass('lg-complete');
								});
							}
						} else {
							var youtubePlayer = $el.find('.lg-youtube').get(0);
							var vimeoPlayer = $el.find('.lg-vimeo').get(0);
							var dailymotionPlayer = $el.find('.lg-dailymotion').get(0);
							var html5Player = $el.find('.lg-html5').get(0);

							if (youtubePlayer) {
								youtubePlayer.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');
							} else if (vimeoPlayer) {
								try {
									new Vimeo.Player(vimeoPlayer).play()["catch"](function (error) {
										console.error('error playing the video:', error.name);
									});
								} catch (e) {
									console.warn('lightGallery:- Make sure you have included https://github.com/vimeo/player.js');
								}
							} else if (dailymotionPlayer) {
								dailymotionPlayer.contentWindow.postMessage('play', '*');
							} else if (html5Player) {
								if (_this.core.s.videojs) {
									try {
										videojs(html5Player).play();
									} catch (e) {
										console.error('lightGallery:- Make sure you have included videojs');
									}
								} else {
									html5Player.play();
								}
							}

							$el.addClass('lg-video-playing');
						}
					}
				};

				Video.prototype.destroy = function () {
					this.videoLoaded = false;
				};

				function onHasVideo(event, index, src, html) {
					/*jshint validthis:true */
					var _this = this;

					_this.core.$slide.eq(index).find('.lg-video').append(_this.loadVideo(src, 'lg-object', true, index, html));

					if (html) {
						if (_this.core.s.videojs) {
							try {
								videojs(_this.core.$slide.eq(index).find('.lg-html5').get(0), _this.core.s.videojsOptions, function () {
									if (!_this.videoLoaded && _this.core.s.autoplayFirstVideo) {
										this.play();
									}
								});
							} catch (e) {
								console.error('lightGallery:- Make sure you have included videojs');
							}
						} else {
							if (!_this.videoLoaded && _this.core.s.autoplayFirstVideo) {
								_this.core.$slide.eq(index).find('.lg-html5').get(0).play();
							}
						}
					}
				}

				function onAferAppendSlide(event, index) {
					/*jshint validthis:true */
					var $videoCont = this.core.$slide.eq(index).find('.lg-video-cont');

					if (!$videoCont.hasClass('lg-has-iframe')) {
						$videoCont.css('max-width', this.core.s.videoMaxWidth);
						this.videoLoaded = true;
					}
				}

				function onBeforeSlide(event, prevIndex, index) {
					/*jshint validthis:true */
					var _this = this;

					var $videoSlide = _this.core.$slide.eq(prevIndex);

					var youtubePlayer = $videoSlide.find('.lg-youtube').get(0);
					var vimeoPlayer = $videoSlide.find('.lg-vimeo').get(0);
					var dailymotionPlayer = $videoSlide.find('.lg-dailymotion').get(0);
					var vkPlayer = $videoSlide.find('.lg-vk').get(0);
					var html5Player = $videoSlide.find('.lg-html5').get(0);

					if (youtubePlayer) {
						youtubePlayer.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');
					} else if (vimeoPlayer) {
						try {
							new Vimeo.Player(vimeoPlayer).pause()["catch"](function (error) {
								console.error('Unable to pause the video:', error.name);
							});
						} catch (e) {
							console.warn('lightGallery:- Make sure you have included https://github.com/vimeo/player.js');
						}
					} else if (dailymotionPlayer) {
						dailymotionPlayer.contentWindow.postMessage('pause', '*');
					} else if (html5Player) {
						if (_this.core.s.videojs) {
							try {
								videojs(html5Player).pause();
							} catch (e) {
								console.error('lightGallery:- Make sure you have included videojs');
							}
						} else {
							html5Player.pause();
						}
					}

					if (vkPlayer) {
						$(vkPlayer).attr('src', $(vkPlayer).attr('src').replace('&autoplay', '&noplay'));
					}

					var _src;

					if (_this.core.s.dynamic) {
						_src = _this.core.s.dynamicEl[index].src;
					} else {
						_src = _this.core.$items.eq(index).attr('href') || _this.core.$items.eq(index).attr('data-src');
					}

					var _isVideo = _this.core.isVideo(_src, index) || {};

					if (_isVideo.youtube || _isVideo.vimeo || _isVideo.dailymotion || _isVideo.vk) {
						_this.core.$outer.addClass('lg-hide-download');
					}
				}

				$.fn.lightGallery.modules.video = Video;
			})();
		});

		/***/
	}),
	/* 15 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

			jQuery(document).ready(function ($) {
				$(".video-gallery").lightGallery({
					loadYoutubeThumbnail: true,
					youtubeThumbSize: 'default'
				});
				$(".image-gallery").lightGallery({
					mode: 'lg-slide'
				});
				$('.idea-folder-gallery').lightGallery({
					mode: 'lg-slide',
					counter: false
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 16 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var _functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);

			function _defineProperty(obj, key, value) {
				if (key in obj) {
					Object.defineProperty(obj, key, {
						value: value,
						enumerable: true,
						configurable: true,
						writable: true
					});
				} else {
					obj[key] = value;
				}
				return obj;
			}


			jQuery(document).ready(function ($) {
				// function to hide search wrapper and overlay
				function hideSeaechWrapper(e) {
					var el = e.target.closest('#search-form-wrapper');

					if (!el) {
						$('#overlay-search').removeClass('open');
						$('#search-form-wrapper').removeClass('open');
						document.removeEventListener('click', hideSeaechWrapper);
					}
				} //show header search form


				$('#show-search-form').on('click', function () {
					$('#overlay-search').addClass('open');
					$('#search-form-wrapper').addClass('open');
					setTimeout(function () {
						document.addEventListener('click', hideSeaechWrapper);
					});
				}); //after desctop login

				$('.js-account-login').on('click', function () {
					$(this).css('display', 'none');
					$(this).siblings('.account-menu-visible').css('display', 'none');
					$(this).siblings('.account-menu-hidden').css('display', 'block');
					$(this).parents('.js-account-wrap').find('.dropdown-toggle.account').addClass('login');
					$(this).parents('.js-account-wrap').find('.account-name').css('display', 'inline-block');
				}); //after desctop log out

				$('.js-account-logout').on('click', function () {
					$(this).css('display', 'none');
					$(this).siblings('.account-menu-visible').css('display', 'block');
					$(this).siblings('.account-menu-hidden').css('display', 'none');
					$(this).parents('.js-account-wrap').find('.dropdown-toggle.account').removeClass('login');
					$(this).parents('.js-account-wrap').find('.account-name').css('display', 'none');
				}); //hide covid section

				$('.js-hide-covit').on('click', function () {
					$(this).parents('.covid-header').remove();
					$('.header-covid').removeClass('header-covid');
					$('.covid-block').removeClass('covid-block');
				});
				var navDropDown = $('.second-header__logo-nav--grop-down');

				if ($(navDropDown).length) {
					if ($(window).width() > 992) {
						$(navDropDown).hover(function () {
							$(this).find('.dropdown-wrap').addClass('active');
						}, function () {
							$(this).find('.dropdown-wrap').removeClass('active');
						});
					} else {
						var clickSpan = $(navDropDown).find('span');
						$(clickSpan).on('click', function () {
							if ($(this).hasClass('clickSpan')) {
								$(this).removeClass('clickSpan');
								$(this).find('.icon__minus').hide();
								$(this).find('.icon__plus').show();
								$(this).siblings('.dropdown-wrap').removeClass('active');
							} else {
								$(this).addClass('clickSpan');
								$(this).find('.icon__minus').show();
								$(this).find('.icon__plus').hide();
								$(this).siblings('.dropdown-wrap').addClass('active');
							}
						});
					}
				}

				function slickInit() {
					$('.carousel-har').not('.slick-initialized').slick({
						dots: true,
						infinite: false,
						arrows: true,
						slidesToShow: 1,
						slidesToScroll: 1,
						rows: 1,
						mobileFirst: true,
						responsive: [{
							breakpoint: 992,
							settings: 'unslick'
						}]
					}).on('afterChange', function () {
						$('.yvideo').each(function () {
							$(this)[0].contentWindow.postMessage('{"event":"command","func":"' + 'stopVideo' + '","args":""}', '*');
						});
					});
				} //


				function slickInitOrganizer() {
					$('.organizer-caro').not('.slick-initialized').slick({
						dots: false,
						arrows: false,
						infinite: true,
						slidesToShow: 1,
						slidesToScroll: 1,
						mobileFirst: true,
						responsive: [{
							breakpoint: 992,
							settings: 'unslick'
						}]
					}).on('afterChange', function () {
						$('.yvideo').each(function () {
							$(this)[0].contentWindow.postMessage('{"event":"command","func":"' + 'stopVideo' + '","args":""}', '*');
						});
					});
				}

				function slickInitVideo() {
					$('.video-caro').not('.slick-initialized').slick({
						dots: false,
						arrows: true,
						infinite: true,
						slidesToShow: 1,
						slidesToScroll: 1,
						mobileFirst: true,
						responsive: [{
							breakpoint: 992,
							settings: 'unslick'
						}]
					}).on('afterChange', function () {
						$('.yvideo').each(function () {
							$(this)[0].contentWindow.postMessage('{"event":"command","func":"' + 'stopVideo' + '","args":""}', '*');
						});
					});
					$('.video-second-caro').not('.slick-initialized').slick({
						dots: false,
						arrows: true,
						infinite: true,
						slidesToShow: 1,
						slidesToScroll: 1,
						mobileFirst: true,
						responsive: [{
							breakpoint: 992,
							settings: 'unslick'
						}]
					}).on('afterChange', function () {
						$('.yvideo').each(function () {
							$(this)[0].contentWindow.postMessage('{"event":"command","func":"' + 'stopVideo' + '","args":""}', '*');
						});
					});
				}

				function slickInitServises() {
					var _$$not$slick;

					$('.services-caro').not('.slick-initialized').slick((_$$not$slick = {
						dots: false,
						arrows: true,
						infinite: true,
						slidesToShow: 1,
						slidesToScroll: 1,
						mobileFirst: true
					}, _defineProperty(_$$not$slick, "infinite", false), _defineProperty(_$$not$slick, "responsive", [{
						breakpoint: 992,
						settings: 'unslick'
					}]), _$$not$slick)).on('afterChange', function () {
						$('.yvideo').each(function () {
							$(this)[0].contentWindow.postMessage('{"event":"command","func":"' + 'stopVideo' + '","args":""}', '*');
						});
					});
				}

				setTimeout(function () {
					slickInit();
					slickInitOrganizer();
					slickInitVideo();
					slickInitServises();
				}, 100);
				var productDetail = $('.product-detail .caro-wrap');

				if (productDetail.length >= 1) {
					Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.product-detail__carousel', '.product-detail__carousel-nav', false);
				}

				var specificationLoad = $('#tab-content-1');

				if (specificationLoad.length >= 1) {
					Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])("#js-carousel-1", "#js-carousel-nav-1", false);
				}

				var showroomDetailView = $('.showroom-detail-view-carousel');

				if (showroomDetailView.length >= 1) {
					Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.showroom-detail-view-carousel', '.showroom-detail-view-carousel-nav', true);
				}

				if ($('.video-block__videos').length >= 1) {
					if ($(window).width() > 992) {
						if ($('.video-block__videos').find('.embed-responsive').hasClass('embed-responsive-4by3')) {
							$('.embed-responsive').removeClass('embed-responsive-4by3').addClass('embed-responsive-16by9');
						}
					} else {
						if ($('.video-block__videos').find('.embed-responsive').hasClass('embed-responsive-16by9')) {
							$('.embed-responsive').removeClass('embed-responsive-16by9').addClass('embed-responsive-4by3');
						}
					}
				} // document load set padding on main tag by height on image


				$(window).on({
					resize: function resize() {
						setTimeout(function () {
							//add functions here to fire on resize
							slickInit();
							slickInitOrganizer();
							slickInitVideo();
							slickInitServises();
						}, 100);

						if ($('.video-block__videos').length >= 1) {
							if ($(window).width() > 992) {
								if ($('.video-block__videos').find('.embed-responsive').hasClass('embed-responsive-4by3')) {
									$('.embed-responsive').removeClass('embed-responsive-4by3').addClass('embed-responsive-16by9');
								}
							} else {
								if ($('.video-block__videos').find('.embed-responsive').hasClass('embed-responsive-16by9')) {
									$('.embed-responsive').removeClass('embed-responsive-16by9').addClass('embed-responsive-4by3');
								}
							}
						}

						var productDetail = $('.product-detail .caro-wrap');

						if (productDetail.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.product-detail__carousel', '.product-detail__carousel-nav', false);
						}

						var specificationLoad = $('#tab-content-1');

						if (specificationLoad.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])("#js-carousel-1", "#js-carousel-nav-1", false);
						}

						var showroomDetailView = $('.showroom-detail-view-carousel');

						if (showroomDetailView.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.showroom-detail-view-carousel', '.showroom-detail-view-carousel-nav', true);
						}

						if ($(window).width() > 992) {
							// remove sticky class nav up
							var navUp = $('header');

							if ($(navUp).hasClass('nav-up')) {
								$(navUp).removeClass('nav-up');
							}

							if ($(navUp).hasClass('small-header')) {
								$(navUp).removeClass('small-header');
							}

							if ($(navUp).find('.hide-element').length >= 1) {
								$(navUp).find('.hide-element').removeClass('hide-element');
							}

							if ($('.home-active-fixed').length >= 1) {
								$('.home-active-fixed').removeClass('home-active-fixed');
							}

							if ($('body').hasClass('position-fixed')) {
								$('body').removeClass('position-fixed');
							}
						} else {
							if ($('.scrollToTopBlock').length >= 1) {
								$('.scrollToTopBlock').fadeOut();
							}
						}
					},
					scroll: function scroll() {
						var scroll = $(window).scrollTop();

						if ($(window).width() > 992) {
							if (scroll > 300) {
								$('.scrollToTopBlock').fadeIn();
							} else {
								$('.scrollToTopBlock').fadeOut();
							}
						}
					},
					orientationchange: function orientationchange(event) {
						setTimeout(function () {
							//add functions here to fire on resize
							slickInit();
							slickInitOrganizer();
							slickInitVideo();
							slickInitServises();
						}, 100);
						var productDetail = $('.product-detail .caro-wrap');

						if (productDetail.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.product-detail__carousel', '.product-detail__carousel-nav', false);
						}

						var specificationLoad = $('#tab-content-1');

						if (specificationLoad.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])("#js-carousel-1", "#js-carousel-nav-1", false);
						}

						var showroomDetailView = $('.showroom-detail-view-carousel');

						if (showroomDetailView.length >= 1) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_0__[/* carouselById */ "a"])('.showroom-detail-view-carousel', '.showroom-detail-view-carousel-nav', true);
						}
					}
				}); //Click footer to top button

				$('.js-to-top').on('click', function () {
					$('html, body').animate({
						scrollTop: 0
					}, 800);
					return false;
				}); // Category switch between list view and thumb view

				$('.js-switch-list-view').on('click', function () {
					$(this).addClass('active');
					$(this).siblings('button').removeClass('active');

					if ($(this).attr('data-type') === 'js-thumb') {
						$('.js-list-category').addClass('category-block__thumb').find('.col-12').addClass('col-md-4');
					} else {
						$('.js-list-category').removeClass('category-block__thumb').find('.col-12').removeClass('col-md-4');
					}
				}); // Category switch between list view and thumb view

				$('.js-switch-list-view-sm').on('click', function () {
					$(this).addClass('active');
					$(this).siblings('button').removeClass('active');

					if ($(this).attr('data-type') === 'js-thumb') {
						$('.js-list-category').addClass('category-block__thumb').find('.col-12').addClass('col-sm-6 col-md-3 col-lg-2');
					} else {
						$('.js-list-category').removeClass('category-block__thumb').find('.col-12').removeClass('col-sm-6 col-md-3 col-lg-2');
					}
				}); //Expand more category by click on the 6 button

				$(".expand-button").click(function (e) {
					// click event for load more
					e.preventDefault();
					$(this).removeClass('expand-button').addClass('d-none').siblings('a.link-button').removeClass('d-none');
					$(".hidden-box:hidden").slice(0, 6).addClass('open');
				}); //hamburger mobile menu
				// function hideMobileMenu(e) {
				// 	var el = e.target.closest('.second-header__logo-nav--navigation');
				// 	if (!el) {
				// 		$('#overlay-mobile-nav').removeClass('open');
				// 		$('.second-header__logo-nav--navigation').removeClass('active');
				// 		$('body').css('overflow','auto');
				// 		document.removeEventListener('click', hideMobileMenu);
				// 	}
				// }

				$('.js-hamburger').on('click', function () {
					$('.second-header__logo-nav--navigation').addClass('active');
					$('#overlay-mobile-nav').addClass('open');
					$('body').css('overflow', 'hidden');

					if ($('header').hasClass('nav-up')) {
						$('header').removeClass('nav-up').addClass('nav-down');
					} // setTimeout(function() {
					// 	document.addEventListener('click', hideMobileMenu);
					// });

				});
				$('.js-hide-general-mobile-menu').on('click', function () {
					$('#overlay-mobile-nav').removeClass('open');
					$('.second-header__logo-nav--navigation').removeClass('active');
					$('body').css('overflow', 'auto'); // setTimeout(function() {
					// 	document.addEventListener('click', hideMobileMenu);
					// });
				}); //third header menu click

				$('.js-home-top-button').on('click', function () {
					$(this).siblings('button').each(function () {
						$(this).removeClass('active');
						$('#' + $(this).attr('data-value')).removeClass('home-active-fixed');
					});

					if ($(this).hasClass('active')) {
						$(this).removeClass('active');
						$('#' + $(this).attr('data-value')).removeClass('home-active-fixed');
						$('.first-header').removeClass('hide-element');
						$('.covid-header').removeClass('hide-element');
						$('header').removeClass('small-header');
						$('body').removeClass('position-fixed');
					} else {
						$(this).addClass('active');
						$('#' + $(this).attr('data-value')).addClass('home-active-fixed');
						$('.first-header').addClass('hide-element');
						$('.covid-header').addClass('hide-element');
						$('header').addClass('small-header');
						$('body').addClass('position-fixed');
					}
				}); //show text button

				$('.js-btn-view-all-text').on('click', function () {
					$(this).toggleClass('active');
					var scrollToEl = Math.round($(this).closest('div').siblings('.js-show-text').offset().top);

					if ($(this).hasClass('active')) {
						$(this).closest('div').siblings('.js-show-text').addClass('show-text');
						$(this).find('span').text($(this).attr('data-readLess'));
					} else {
						$(this).closest('div').siblings('.js-show-text').removeClass('show-text');
						$(this).find('span').text($(this).attr('data-readAll'));
						$('html, body').animate({
							scrollTop: scrollToEl - 130
						}, 800);
					}
				});

				function hideModal(e) {
					var el = e.target.closest('#js-mobile-show-modal');

					if (!el) {
						$('#js-mobile-show-modal').removeClass('active');
						document.removeEventListener('click', hideModal);
					}
				} //open modal for block with background


				$('#js-btn-mobile-show-modal').on('click', function () {
					$('#js-mobile-show-modal').addClass('active');
					setTimeout(function () {
						document.addEventListener('click', hideModal);
					});
				}); // open showroom detail view

				$('.js-showroom-detail-view-btn').on('click', function () {
					$(this).closest('figcaption.showroom-detail-block__images').siblings('div.showroom-detail-view-block').addClass('active');
					$('body').addClass('modal-open_custom');
				});
				$('.js-showroom-detail-view-btn-siblings').on('click', function () {
					$(this).siblings('div.showroom-detail-view-block').addClass('active');
					$('body').addClass('modal-open_custom');
				}); // hide showroom detail view

				$('.js-showroom-detail-close-btn').on('click', function () {
					$(this).parent('div.showroom-detail-view-block').removeClass('active');
					$('body').removeClass('modal-open_custom');
				}); // show mobile fax a desing plan modals

				$('.js-mobile-fax-design-content-btn').on('click', function () {
					var modalId = $(this).attr('data-target');
					$(modalId).find('.modal-title').empty().text($(this).text());
					$(modalId).find('.modal-body .row').empty().append($($(this).attr('date-content-class-open')).detach());

					if ($(this).attr('date-content-class-open') === '.js-sample-fax-form') {
						$(modalId).find('.modal-body .row').addClass('flex-column-reverse');
						$(modalId).find('.two-elements-block__wrapper--content').addClass('mt-0 mb-3');
					} else {
						$(modalId).find('.modal-body .row').removeClass('flex-column-reverse');
					}

					$(modalId).find('.modal-body h2').remove();
					$(modalId).find('.js-close-fax-design').attr('date-content-class-close', $(this).attr('date-content-class-open'));
					$(modalId).find('.two-elements-block__wrapper--link-block').addClass('flex-row');
					$(modalId).find('.js-btn-view-all-text').remove();
					$(modalId).find('.js-show-text').css('text-align', 'left').removeClass('small-text');
					$(modalId).find('.you-design').addClass('modal-fax-design-btn').siblings('.we-design').addClass('modal-fax-design-btn');
					$(modalId).find('.two-elements-block__wrapper--stars').addClass('mt-0');
				});
				$('.js-close-fax-design').on('click', function () {
					var modalBody = $(this).parents('.modal-header').siblings('.modal-body');

					if ($(this).attr('date-content-class-close') === '.js-sample-fax-form' || $(this).attr('date-content-class-close') === 'js-read-review') {
						$('.js-first-fax-design').find('.row').append($(modalBody).find($(this).attr('date-content-class-close')).detach());
					} else {
						$('.js-second-fax-design').find('.row').append($(modalBody).find($(this).attr('date-content-class-close')).detach());
					}
				});
				$('.js-only-close-fax-design').on('click', function () {
					$(this).parents('.modal-body').siblings('.modal-header').find('.js-close-fax-design').trigger('click');
				});
				document.body.addEventListener("click", function (event) {
					if ($(event.target).hasClass('js-delete-uploaded-img')) {
						var clickedBtn = $(event.target),
							modalId = clickedBtn.attr('data-target');
						$(modalId).find('.js-delete-uploaded-img-btn').attr({
							'data-image-name': '.' + clickedBtn.attr('data-image-name'),
							'data-target': '#mobile-fax-design'
						});
					}
				});
				$('.js-delete-uploaded-img-btn').on('click', function () {
					var deletedRow = $(this).attr('data-image-name'),
						modalId = $(this).attr('data-target');
					$(modalId).find(deletedRow).parents('tr').remove();
				}); //show all desktop footer menu

				$('.js-show-all-footer-menu-btn').on('click', function () {
					if ($(window).width() >= 992) {
						var $wrap = $(this).parents('.js-show-all-footer-menu');
						$(this).hide();
						$wrap.find('.first-footer__wrapper-button').css('display', 'none');
						$wrap.find('.first-footer__navivation').addClass('show-all-menu', 100, 'swing');
						$wrap.find('.hidden-footer-menu-item').show(100);
						$wrap.find('.js-hide-all-footer-menu-btn').addClass('show-btn', 100, 'swing');
					}
				}); //hide desktop footer menu

				$('.js-hide-all-footer-menu-btn').on('click', function () {
					if ($(window).width() >= 992) {
						var $wrap = $(this).parents('.js-show-all-footer-menu');
						$(this).removeClass('show-btn', 110, 'swing');
						$wrap.find('.first-footer__wrapper-button').css('display', 'flex');
						$wrap.find('.first-footer__navivation').removeClass('show-all-menu', 110, 'swing');
						$wrap.find('.hidden-footer-menu-item').hide();
						$wrap.find('.js-show-all-footer-menu-btn').show(100);
					}
				}); // show mobile footer nav

				$('.js-show-mobile-footer-menu-btn').on('click', function () {
					if ($(window).width() <= 992) {
						$(this).siblings('.first-footer__navivation').toggle(300);
						$(this).parents('.col-12.col-lg-6.col-xl-3').siblings('.col-12.col-lg-6.col-xl-3').find('.first-footer__navivation').hide(300);
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 17 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				$('.collapse').collapse(); //collapse on hover - the collapse needs to wait until other collapse ends
				// $(".card").hover(function () {
				//     $(this).closest('.card').find('.collapse').collapse('toggle');
				// })
				// $('.card .btn').mouseleave(function () {
				//     console.log('leave');
				//     $(this).closest('.card').find('.collapse').collapse('hide');
				// })
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 18 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				$('.solution-block-carousel__wrapper').slick({
					dots: true,
					infinite: true,
					centerMode: true,
					slidesToShow: 1,
					slidesToScroll: 1
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 19 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function ($) {
			var // where files are dropped + file selector is opened
				dropRegion = document.querySelector(".drop-region");

			if ($(dropRegion).length >= 1) {
				var preventDefault = function preventDefault(e) {
					e.preventDefault();
					e.stopPropagation();
				};

				var handleDrop = function handleDrop(e) {
					var dt = e.dataTransfer,
						files = dt.files;

					if (files.length) {
						handleFiles(files);
					} else {
						// check for img
						var html = dt.getData('text/html'),
							match = html && /\bsrc="?([^"\s]+)"?\s*/.exec(html),
							url = match && match[1];

						if (url) {
							uploadImageFromURL(url);
							return;
						}
					}

					function uploadImageFromURL(url) {
						var img = new Image();
						var c = document.createElement("canvas");
						var ctx = c.getContext("2d");

						img.onload = function () {
							c.width = this.naturalWidth; // update canvas size to match image

							c.height = this.naturalHeight;
							ctx.drawImage(this, 0, 0); // draw in image

							c.toBlob(function (blob) {
								// get content as PNG blob
								// call our main function
								handleFiles([blob]);
							}, "image/png");
						};

						img.onerror = function () {
							alert("Error in uploading");
						};

						img.crossOrigin = ""; // if from different origin

						img.src = url;
					}
				};

				var handleFiles = function handleFiles(files) {
					for (var i = 0, len = files.length; i < len; i++) {
						if (validateImage(files[i])) previewAnduploadImage(files[i]);
					}
				};

				var validateImage = function validateImage(image) {
					// check the type
					var validTypes = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif', 'image/bmp'];

					if (validTypes.indexOf(image.type) === -1) {
						alert("Invalid File Type");
						return false;
					} // check the size


					var maxSizeInBytes = 10e6; // 10MB

					if (image.size > maxSizeInBytes) {
						alert("File too large");
						return false;
					}

					return true;
				};

				var createInput = function createInput(inputName, inputVal) {
					var inputField = document.createElement("input");
					inputField.type = "text";
					inputField.className = "image-data";
					inputField.name = inputName;
					inputField.value = inputVal;
					return inputField;
				};

				var previewAnduploadImage = function previewAnduploadImage(image) {
					// container
					var imgView = document.createElement("tr");
					imgView.className = "image-view";
					imagePreviewRegion.appendChild(imgView);
					var buttonDeleteTd = document.createElement("td");
					buttonDeleteTd.className = "mobile-button-delete-wrap";
					var buttonDelete = document.createElement("button");
					buttonDelete.className = "mobile-button-delete js-delete-uploaded-img";
					buttonDelete.setAttribute('data-image-name', image.name);
					buttonDelete.setAttribute('data-toggle', 'modal');
					buttonDelete.setAttribute('data-target', '#deleteImgModal');
					buttonDeleteTd.appendChild(buttonDelete);
					imgView.appendChild(buttonDeleteTd);
					var imgIcon = document.createElement("td");
					imgIcon.className = "mobile-image-icon";
					var imgTypeSplit = image.type.split('/');
					var imgIconContainer = document.createElement("span");
					imgIconContainer.className = "mobile-image-container";

					if (imgTypeSplit[1] == "jpg" || imgTypeSplit[1] == "jpeg") {
						imgIconContainer.style.background = "#7D9BC2";
					}

					if (imgTypeSplit[1] == "gif") {
						imgIconContainer.style.background = "#C77B18";
					}

					if (imgTypeSplit[1] == "pdf" || imgTypeSplit[1] == "png") {
						imgIconContainer.style.background = "#C71841";
					}

					imgIconContainer.append(imgTypeSplit[1]);
					imgIcon.appendChild(imgIconContainer);
					imgView.appendChild(imgIcon);
					var imgName = document.createElement("td");
					imgName.className = "image-name " + image.name;
					imgName.innerHTML = image.name;
					imgView.appendChild(imgName); // previewing image
					// var img = document.createElement("img");
					// img.className = "imgage-img";
					// imgView.appendChild(img);
					// read the image...
					// var imputImgData = createInput ('image-data', "");

					var reader = new FileReader();

					reader.onload = function (e) {
						// img.src = e.target.result;
						var imputImgData = createInput('image-data', e.target.result);
						imgName.appendChild(imputImgData);
					};

					reader.readAsDataURL(image); // create field for image name

					var imputImgName = createInput('image-name', image.name);
					imgName.appendChild(imputImgName);
					var imputImgSize = createInput('image-size', image.size);
					imgName.appendChild(imputImgSize);
					var imputImgType = createInput('image-type', image.type);
					imgName.appendChild(imputImgType);
					var imgSize = document.createElement("td");
					imgSize.className = "image-size";
					var newSize = image.size / 1000;

					if (newSize >= 1000) {
						newSize = (newSize / 1000).toFixed(2) + " mb";
					} else {
						newSize = newSize.toFixed(2) + " kb";
					}

					imgSize.innerHTML = newSize;
					imgView.appendChild(imgSize);
					var imgWrap = document.createElement("td");
					imgWrap.className = "success-or-error";
					imgView.appendChild(imgWrap);
					var imgSuccess = document.createElement("img");
					imgSuccess.src = "images/checked.svg";
					imgWrap.appendChild(imgSuccess);
				};

				var imagePreviewRegion = dropRegion.closest('table').querySelector('.image-preview'); // var realInput = dropRegion.querySelector('.drop-region-input');

				document.body.addEventListener("change", function (event) {
					if (event.srcElement.classList.value == 'drop-region-input') {
						imagePreviewRegion = event.srcElement.closest('table').querySelector('.image-preview');
						var files = event.srcElement.files;
						handleFiles(files);
					}
				});
				dropRegion.addEventListener('dragenter', preventDefault, false);
				dropRegion.addEventListener('dragleave', preventDefault, false);
				dropRegion.addEventListener('dragover', preventDefault, false);
				dropRegion.addEventListener('drop', preventDefault, false);
				dropRegion.addEventListener('drop', handleDrop, false);
			}
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 20 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var $toggleMenu = $(".toggleMenu");
				var $iconClose = $(".button-close ");
				var $toggleOnCurtainMenu = $(".toggle-on-curtain-menu");
				var $curtainDropdown = $(".curtain-menu");
				var $headerNavigationA = $("header nav a");

				function closeMegaMenu(obj) {
					$toggleOnCurtainMenu.removeClass('hide');
					$curtainDropdown.addClass('hide');
					$iconClose.addClass('hide');
					$toggleMenu.removeAttr("style");
				}

				function closeCheckoutDropdown() {
					$curtainDropdown.stop().animate({
						opacity: '0'
					}, 300);
					$curtainDropdown.removeClass('show').addClass('hide');
					$toggleOnCurtainMenu.toggleClass('hide');
					$toggleMenu.removeAttr("style");
				}

				function openMegaMenu(obj, e) {
					e.preventDefault();
					var $linkKey = obj.data('toggle');
					$curtainDropdown.each(function (i) {
						var $el = $(this);

						if ($el.data('toggle') === $linkKey) {
							$el.toggleClass('hide');
						}
					});
					$toggleOnCurtainMenu.toggleClass('hide');
					$iconClose.toggleClass('hide');
					obj.css("color", "#3a957c");
				}

				function dropdownInit() {
					var wid = $(window).width();

					if (wid < 1025) {
						$toggleMenu.on('click', function (e) {
							openMegaMenu($(this), e);
						});
						$iconClose.on('click', function () {
							closeMegaMenu();
						}); //close the shopping cart menu when clicking outside of it

						$(document).click(function (event) {
							var $target = $(event.target);

							if (!$target.closest('#curtain-menu').length && !$target.closest('#toggleMenu').length) {
								closeMegaMenu();
							}
						});
					} else if (wid > 1025) {
						$toggleMenu.mouseenter(function (e) {
							var $linkKey = $(this).data('toggle');
							$curtainDropdown.each(function (i) {
								var $el = $(this);

								if ($el.data('toggle') === $linkKey) {
									$el.removeClass('hide').addClass('show');
									$el.stop().animate({
										opacity: '1'
									}, 200);
								}
							});
						});
						$curtainDropdown.mouseleave(function () {
							closeCheckoutDropdown();
						});
					}
				}

				dropdownInit();
				$(window).on("resize", function () {
					dropdownInit();
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 21 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				$('.list-item').hover(function () {
					$(this).prev().find('.item').css({
						'border-bottom-color': 'transparent'
					});
				}, function () {
					$(this).prev().find('.item').removeAttr('style');
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 22 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var item = $(".selectable");
				var selectAllLabel = $(".checkbox__select-all__label");
				$("#checkbox__select-all").click(function () {
					item.prop("checked", $(this).prop("checked"));
					selectAllLabel.text('Delete All');
				});
				item.click(function () {
					if (!$(this).prop("checked")) {
						$("#checkbox__select-all").prop("checked", false);
						selectAllLabel.text('Select All');
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 23 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				if ($(window).width() > 992) {
					if ($('.card-fixed').length) {
						var checkCardWrap = $('.card-fixed'),
							checkCard = $('.card-fixed__inner'),
							startPosition = checkCardWrap.offset().top,
							headerWrap = $('header').outerHeight(),
							stopPosition = $('footer').offset().top - checkCard.outerHeight() - 60;
						$(document).scroll(function () {
							//stick nav to top of page
							var y = $(this).scrollTop() + headerWrap + 25;

							if (y >= startPosition) {
								checkCard.addClass('position-fixed');

								if (y > stopPosition) {
									checkCard.css('top', stopPosition - y + headerWrap + 25);
								} else {
									checkCard.css('top', headerWrap + 25);
								}
							} else if (y <= stopPosition) {
								checkCard.removeClass('position-fixed');
								checkCard.css('top', 0);
							}
						});
					} else {
						return false;
					}
				}
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 24 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var linkNext = $('.choose__e-type');
				var confirmInit = $('.initialize-confirm');
				var confirmSign = $('[ data-signature="signature-confirmed"]');
				var insertInit = $('[data-confirm="toggle-initialize-confirm"]');
				var btnBack = $('[data-role="back"]');
				var btnSign = $('[data-role="sign"]');
				var btnPlaceholder = $('[data-role="sign-placeholder"]');
				var btnChooseType = $('[data-role="choose-e-type"]');
				var ctaNavFooter = $('#cta-footer-nav');
				var ctaContinueFooter = $('#cta-footer-continue');
				var inputs = $('[data-inputforms="input-forms"]');
				var alertSuccess = $('[data-alert="alert-primary-initialize"]');
				var tabs = $('[data-toggle="pill"]');
				var btnContinue = $('[data-btn="continue"]');
				var btnContinueConfirm = $('[data-role="continue-confirm"]');
				var btnContinueConfirmBtn = $('[data-role="continue-confirm"] .btn');
				var btnInsert = $('[data-btn="insert"]');
				var requiredStarts = $('[data-role="required-star"]');
				var signCheck = $('[data-signature="signature-check"]');
				var alertTac = $('[data-alert="alert-agree-initialize"]');
				var agreeTac = $('[data-role="agree-with-tac"]');
				var signBack = $('[data-role="signBack"]');
				var backToCard = $('[data-role="backToCard"]');
				var isModalValid = false;
				backToCard.on('click', function () {
					signCheck.addClass('d-none');
					confirmSign.addClass('d-none');
					$('#cta-footer-continue').addClass('d-none');
					$('#cta-footer-nav').removeClass('d-none');
					btnPlaceholder.removeClass('d-none');
					btnBack.removeClass('d-none');
				});
				signBack.on('click', function () {
					$(this).addClass('d-none');
					inputs.slideDown();
					signCheck.addClass('d-none');
					confirmSign.addClass('d-none');
					$('[data-role="sign-placeholder"] .btn').addClass('d-none');
					$('#cta-footer-continue').addClass('d-none');
					$('#cta-footer-nav').removeClass('d-none');
					alertSuccess.css('display', 'none');
					inputs.css('margin-top', '0');
				});
				linkNext.on('click', function () {
					$('.modal').modal('hide');
					$('body').addClass('modal-open_custom');
				});
				$('.modal-sign .close-modal').on('click', function () {
					$('.modal').modal('hide');
					$('body').removeClass('modal-open_custom');
				});
				$('.modal').on('click', function (e) {
					if (e.target !== this) {
						return;
					}

					$('.modal').modal('hide');
					$('body').removeClass('modal-open_custom');
				});
				tabs.click(function () {
					if ($(this).is('[data-tab="continue"]')) {
						btnContinue.removeClass('d-none');
						btnInsert.addClass('d-none');
					} else {
						btnContinue.addClass('d-none');
						btnInsert.removeClass('d-none');
					}
				});
				btnSign.click(function () {
					if ($(window).width() < 992) {
						btnSign.addClass('d-none');
						ctaNavFooter.addClass('d-none');
						ctaContinueFooter.removeClass('d-none');
						inputs.css('margin-top', '60px');
					}

					btnPlaceholder.addClass('d-none');
					confirmSign.addClass('border-bottom__70');
					btnBack.addClass('d-none');
					confirmSign.removeClass('d-none');
					inputs.slideDown();
					alertSuccess.slideToggle();
					btnContinue.removeClass('d-none');
					btnContinueConfirm.removeClass('d-none');
				});
				insertInit.click(function (e) {
					e.preventDefault();

					if ($(window).width() > 992) {
						btnChooseType.addClass('d-none');
					}

					inputs.slideUp();
					confirmInit.removeClass('d-none');
					requiredStarts.removeClass('d-none');
					signCheck.removeClass('d-none');
					btnPlaceholder.removeClass('d-none');
					btnBack.removeClass('d-none');
					btnSign.prop("disabled", false).removeClass('d-none');
					signBack.removeClass('d-none');
				});
				agreeTac.click(function (e) {
					alertTac.slideToggle(function () {
						$(this).addClass('d-none');
						isModalValid = true;
						btnContinueConfirmBtn.prop("disabled", false);
					});

					if ($(window).width() < 992) {
						inputs.css('margin-top', '0px');
					}
				});
				btnContinueConfirmBtn.click(function () {
					if (!isModalValid) {
						alertTac.slideToggle();
						alertSuccess.slideToggle();
						btnContinueConfirmBtn.prop("disabled", true);

						if ($(window).width() < 992) {
							inputs.css('margin-top', '120px');
							signBack.addClass('d-none');
						}
					} else {
						$('.modal').modal('hide');
						$('body').removeClass('modal-open_custom');
						$("#modal__e-sign__success").modal("show");
						$('body').addClass('modal-open_custom');
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 25 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				$(document).on('change', '.custom-file-input', function () {
					var inputValue = this.value;
					var label = $('.custom-file-label__text');
					label.text(inputValue.substr(inputValue.lastIndexOf('\\') + 1));
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 26 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var toggleRegister = $('[data-role="toggle-el"]');
				var toggleRegisterTarget = $('[data-role="toggle-el-target"]');
				toggleRegister.click(function () {
					$('.nav-link').removeClass('active');
					$(this).addClass('active');
					toggleRegisterTarget.slideToggle();
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 27 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function ($) {
			var didScroll;
			var lastScrollTop = 0;
			var delta = 2;
			var navbarHeight = $('header').outerHeight();
			$(window).scroll(function (event) {
				didScroll = true;
			});
			setInterval(function () {
				if (didScroll) {
					hasScrolled();
					didScroll = false;
				}
			}, 250);

			function hasScrolled() {
				if ($(window).width() <= 992) {
					var st = $(this).scrollTop(); // if(Math.abs(lastScrollTop - st) <= delta)
					// 	return;
					// if (st > lastScrollTop && st > navbarHeight){
					// 	$('header').removeClass('nav-down').addClass('nav-up');
					// } else {
					// 	if(st + $(window).height() < $(document).height()) {
					// 		$('header').removeClass('nav-up').addClass('nav-down');
					// 	}
					// }
					// lastScrollTop = st;
					// sticky header

					if (st >= 100) {
						$('header').removeClass('nav-down').addClass('nav-up');
					} else {
						$('header').removeClass('nav-up').addClass('nav-down');
					}
				}
			}

			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 28 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			function _createForOfIteratorHelper(o, allowArrayLike) {
				var it;
				if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
					if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
						if (it) o = it;
						var i = 0;
						var F = function F() {
						};
						return {
							s: F, n: function n() {
								if (i >= o.length) return {done: true};
								return {done: false, value: o[i++]};
							}, e: function e(_e) {
								throw _e;
							}, f: F
						};
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
				}
				var normalCompletion = true, didErr = false, err;
				return {
					s: function s() {
						it = o[Symbol.iterator]();
					}, n: function n() {
						var step = it.next();
						normalCompletion = step.done;
						return step;
					}, e: function e(_e2) {
						didErr = true;
						err = _e2;
					}, f: function f() {
						try {
							if (!normalCompletion && it["return"] != null) it["return"]();
						} finally {
							if (didErr) throw err;
						}
					}
				};
			}

			function _unsupportedIterableToArray(o, minLen) {
				if (!o) return;
				if (typeof o === "string") return _arrayLikeToArray(o, minLen);
				var n = Object.prototype.toString.call(o).slice(8, -1);
				if (n === "Object" && o.constructor) n = o.constructor.name;
				if (n === "Map" || n === "Set") return Array.from(o);
				if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
			}

			function _arrayLikeToArray(arr, len) {
				if (len == null || len > arr.length) len = arr.length;
				for (var i = 0, arr2 = new Array(len); i < len; i++) {
					arr2[i] = arr[i];
				}
				return arr2;
			}

			jQuery(document).ready(function ($) {
				var selectBox = $('.select-custom');
				var selectOption = $('.select-option');
				var selectedOptionRender = $('.selected-option');
				var selectedOption = $('.select-custom__option.selected');
				selectBox.on('click', function () {
					$(this).find('.select-custom__list .selected.default').addClass('d-none');
					$(this).find('.select-custom__list').toggleClass('d-block');
					$(this).find('.select-custom__box').toggleClass('active');
					$(this).find('.hover__rotate-angle').toggleClass('rotate');
				});

				function loadDefaultOption() {
					selectBox.each(function () {
						var selected = $(this).find(selectedOption).clone();
						var render = $(this).find(selectedOptionRender);
						render.html(selected);
					});
				}

				loadDefaultOption();
				selectOption.click(function () {
					var option = $(this).clone();
					var render = $(this).closest(selectBox).find(selectedOptionRender);
					render.html(option);
				}); // my custom select dropdown

				var _iterator = _createForOfIteratorHelper(document.querySelectorAll(".my-custom-select-wrapper")),
					_step;

				try {
					for (_iterator.s(); !(_step = _iterator.n()).done;) {
						var dropdown = _step.value;
						dropdown.addEventListener('click', function () {
							this.querySelector('.my-custom-select').classList.toggle('open-select');
						});
					}
				} catch (err) {
					_iterator.e(err);
				} finally {
					_iterator.f();
				}

				var _iterator2 = _createForOfIteratorHelper(document.querySelectorAll(".my-custom-option")),
					_step2;

				try {
					for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
						var option = _step2.value;
						option.addEventListener('click', function () {
							if (!this.classList.contains('selected')) {
								this.parentNode.querySelector('.my-custom-option.selected').classList.remove('selected');
								this.classList.add('selected');
								this.closest('.my-custom-select').querySelector('.my-custom-select__trigger span').textContent = this.textContent;
							}
						});
					} // window.addEventListener('click', function (e) {
					//     const select = document.querySelector('.my-custom-select')
					//     if (!select.contains(e.target)) {
					//         select.classList.remove('open');
					//     }
					// });

				} catch (err) {
					_iterator2.e(err);
				} finally {
					_iterator2.f();
				}

				window.addEventListener('click', function (e) {
					var _iterator3 = _createForOfIteratorHelper(document.querySelectorAll('.my-custom-select')),
						_step3;

					try {
						for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
							var select = _step3.value;

							if (!select.contains(e.target)) {
								select.classList.remove('open-select');
							}
						}
					} catch (err) {
						_iterator3.e(err);
					} finally {
						_iterator3.f();
					}
				}); // select dropdown contains another select dropdowns

				$('.my-custom-select-selects-wrapper').on('click', function () {
					$(this).find('.my-customs-select').toggleClass('opens-select');
				}); // open inner select dropdown

				$('.my-custom-select-select-wrapper').on('click', function (e) {
					e.stopPropagation();
					$(this).find('.my-customs-select-select').toggleClass('open-second-select').parents('.my-custom-select-select-wrapper').siblings('.my-custom-select-select-wrapper').find('.my-customs-select-select').removeClass('open-second-select');
				}); // click on the option in general select dropdown

				$('.my-customs-option').on('click', function () {
					$(this).addClass('selected').siblings('.my-customs-option').removeClass('selected');
					$(this).parents('.my-custom-select-selects-wrapper').find('.my-customs-select__trigger span').text($(this).text());
					$(this).parents('.my-custom-select-selects-wrapper').find('.my-custom-select-select-wrapper').each(function () {
						$(this).find('.my-customs-select-select-option').removeClass('selected');
						$(this).find('.my-customs-select-select__trigger').removeClass('opened');
						$(this).find('.my-customs-select-select__trigger span').text($(this).find('.js-default-value').text());
						$(this).find('.my-customs-select-select').removeClass('open-second-select');
					});
				}); // click on the option on inner select dropdown

				$('.my-customs-select-select-option').on('click', function () {
					$(this).addClass('selected').siblings('.my-customs-select-select-option').removeClass('selected');
					$(this).parents('.my-custom-select-select-wrapper').find('.my-customs-select-select__trigger').addClass('opened');
					$(this).parents('.my-custom-select-select-wrapper').find('.my-customs-select-select__trigger span').text($(this).text());
					$(this).parents('.my-custom-select-select-wrapper').siblings('.my-custom-select-select-wrapper').each(function () {
						$(this).find('.my-customs-select-select__trigger span').text($(this).find('.js-default-value').text());
						$(this).find('.my-customs-select-select-option').removeClass('selected');
						$(this).find('.my-customs-select-select__trigger').removeClass('opened');
					});
					$(this).parents('.my-custom-select-selects-wrapper').find('.my-customs-select__trigger span').text($(this).text());
					$(this).parents('.my-custom-select-selects-wrapper').find('.my-customs-option').removeClass('selected');
					$(this).parents('.my-custom-select-selects-wrapper').find('.my-customs-select').removeClass('opens-select');
				});
				window.addEventListener('click', function (e) {
					var _iterator4 = _createForOfIteratorHelper(document.querySelectorAll('.my-customs-select')),
						_step4;

					try {
						for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
							var secondSelect = _step4.value;

							if (!secondSelect.contains(e.target)) {
								secondSelect.classList.remove('opens-select');
							}
						}
					} catch (err) {
						_iterator4.e(err);
					} finally {
						_iterator4.f();
					}
				}); // select dropdown with checkboxes

				function checkboxDropdown(el) {
					var $el = $(el);

					function updateStatus(label, result) {
						if (!result.length) {
							label.html($el.find('.dropdown-label').attr('data-default-text') + '<span></span>');
						}
					}

					;
					$el.each(function (i, element) {
						var _this = this;

						var $list = $(this).find('.dropdown-list'),
							$label = $(this).find('.dropdown-label'),
							$inputs = $(this).find('.check'),
							$clearBtn = $(this).siblings('.js-clear-all-product-filters'),
							defaultChecked = $(this).find('input[type=checkbox]:checked'),
							result = [];
						updateStatus($label, result);

						if (defaultChecked.length) {
							defaultChecked.each(function () {
								result.push($(this).next().text());
								$label.html(result.join(", "));
							});
						}

						$label.on('click', function () {
							$(_this).toggleClass('open');
						});
						$inputs.on('change', function () {
							var checked = $(this).is(':checked');
							var checkedText = $(this).next().text();

							if (checked) {
								result.push(checkedText);
								$label.html(result.join(",<br>") + '<span class="not-empty"></span>');
							} else {
								var index = result.indexOf(checkedText);

								if (index >= 0) {
									result.splice(index, 1);
								}

								$label.html(result.join(",<br>") + '<span class="not-empty"></span>');
							}

							updateStatus($label, result);
						});
						$clearBtn.on('click', function () {
							$(this).css('display', 'none');
							result.splice(0, result.length);
							$label.html($label.attr('data-default-text') + '<span></span>');
							$inputs.prop('checked', false);
						});
						$(document).on('click touchstart', function (e) {
							if (!$(e.target).closest($(_this)).length) {
								$(_this).removeClass('open');
							}
						});
					});
				}

				;

				if ($('.dropdown').length >= 1) {
					$('.dropdown').each(function () {
						checkboxDropdown($(this));
					});
				}

				$('.multiselectbox').selectpicker();
				$('.bootstrap-select__ctg__wrap .js-clear-filter').on('click', function () {
					$('.bootstrap-select__ctg__wrap .multiselectbox').selectpicker('deselectAll');
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 29 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				$('.js-pay-card-number').on('input', function (e) {
					var target = e.target,
						position = target.selectionEnd,
						length = target.value.length;
					target.value = target.value.replace(/[^\dA-Z]/g, '').replace(/(.{4})/g, '$1 ').trim();
					target.selectionEnd = position += target.value.charAt(position - 1) === ' ' && target.value.charAt(length - 1) === ' ' && length !== target.value.length ? 1 : 0;
				});
				$('.js-pay-card-date').on('input', function (e) {
					var target = e.target,
						position = target.selectionEnd,
						length = target.value.length;
					target.value = target.value.replace(/[^\dA-Z]/g, '').replace(/(.{2})/g, '$1/').trim().substr(0, 5);
					target.selectionEnd = position += target.value.charAt(position - 1) === '/' ? 1 : 0;
				});
				$('.js-pay-card-cv').on('input', function (e) {
					var target = e.target;
					target.value = target.value.replace(/[^\dA-Z]/g, '');
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 30 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var btnLoadPage = $('.btn-load-page');
				btnLoadPage.click(function () {
					var iframe = $(this).data('target');
					var src = $(this).data('src');
					$(iframe + ' iframe').attr('src', src);
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 31 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			var _require = __webpack_require__(32),
				on = _require.on;

			var _require2 = __webpack_require__(0),
				contains = _require2.contains;

			jQuery(document).ready(function ($) {
				var datapickerBlock = $('#home-consult__modal-datepicker');
				var mobileSecondHomeConsultForm = $('#mobile-second-home-consult-form');

				if ($(datapickerBlock).length >= 1) {
					$(datapickerBlock).datepicker('setDate', new Date());
				}

				if ($(window).width() < 992) {
					var myOrderDateStart = $('#mobile-my-order-from-date'),
						myOrderDateStartContainer = $('.mobile-from-date'),
						myOrderDateEnd = $('#mobile-my-order-end-date'),
						myOrderDateEndContainer = $('.mobile-end-date');
				} else {
					var myOrderDateStart = $('#my-order-from-date'),
						myOrderDateStartContainer = $('.from-date'),
						myOrderDateEnd = $('#my-order-end-date'),
						myOrderDateEndContainer = $('.end-date');
				}

				if (myOrderDateStart.length >= 1 || myOrderDateEnd.length >= 1 || myOrderDateStartContainer.length >= 1 || myOrderDateEndContainer.length >= 1) {
					var ConfigureToDate = function ConfigureToDate() {
						$(myOrderDateEnd).val("").datepicker("update");
						$(myOrderDateEnd).datepicker('setStartDate', $(myOrderDateStart).val());
					};

					$(myOrderDateStart).datepicker({
						autoclose: true,
						todayHighlight: true,
						format: 'mm/dd/yyyy',
						weekStart: 1,
						container: $(myOrderDateStartContainer)
					}).on('changeDate', function (e) {
						ConfigureToDate();
					});
					$(myOrderDateEnd).datepicker({
						autoclose: true,
						todayHighlight: true,
						format: 'mm/dd/yyyy',
						weekStart: 1,
						container: $(myOrderDateEndContainer)
					});
				}

				$(mobileSecondHomeConsultForm).scroll(function () {
					$('.home-consult-form__input.date-pikcer').blur();
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 32 */
	/***/ (function (module, exports) {

// shim for using process in browser
		var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

		var cachedSetTimeout;
		var cachedClearTimeout;

		function defaultSetTimout() {
			throw new Error('setTimeout has not been defined');
		}

		function defaultClearTimeout() {
			throw new Error('clearTimeout has not been defined');
		}

		(function () {
			try {
				if (typeof setTimeout === 'function') {
					cachedSetTimeout = setTimeout;
				} else {
					cachedSetTimeout = defaultSetTimout;
				}
			} catch (e) {
				cachedSetTimeout = defaultSetTimout;
			}

			try {
				if (typeof clearTimeout === 'function') {
					cachedClearTimeout = clearTimeout;
				} else {
					cachedClearTimeout = defaultClearTimeout;
				}
			} catch (e) {
				cachedClearTimeout = defaultClearTimeout;
			}
		})();

		function runTimeout(fun) {
			if (cachedSetTimeout === setTimeout) {
				//normal enviroments in sane situations
				return setTimeout(fun, 0);
			} // if setTimeout wasn't available but was latter defined


			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
				cachedSetTimeout = setTimeout;
				return setTimeout(fun, 0);
			}

			try {
				// when when somebody has screwed with setTimeout but no I.E. maddness
				return cachedSetTimeout(fun, 0);
			} catch (e) {
				try {
					// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
					return cachedSetTimeout.call(null, fun, 0);
				} catch (e) {
					// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
					return cachedSetTimeout.call(this, fun, 0);
				}
			}
		}

		function runClearTimeout(marker) {
			if (cachedClearTimeout === clearTimeout) {
				//normal enviroments in sane situations
				return clearTimeout(marker);
			} // if clearTimeout wasn't available but was latter defined


			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
				cachedClearTimeout = clearTimeout;
				return clearTimeout(marker);
			}

			try {
				// when when somebody has screwed with setTimeout but no I.E. maddness
				return cachedClearTimeout(marker);
			} catch (e) {
				try {
					// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
					return cachedClearTimeout.call(null, marker);
				} catch (e) {
					// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
					// Some versions of I.E. have different rules for clearTimeout vs setTimeout
					return cachedClearTimeout.call(this, marker);
				}
			}
		}

		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
			if (!draining || !currentQueue) {
				return;
			}

			draining = false;

			if (currentQueue.length) {
				queue = currentQueue.concat(queue);
			} else {
				queueIndex = -1;
			}

			if (queue.length) {
				drainQueue();
			}
		}

		function drainQueue() {
			if (draining) {
				return;
			}

			var timeout = runTimeout(cleanUpNextTick);
			draining = true;
			var len = queue.length;

			while (len) {
				currentQueue = queue;
				queue = [];

				while (++queueIndex < len) {
					if (currentQueue) {
						currentQueue[queueIndex].run();
					}
				}

				queueIndex = -1;
				len = queue.length;
			}

			currentQueue = null;
			draining = false;
			runClearTimeout(timeout);
		}

		process.nextTick = function (fun) {
			var args = new Array(arguments.length - 1);

			if (arguments.length > 1) {
				for (var i = 1; i < arguments.length; i++) {
					args[i - 1] = arguments[i];
				}
			}

			queue.push(new Item(fun, args));

			if (queue.length === 1 && !draining) {
				runTimeout(drainQueue);
			}
		}; // v8 likes predictible objects


		function Item(fun, array) {
			this.fun = fun;
			this.array = array;
		}

		Item.prototype.run = function () {
			this.fun.apply(null, this.array);
		};

		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues

		process.versions = {};

		function noop() {
		}

		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;

		process.listeners = function (name) {
			return [];
		};

		process.binding = function (name) {
			throw new Error('process.binding is not supported');
		};

		process.cwd = function () {
			return '/';
		};

		process.chdir = function (dir) {
			throw new Error('process.chdir is not supported');
		};

		process.umask = function () {
			return 0;
		};

		/***/
	}),
	/* 33 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function ($) {
			$(document).on("show.bs.modal", '.modal', function (event) {
				// console.log("Global show.bs.modal fire");
				var zIndex = 1040 + 10 * $(".modal:visible").length;
				$(this).css("z-index", zIndex);
				setTimeout(function () {
					$(".modal-backdrop").not(".modal-stack").first().css("z-index", zIndex - 1).addClass("modal-stack");
				}, 0);
			}).on("hidden.bs.modal", '.modal', function (event) {
				// console.log("Global hidden.bs.modal fire");
				$(".modal:visible").length && $("body").addClass("modal-open");
			});
			$(document).on('inserted.bs.tooltip', function (event) {
				// console.log("Global show.bs.tooltip fire");
				var zIndex = 1045 + 10 * $(".modal:visible").length;
				var tooltipId = $(event.target).attr("aria-describedby");
				$("#" + tooltipId).css("z-index", zIndex);
			});
			$(document).on('inserted.bs.popover', function (event) {
				// console.log("Global inserted.bs.popover fire");
				var zIndex = 1045 + 10 * $(".modal:visible").length;
				var popoverId = $(event.target).attr("aria-describedby");
				$("#" + popoverId).css("z-index", zIndex);
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 34 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
			/* harmony import */
			var jquery_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
			/* harmony import */
			var jquery_ui__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_ui__WEBPACK_IMPORTED_MODULE_1__);


			jQuery(document).ready(function ($) {
				$(function () {
					$('[data-toggle="tooltip"]').tooltip();
				}); // clicl some filters checkbox to show clear button

				$('.js-add-product-filter').on('click', function () {
					var clickedCheckbox = $(this),
						checkboxWrapper = $(this).parents('.js-product-filters');
					$(this).parents('.dropdown').removeClass('open');

					if ($(clickedCheckbox).is(':checked')) {
						if ($(checkboxWrapper).find('input[type="checkbox"]:checked').length >= 1) {
							$('.js-clear-all-product-filters').css('display', 'block');
						} else {
							$('.js-clear-all-product-filters').css('display', 'none');
						}
					} else {
						if ($(checkboxWrapper).find('input[type="checkbox"]:checked').length >= 1) {
							$('.js-clear-all-product-filters').css('display', 'flex');
						} else {
							$('.js-clear-all-product-filters').css('display', 'none');
						}
					}
				}); //add to cart

				$('.js-add-to-card-button').on('click', function () {
					if ($(window).width() > 992) {
						var cart = $('.js-add-to-card');
						var imgtodrag = $('.js-add-to-card-image-holder .slick-current.slick-center').find('img').eq(0);

						if (imgtodrag) {
							var imgclone = imgtodrag.clone().offset({
								top: imgtodrag.offset().top,
								left: imgtodrag.offset().left
							}).css({
								'position': 'absolute',
								'width': imgtodrag.width(),
								'height': imgtodrag.height(),
								'z-index': '10000'
							}, 1000).appendTo($('body')).animate({
								'top': cart.offset().top + 10,
								'left': cart.offset().left + 10,
								'opacity': '0.5',
								'width': '50px',
								'height': '50px',
								'z-index': '100'
							}, 1000);
							imgclone.animate({
								'width': 0,
								'height': 0
							}, function () {
								$(this).detach();
							});
						}
					}
				});

				if ($('.js-text-wrap').length >= 1) {
					var textWrapTop;
					setTimeout(function () {
						textWrapTop = $('.js-text-wrap').find('.tab-content__text-wrap--title').offset().top;
					}, 100);
				} // show hidden text


				$('.js-btn-read-all-text').on('click', function () {
					$(this).toggleClass('active'); // var titlePosition = $(this).siblings('.js-text-wrap').find('.tab-content__text-wrap--title').offset().top;

					console.log(textWrapTop);

					if ($(this).hasClass('active')) {
						$(this).siblings('.js-text-wrap').addClass('opened');
						$(this).find('span').text($(this).attr('data-readLess'));
					} else {
						$(this).siblings('.js-text-wrap').removeClass('opened').animate({
							scrollTop: -textWrapTop
						}, 800);
						$(this).find('span').text($(this).attr('data-readAll'));
					}
				}); //button back to filters

				$('.back-to-filters-wrap').hover(function () {
					$(this).find('.back-to-filters').addClass('clicked').text($(this).find('.back-to-filters').attr('data-second-text'));
				}, function () {
					$(this).find('.back-to-filters').removeClass('clicked').text($(this).find('.back-to-filters').attr('data-default-text'));
				});
				$('.back-to-filters-wrap').on('click', function () {
					if ($(this).find('.back-to-filters').hasClass('clicked')) {
						$(this).find('.back-to-filters').removeClass('clicked').text($(this).find('.back-to-filters').attr('data-default-text'));
					} else {
						$(this).find('.back-to-filters').addClass('clicked').text($(this).find('.back-to-filters').attr('data-second-text'));
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 35 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
			/* harmony import */
			var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);


			jQuery(document).ready(function ($) {
				// clicl account setings buttons to show details
				$('.js-open-hidden-box').on('click', function () {
					if ($(window).width() > 992) {
						$(this).addClass('active').siblings().removeClass('active');
						$($(this).attr('date-open-block')).addClass('active').siblings('.account-block__details').removeClass('active');
						$($(this).attr('date-open-block')).siblings('.account-block__details').find('.account-block__form').removeClass('active');
						$($(this).attr('date-open-block')).siblings('.account-block__details').find('.account-block__details__wrapper--edit-button').show();
					} else {
						if ($(this).hasClass('active')) {
							$(this).removeClass('active').siblings().removeClass('active');
							$(this).siblings('.mobile-show').empty();
						} else {
							$(this).addClass('active').siblings().removeClass('active');
							$(this).siblings('.mobile-show').empty();
							$($(this).attr('date-open-block')).clone().appendTo($($(this).attr('data-open-mobile-block')));
							$($(this).attr('data-open-mobile-block')).find('.account-block__details').fadeIn(300);
						}
					}
				});

				function hideMobileAccountSettingsButtons(e) {
					var el = e.target.closest('.js-show-mobile-action-btn');

					if (!el) {
						$('.js-show-mobile-action-buttons').fadeOut(300);
						document.removeEventListener('click', hideMobileAccountSettingsButtons);
					}
				} // show mobile edit and delete buttons


				document.body.addEventListener('click', function (event) {
					if ($(event.target).hasClass('js-show-mobile-action-btn')) {
						var clickedButton = event.target;
						$(clickedButton).parents('.card').siblings().find('.js-show-mobile-action-buttons').each(function () {
							$(this).fadeOut(300);
						});
						$(clickedButton).siblings('.js-show-mobile-action-buttons').fadeIn(300);
						setTimeout(function () {
							document.addEventListener('click', hideMobileAccountSettingsButtons);
						});
					}

					if ($(event.target).hasClass('js-modal-type') || $(event.target).parent().hasClass('js-modal-type')) {
						if ($(event.target).hasClass('js-modal-type')) {
							var modal = $(event.target).attr('data-target'),
								newTextTitle = $(event.target).attr('data-address-type');
						} else {
							var modal = $(event.target).parent().attr('data-target'),
								newTextTitle = $(event.target).parent().attr('data-address-type');
						}

						$(modal).find('.modal-title span').text(newTextTitle);
					}
				}); // show my-order collapse

				$('.js-show-my-orders').on('click', function () {
					$(this).siblings('button.btn-secondary').show();
					$('.account-block__collapse').addClass('open');
				}); //hide my-order collapse

				$('.js-hide-my-orders').on('click', function () {
					$(this).hide();
					$('.account-block__collapse').removeClass('open');
				});
				$('.my-order .account-block__collapse--header').on('click', function () {
					if ($(window).width() > 992) {
						if ($(this).hasClass('collapsed')) {
							$(this).find('.js-read-button span').text($(this).find('.js-read-button').attr('data-readLess'));
						} else {
							$(this).find('.js-read-button span').text($(this).find('.js-read-button').attr('data-readAll'));
						}

						$(this).parents('.my-order').toggleClass('active').siblings().removeClass('active');
						$(this).parents('.my-order').siblings().find('.js-read-button span').text($(this).find('.js-read-button').attr('data-readAll'));
					}
				});
				$('.account-block__collapse--header').on('click', function () {
					if ($(window).width() > 992) {
						$(this).parents('.card').siblings().find('.account-block__details--edit-button').show();

						if ($(this).hasClass('collapsed')) {
							$(this).find('.account-block__details--edit-button').hide();
						} else {
							$(this).find('.account-block__details--edit-button').show();
						}
					} else {
						if ($(this).hasClass('collapsed')) {
							$('html, body').animate({
								scrollTop: $("#accordion").offset().top - 150
							}, 800);
						}
					}
				}); // change defalt image on add new house image

				$('.js-img-up').on('change', function () {
					if (this.files && this.files[0]) {
						
						var reader = new FileReader(),
							changedInput = this;

						reader.onload = function (e) {
							
							// Added by Mark
							$.ajax({
								method: "POST",
								url: "pages/account-ajax/ajax-add-blob-image.php",
								data: {blob_image: e.target.result}
							}).done(function(data) {
								//console.log(data);								
							}).fail(function() {
								//console.log("failed");
							});
							// End Mark

							$('.js-y-house-defalt-img').hide();
							
							$('.js-my-house-img-view').attr('src', e.target.result).show().parent('a').attr('href', e.target.result);
							
							$(changedInput).siblings('label').text($(changedInput).val().split('\\').pop());
							
						};

						reader.readAsDataURL(this.files[0]);
						
					}
				}); // select all saved houses

				$('.js-select-all-houses').on('click', function () {
					if ($(this).is(':checked')) {
						var modalHeader = $(this).parents('.modal-header');
						$(modalHeader).find('.house-checkbox').hide();
						$(modalHeader).find('.manage-house-filters__result').css('display', 'flex');
						$(modalHeader).find('.manage-house-filters__result--text span').text($(modalHeader).siblings('.modal-body').find('input[type="checkbox"]').length);
						$(modalHeader).siblings('.modal-body').find('input[type="checkbox"]').each(function () {
							$(this).prop('checked', true);
							$(this).parents('.manage-house-houses').find('.js-edit-house').addClass('active');
						});
					}
				}); // unselect all houses

				$('.js-manage-house-clear').on('click', function () {
					var modalHeader = $(this).parents('.modal-header');
					$(modalHeader).find('.house-checkbox').show();
					$(modalHeader).find('.js-select-all-houses').prop('checked', false);
					$(modalHeader).find('.manage-house-filters__result').css('display', 'none');
					$(modalHeader).siblings('.modal-body').find('input[type="checkbox"]').each(function () {
						$(this).prop('checked', false);
						$(this).parents('.manage-house-houses').find('.js-edit-house').removeClass('active');
					});
				}); // select one or more houses

				$('.js-select-house').on('click', function () {
					var modalBody = $(this).parents('.modal-body'),
						modalHeader = $(modalBody).siblings('.modal-header');

					if ($(this).is(':checked')) {
						$(this).parents('.manage-house-houses').find('.js-edit-house').addClass('active');

						if ($(modalBody).find('input[type="checkbox"]:checked').length > 0) {
							$(modalHeader).find('.house-checkbox').hide();
							$(modalHeader).find('.manage-house-filters__result').css('display', 'flex');
							$(modalHeader).find('.manage-house-filters__result--text span').text($(modalBody).find('input[type="checkbox"]:checked').length);
						} else {
							$(modalHeader).find('.house-checkbox').show();
							$(modalHeader).find('.js-select-all-houses').prop('checked', false);
							$(modalHeader).find('.manage-house-filters__result').css('display', 'none');
						}
					} else {
						$(this).parents('.manage-house-houses').find('.js-edit-house').removeClass('active');

						if ($(modalBody).find('input[type="checkbox"]:checked').length > 0) {
							$(modalHeader).find('.house-checkbox').hide();
							$(modalHeader).find('.manage-house-filters__result').css('display', 'flex');
							$(modalHeader).find('.manage-house-filters__result--text span').text($(modalBody).find('input[type="checkbox"]:checked').length);
						} else {
							$(modalHeader).find('.house-checkbox').show();
							$(modalHeader).find('.js-select-all-houses').prop('checked', false);
							$(modalHeader).find('.manage-house-filters__result').css('display', 'none');
						}
					}
				}); // edit house

				$('.js-edit-house').on('click', function () {
					var modal = $(this).attr('data-target'),
						houseId = $(this).attr('data-house-id');
					$(modal).find('.modal-title span').text('Edit house with ID = ' + houseId);

					if ($(window).width() > 992) {
						$(modal).find('.js-row-action').css('display', 'flex').removeClass('justify-content-center').addClass('justify-content-end');
						$(modal).find('.js-mobile-row-action').hide();
						$(modal).find('.js-col-edit-add').find('button.btn-primary span').text('save changes');
					} else {
						$(modal).find('.js-row-action').hide();
						$(modal).find('.js-mobile-row-action').css('display', 'flex').removeClass('justify-content-center').addClass('justify-content-end');
						$(modal).find('.js-col-edit-add').removeClass('col-12').addClass('col-6').find('button.btn-primary span').text('save changes');
					}

					$(modal).find('.js-col-delete').show();
				}); //add house

				$('.add-house').on('click', function () {
					var modal = $(this).attr('data-target');
					$(modal).find('.modal-title span').text('Add house');

					if ($(window).width() > 992) {
						$(modal).find('.js-row-action').css('display', 'flex').removeClass('justify-content-end').addClass('justify-content-center');
						$(modal).find('.js-mobile-row-action').hide();
						$(modal).find('.js-col-edit-add').find('button.btn-primary span').text('confirm');
					} else {
						$(modal).find('.js-row-action').hide();
						$(modal).find('.js-mobile-row-action').css('display', 'flex').removeClass('justify-content-end').addClass('justify-content-center');
						$(modal).find('.js-col-edit-add').removeClass('col-6').addClass('col-12').find('button.btn-primary span').text('confirm');
					}

					$(modal).find('.js-col-delete').hide();
				}); // function hideMobileAccountNav(e) {
				// 	var el = e.target.closest('.account-block__navigation--wrapper');
				// 	if (!el) {
				// 		$('#overlay-search').removeClass('open');
				// 		$('.account-block__navigation--wrapper').removeClass('active');
				// 		$('body').css('overflow','auto');
				// 		document.removeEventListener('click', hideMobileAccountNav);
				// 	}
				// }
				// account navigation in header

				$('.js-show-user-nav').on('click', function () {
					$('.account-block__navigation--wrapper').addClass('active');
					$('#overlay-mobile-nav').addClass('open');
					$('body').css('overflow', 'hidden'); // setTimeout(function() {
					// 	document.addEventListener('click', hideMobileAccountNav);
					// });
				}); //hide accunt nov

				$('.js-hide-account-mobile-menu').on('click', function () {
					$('.account-block__navigation--wrapper').removeClass('active');
					$('#overlay-mobile-nav').removeClass('open');
					$('body').css('overflow', 'auto');
				}); //mobile login show account nav

				$('.js-mobile-account-login').on('click', function () {
					$(this).css('display', 'none');
					$(this).parents('li').siblings('li').find('.account-mobile-menu-visible').css('display', 'none');
					$(this).parents('li').siblings('li').find('.account-menu-hidden').css('display', 'flex');
					$(this).parents('.account-block__navigation--wrapper').find('.js-login-txt').addClass('active');
					$(this).parents('.account-block__navigation--wrapper').find('.js-not-login-txt').removeClass('active');
				}); //mobile logout hive account nav

				$('.js-mobile-account-logout').on('click', function () {
					$(this).css('display', 'none');
					$(this).parents('li').siblings('li').find('.account-mobile-menu-visible').css('display', 'flex');
					$(this).parents('li').siblings('li').find('.account-menu-hidden').css('display', 'none');
					$(this).parents('.account-block__navigation--wrapper').find('.js-login-txt').removeClass('active');
					$(this).parents('.account-block__navigation--wrapper').find('.js-not-login-txt').addClass('active');
				}); // account navigation under header

				var $accountNav = $('.account-nav__content');

				if ($accountNav.length === 1) {
					var elemWidth = 0;
					$($accountNav).find('.home-mobile-buttons-block__link').each(function () {
						elemWidth += $(this).width();
					});
					Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* mobilePredNextButtons */ "c"])($('.account-nav__content'), $('.account-nav__prev'), $('.account-nav__next'), elemWidth);
				} //Hide mobile folver nav and show mobile folced content


				$('.js-hide-folder-nav').on('click', function () {
					if ($(window).width() < 992) {
						$(this).removeClass('active');
						$(this).parents('.js-folder-nav-wrap').fadeOut(100);
						$('.js-mobile-idea-folder-header').find('.js-back-house-list').removeClass('full-with-button');
						$('.js-mobile-idea-folder-header').find('.manage-folders').addClass('active');
						$('.js-mobile-idea-folder-header').find('.js-hide-folder-nav-content-btn').addClass('active').attr('date-aria-controls', $(this).attr('aria-controls'));
						$('.js-mobile-idea-folder-header').find('.mobile-idea-folder--details__content').addClass('active');
						$('.js-mobile-idea-folder-header').find('.mobile-idea-folder--details__text-box').empty().html($(this).html()); // $('.js-mobile-idea-folder-header').find('.js-show-mobile-action-btn').fadeIn(100);
					} else {
						$($(this).attr('href')).siblings().each(function () {
							if ($(this).find('.js-saved-images-box').length()) {
								$(this).find('.js-saved-images-box').fadeIn(500);
								$(this).find('.js-specification-sheet-box').fadeOut(10);
								$(this).find('.js-add-to-rooms-new-idea-folder-images').fadeOut(10);
							} else {
								$(this).find('.js-saved-images-box').fadeOut(10);
								$(this).find('.js-specification-sheet-box').fadeOut(10);
								$(this).find('.js-add-to-rooms-new-idea-folder-images').fadeIn(500);
							}
						});
					}
				}); //Hide mobile folced content and show mobile folver nav

				$('.js-hide-folder-nav-content-btn').on('click', function () {
					if ($(window).width() < 992) {
						$(this).removeClass('active');
						$(this).parents('.js-folder-nav-content').fadeOut(100);
						$('#' + $(this).attr('date-aria-controls')).removeClass('active show');
						$('.js-folder-nav-wrap').fadeIn(100);
						$('.js-folder-nav-wrap').find('a[aria-controls=' + $(this).attr('date-aria-controls') + ']').removeClass('active');
						$('.js-mobile-idea-folder-header').find('.js-back-house-list').addClass('full-with-button');
						$('.js-mobile-idea-folder-header').find('.manage-folders').removeClass('active');
						$('.js-mobile-idea-folder-header').find('.mobile-idea-folder--details__content').removeClass('active'); // $('.js-mobile-idea-folder-header').find('.js-show-mobile-action-btn').fadeOut(100);
					}
				}); //show specification sheet

				$('.specification-sheet').on('click', function () {
					if ($(window).width() > 992) {
						$(this).parents('.js-saved-images-box').fadeOut(500);
						$(this).parents('.js-saved-images-box').siblings('.js-specification-sheet-box').fadeIn(500);
					}
				});
				$('.specification-sheet .folder-wrapper__saved-element--folders-button').on('click', function () {
					$(this).parents('.js-saved-images-box').fadeOut(10);
					$(this).parents('.js-saved-images-box').siblings('.js-specification-sheet-box').fadeIn(500);
				});
				$('.js-hide-specification-sheet-box-btn').on('click', function () {
					$(this).parents('.folder-wrapper').find('.js-saved-images-box').fadeIn(500);
					$(this).parents('.folder-wrapper').find('.js-specification-sheet-box').fadeOut(10);
					$(this).parents('.folder-wrapper').find('.js-add-to-rooms-new-idea-folder-images').fadeOut(10);
					$('html, body').animate({
						scrollTop: 0
					}, 800);
				});
				$('.js-show-specification-sheet-btn').on('click', function () {
					if ($(this).hasClass('clicked')) {
						$(this).removeClass('clicked');
						$(this).parents('.folder-wrapper').find('.js-saved-images-box').fadeIn(500);
						$(this).parents('.folder-wrapper').find('.js-specification-sheet-box').fadeOut(10);
						$(this).parents('.folder-wrapper').find('.js-add-to-rooms-new-idea-folder-images').fadeOut(10);
					} else {
						$(this).addClass('clicked');
						$(this).parents('.folder-wrapper').find('.js-saved-images-box').fadeOut(10);
						$(this).parents('.folder-wrapper').find('.js-specification-sheet-box').fadeIn(500);
						$(this).parents('.folder-wrapper').find('.js-add-to-rooms-new-idea-folder-images').fadeOut(10);
					}
				});
				$('.js-show-add-to-rooms-new-idea-folder-images-btn').on('click', function () {
					$(this).parents('.folder-wrapper').find('.js-saved-images-box').fadeOut(10);
					$(this).parents('.folder-wrapper').find('.js-add-to-rooms-new-idea-folder-images').fadeIn(500);
				});
				$('.js-hide-add-to-rooms-new-idea-folder-images-btn').on('click', function () {
					$(this).parents('.folder-wrapper').find('.js-saved-images-box').fadeIn(500);
					$(this).parents('.folder-wrapper').find('.js-specification-sheet-box').fadeOut(10);
					$(this).parents('.folder-wrapper').find('.js-add-to-rooms-new-idea-folder-images').fadeOut(10);
					$('html, body').animate({
						scrollTop: 0
					}, 800);
				});

				if ($('.js-desktop-active').length) {
					if ($(window).width() > 992) {
						$('.js-desktop-active').attr('aria-selected', 'true');
						$('.js-desktop-active').addClass('active');
						$($('.js-desktop-active').attr('href')).addClass('active show');
					}
				}

				$(window).on({
					load: function load() {
						if ($(window).width() < 992) {
							if ($('.js-desctop-file-position').length) {
								if ($('.js-desctop-file-position').find('.col-12').length) {
									$('.js-mobile-file-position').append($($('.js-desctop-file-position').find('.col-12')).detach());
								}
							}
						} else {
							if ($('.js-mobile-file-position').find('.col-12').length) {
								$('js-desctop-file-position').append($($('.js-mobile-file-position').find('.col-12')).detach());
							}
						}
					},
					resize: function resize() {
						if ($(window).width() < 992) {
							if ($('.js-desctop-file-position').length) {
								if ($('.js-desctop-file-position').find('.col-12').length) {
									$('.js-mobile-file-position').append($($('.js-desctop-file-position').find('.col-12')).detach());
								}
							}
						} else {
							if ($('.js-mobile-file-position').find('.col-12').length) {
								$('.js-desctop-file-position').append($($('.js-mobile-file-position').find('.col-12')).detach());
							}

							if ($('.js-desktop-active').length) {
								$('.js-desktop-active').attr('aria-selected', 'true');
								$('.js-desktop-active').addClass('active');
								$($('.js-desktop-active').attr('href')).addClass('active show');
							}
						}
					}
				}); //load confirm alert for checked checkbox

				$('.js-load-confirm-modal').on('click', function () {
					var modalId = $(this).attr('data-target');

					if ($(this).is(':checked')) {
						$(modalId).modal('show');
						$(modalId).find('.js-uncheck-checkbox-btn').attr('date-checkbox-id', '#' + $(this).attr('id'));
					}
				}); // uncheck checkbox if click NO

				$('.js-uncheck-checkbox-btn').on('click', function () {
					$($(this).attr('date-checkbox-id')).prop('checked', false);
				});
				$('.js-url-modal-btn').on('click', function () {
					var modalId = $(this).attr('data-target');
					$(modalId).find('.js-save-image-url-btr').attr('data-tab-parrent', $(this).attr('data-tab-parrent')).attr('data-button-positon', $(this).attr('data-button-positon'));
				});
				$('.js-add-new-url-field-btn').on('click', function () {
					var newField = '<div class="col-12 new-field-wrap js-new-url-field">' + '<div class="form-group mt-2">' + '<input type="text" class="form-control mt-2" name="image-url" placeholder="Paste URL here">' + '</div>' + '<button type="button" class="new-field-btn js-remove-new-url-field">' + '<svg xmlns="http://www.w3.org/2000/svg" width="14.932" height="16.033" viewBox="0 0 14.932 16.033"><defs><style>.trash-small{fill:#fb561b;}</style></defs><g transform="translate(0 0)"><g transform="translate(0 0)"><g transform="translate(0 0)"><path class="trash-small" d="M63.331,124.769a1.305,1.305,0,0,0,1.351,1.168h5.771a1.328,1.328,0,0,0,1.374-1.191l.939-9.8H62.186Z" transform="translate(-60.01 -109.905)"/><path class="trash-small" d="M27.028,2.061h-4.26V1.328A1.283,1.283,0,0,0,21.533,0H18.577a1.282,1.282,0,0,0-1.306,1.259q0,.035,0,.07v.733h-4.26a.458.458,0,0,0,0,.916H27.028a.458.458,0,1,0,0-.916Zm-5.176-.733v.733H18.188V1.328a.366.366,0,0,1,.389-.412h2.886a.366.366,0,0,1,.391.34A.362.362,0,0,1,21.852,1.328Z" transform="translate(-12.554 0)"/></g></g></g></svg>' + '</button>' + '</div>';
					$(this).parents('.js-add-new-field').before(newField); // $(this).hide();
				});
				$('.js-row-url-list').on('click', '.js-remove-new-url-field', function () {
					$(this).parents('.js-new-url-field').remove(); // $('.js-add-new-url-field-btn').css('display','flex');
				}); // upload new image

				$('.drop-input').on('change', function (event) {
					var files = event.target.files;
					var savedArea = $(this).parents('.new-field-wrap-table__footer').siblings('.new-field-wrap-table__body').find('.col-12');
					var newSize = files[0].size / 1000;

					if (newSize >= 1000) {
						newSize = (newSize / 1000).toFixed(2) + " MB";
					} else {
						newSize = newSize.toFixed(2) + " KB";
					}

					$(savedArea).append('<div class="row new-field-wrap-table__body--row">' + '<div class="col-5 new-field-wrap-table__body--file-name">' + '<input type="text" class="image-data" name="file-name[]" value="' + files[0].name + '">' + '<input type="text" class="image-data" name="file-size[]" value="' + files[0].size + '">' + '<input type="text" class="image-data" name="image-type[]" value="' + files[0].type + '">' + files[0].name + '</div>' + '<div class="col-4 new-field-wrap-table__body--file-size">' + newSize + '</div>' + '<div class="col-3 new-field-wrap-table__body--file-sucsess">' + '<img src="images/checked.svg" alt="" class="img-fluid">' + '</div>' + '<button class="new-field-wrap-table__body--delete js-delete-new-upload-img-btn">' + '<img src="images/trash-small.svg" alt="" class="img-fluid">' + '</button>' + '</div>'); // $(this).val('');
				});
				$('.new-field-wrap-table__body').on('click', '.js-delete-new-upload-img-btn', function () {
					$(this).parents('.new-field-wrap-table__body--row').remove();
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 36 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
			/* harmony import */
			var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);


			jQuery(document).ready(function ($) {
				// full mobile about us modals
				$('.modal-open').on('click', function () {
					var texts = $(this).closest('div').siblings('.js-show-text').html().split('<br><br>');
					var modalId = $(this).attr('data-target');
					var imgs = $(this).attr('data-img-path');

					if (texts.length > 1) {
						if (imgs) {
							if (imgs.split(';').length > 1) {
								var splitImgs = imgs.split(';'); // if separated text is equal to separated images

								if (texts.length === splitImgs.length) {
									for (var i = 0; i < texts.length; i++) {
										$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p><img src="' + splitImgs[i] + '" alt="" class="about-us-modal__image img-fluid"/>');
									}
								} // if separated text is bigger to separated images


								if (texts.length > splitImgs.length) {
									for (var i = 0; i < texts.length; i++) {
										if (splitImgs[i] !== undefined && splitImgs[i] !== "") {
											$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p><img src="' + splitImgs[i] + '" alt="" class="about-us-modal__image img-fluid"/>');
										} else {
											$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p>');
										}
									}
								} // if separated text is smaller to separated images


								if (texts.length < splitImgs.length) {
									for (var i = 0; i < splitImgs.length; i++) {
										if (texts[i] !== undefined && texts[i] !== "") {
											$(modalId).find('.modal-body').append('<img src="' + splitImgs[i] + '" alt="" class="about-us-modal__image img-fluid"/><p class="about-us-modal__text">' + texts[i] + '</p>');
										} else {
											$(modalId).find('.modal-body').append('<img src="' + splitImgs[i] + '" alt="" class="about-us-modal__image img-fluid"/>');
										}
									}
								}
							} // if we have only on imaga
							else {
								for (var i = 0; i < texts.length; i++) {
									if (i === 0) {
										$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p><img src="' + imgs + '" alt="" class="about-us-modal__image img-fluid"/>');
									} else {
										$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p>');
									}
								}
							}
						} // without images
						else {
							for (var i = 0; i < texts.length; i++) {
								$(modalId).find('.modal-body').append('<p class="about-us-modal__text">' + texts[i] + '</p>');
							}
						}
					}
				}); //open mobile team gallery

				$('#js-team-galery-btn').on('click', function (e) {
					e.preventDefault();
					var modalId = $(this).attr('data-target'),
						cloneTeam = $('#js-team-galery').clone(),
						cloneTeamFirstText = $('.js-team-galery-first-test').clone(),
						cloneTeamSecondText = $('.js-team-galery-second-test').clone();
					$(modalId).find('.modal-body').append(cloneTeam).append(cloneTeamFirstText).append(cloneTeamSecondText);
					$(modalId).find('.modal-body').find('.desktop-show').removeClass('desktop-show');
					$(modalId).find('.js-team-galery-second-test').css('background', '#ffffff');
					$(modalId).find('.modal-body').find('.simple-block__border').addClass('p-0');
				}); //open mobile timeline

				$('#js-mobile-time-line-btn').on('click', function (e) {
					e.preventDefault();
					var modalId = $(this).attr('data-target');
					var cloneTimeLine = $('#js-show-mobile-time-line').clone();
					$(modalId).find('.modal-body').append(cloneTimeLine);
					$(modalId).find('.mobile-content').removeClass('mobile-content');
					$(modalId).find('.mobile-small-text').removeClass('mobile-small-text');
					$(modalId).find('.js-remove-for-modal').remove();
				}); //open mobile catalog

				$('.js-show-mobile-catalog-btn').on('click', function (e) {
					e.preventDefault();
					var modalId = $(this).attr('data-target'),
						mobileCatalogContent = $('#js-show-mobile-catalog').clone();
					$(modalId).find('.modal-body').append(mobileCatalogContent);
				}); //clear mobile modals

				$('.about-us-modal-close').on('click', function (e) {
					e.preventDefault();
					$(this).parent().siblings('.modal-body').empty();
				});
				$('body').on('click', function () {
					$(this).find('.custom-fixed-modal').removeClass('active');
					$(this).find('.four-elements-block__wrapper--image img').removeClass('bordered-img');
				});
				$('body').on('click', '.custom-fixed-modal', function (event) {
					event.stopPropagation();
				}); //open custom fixed element for more inforamtion about the employee

				$('body').on('click', '.js-open-custom-modal', function (event) {
					event.stopPropagation();
					var elem = $(this).attr('data-custom-modal-id');
					$(this).parents('#js-team-galery').find('.four-elements-block__wrapper--img').removeClass('bordered-img');
					$(this).parents('figure.four-elements-block__wrapper').find('.four-elements-block__wrapper--img').addClass('bordered-img');
					$(elem).addClass('active');
					$(elem).find('.js-hide-custom-fixed-modal').attr('data-employee-ID', $(this).attr('data-employee-ID'));
				}); // close custom fixed element for more inforamtion about the employee

				$('.js-hide-custom-fixed-modal').on('click', function () {
					var elem = $(this).attr('data-custom-modal-id'),
						btn = $('button.js-open-custom-modal[data-employee-ID="' + $(this).attr('data-employee-ID') + '"]');
					$(btn).siblings('img').removeClass('bordered-img');
					$(elem).removeClass('active');
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 37 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				if ($(window).width() < 992) {
					if ($('#shoppingCardTitle').length) {
						var shoppingCardTitle = $('#shoppingCardTitle').detach();
						$(".mobile__append-shoppingCardTitle").append(shoppingCardTitle);
					}
				}
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 38 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var minus = $('.card-checkout__product__label__buttons .minus');
				var plus = $('.card-checkout__product__label__buttons .plus');
				minus.click(function () {
					var $input = $(this).parent().find('input');
					var count = parseInt($input.val()) - 1;
					count = count < 1 ? 1 : count;
					$input.val(count);
					$input.change();
					return false;
				});
				plus.click(function () {
					var $input = $(this).parent().find('input');
					$input.val(parseInt($input.val()) + 1);
					$input.change();
					return false;
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 39 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {// var btnAddAddress = $('#modal__add-address');
				//
				// if ($(window).width() <= 992){
				// 	btnAddAddress
				// 		.removeClass('form__add-new-address cd-none')
				// 		.addClass('modal fade')
				// 		.removeAttr('data-role')
				// 		.attr( "role", "dialog" )
				// 		.attr( "aria-labelledby", "exampleModalLabel" )
				// 		.attr( "aria-hidden", "true" )
				// 		.attr( "tabindex", "-1" )
				// } else if ($(window).width() > 992) {
				// 	btnAddAddress
				// 		.removeClass('modal fade')
				// 		.addClass('form__add-new-address cd-none')
				// 		.removeAttr('role')
				// 		.removeAttr('aria-labelledby')
				// 		.removeAttr('aria-hidden')
				// 		.removeAttr('tabindex')
				// 		.attr( "data-role", "toggle-el-target" )
				// }
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 40 */
	/***/ (function (module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */
		(function (jQuery) {
			jQuery(document).ready(function ($) {
				var signInfoTextCustomCollapse = $('.info-text-custom-collapse');
				var modalSignInfoTextCustomCollapseBtn = $('[data-role="btn-info-text-custom-collapse"]');

				function customCollapseInit() {
					var wid = $(window).width();

					if (wid < 1025) {
						$(modalSignInfoTextCustomCollapseBtn).off('click').on('click', function (event) {
							if (!$(this).siblings(signInfoTextCustomCollapse).hasClass('active')) {
								$(this).siblings(signInfoTextCustomCollapse).addClass('active');
								$(this).text('Close');
							} else {
								$(this).siblings(signInfoTextCustomCollapse).removeClass('active');
								$(this).text('Read all');
							}
						});
					}
				}

				customCollapseInit();
				$(window).on("resize", function () {
					customCollapseInit();
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 41 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
			/* harmony import */
			var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);


			jQuery(document).ready(function ($) {
				var diyTabContent = $('.js-mobile-tab-container');

				if ($(diyTabContent).length) {
					if ($(window).width() < 992) {
						$(diyTabContent).find('.tab-block__wrapper').removeClass('open');
					}
				} // click and check mobile diy header menu


				$('.js-mobile-tab-btn').on('click', function () {
					$(this).siblings('.js-mobile-tab-btn').removeClass('active');
					$(this).addClass('active');
					$('.js-uncheck-diy-header-btn').removeClass('not-active');
					$('.js-mobile-tab-text-img').fadeOut();
					$($(this).attr('data-id')).siblings('.tab-block__wrapper').removeClass('open');
					$($(this).attr('data-id')).addClass('open');
					$('html, body').animate({
						scrollTop: 0
					}, 800);
					var mainContainer,
						navContainer,
						buttonPrev,
						buttonNext,
						elemWidth = 0;
					mainContainer = document.querySelector($(this).attr('data-id'));
					navContainer = mainContainer.getElementsByClassName('tab-block__wrapper--image-content');
					buttonPrev = mainContainer.getElementsByClassName('tab-block__wrapper--image-wrap__prev');
					buttonNext = mainContainer.getElementsByClassName('tab-block__wrapper--image-wrap__next');
					var navContainerChild = navContainer[0].children; // for margin-right: 16px
					// I sum all childrens with 16px without the last

					elemWidth += (navContainerChild.length - 1) * 16;

					for (var i = 0; i < navContainerChild.length; i++) {
						elemWidth += navContainerChild[i].offsetWidth;
					}

					Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* mobilePredNextButtons */ "c"])($(navContainer[0]), $(buttonPrev[0]), $(buttonNext[0]), elemWidth);
				}); // desktop tab navigation

				if ($('.tab-block__buttons-content').length >= 1) {
					Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* desctopPredNextButtons */ "b"])($('.tab-block__buttons-content'), $('.tab-block__buttons-content').siblings('.tab-block__buttons-prev'), $('.tab-block__buttons-content').siblings('.tab-block__buttons-next'));
				} // tab buttons


				$('.tab-block__buttons-content .tab-block__buttons-content--button').on('click', function () {
					var tabAttr = $(this).attr("data-id");
					$("#" + tabAttr).siblings('.tab-block__wrapper').each(function () {
						$(this).removeClass('open');

						if ($(this).find('.caro-wrap').length >= 1) {
							$(this).find('.caro-wrap').removeClass('active');
						}
					});
					$(this).siblings('.tab-block__buttons-content--button').each(function () {
						$(this).removeClass('active');
					});
					$(this).addClass('active');
					$("#" + tabAttr).addClass('open');

					if ($("#" + tabAttr).find('.caro-wrap').length >= 1) {
						$("#" + tabAttr).find('.caro-wrap').addClass('active');
						var arr = new Array();
						$("#" + tabAttr).find('.caro-wrap').children().each(function () {
							arr.push($(this).attr('id'));
						});

						if (arr.length > 0 && arr.length <= 2) {
							var carousel = ("#" + arr[0]).toString(),
								carouselNav = ("#" + arr[1]).toString();
							carouselById(carousel, carouselNav, false);
						}
					}
				}); // uncheck and click mobile diy header menu

				$('.js-uncheck-diy-header-btn').on('click', function () {
					$(this).addClass('not-active');
					$('.js-mobile-tab-btn').removeClass('active');
					$('.js-mobile-tab-text-img').fadeIn();
					$('.js-mobile-tab-container').find('.tab-block__wrapper').removeClass('open');
				}); // open mobile modal with detach element

				$('.js-modal-diy-btn').on('click', function () {
					var modalId = $(this).attr('data-target'),
						detachedArea = $($(this).attr('data-area-id')).find('.js-diy-detached-div');
					$(modalId).find('.modal-title').text($(this).html());
					$(modalId).find('.js-close-diy-modal-btn').attr('data-area-id', $(this).attr('data-area-id'));
					$(modalId).find('.modal-body').empty().append($(detachedArea).detach());
				}); // close mobile modal with return detached element

				$('.js-close-diy-modal-btn').on('click', function () {
					var detachedArea = $(this).parents('.modal-header').siblings('.modal-body').find('.js-diy-detached-div');
					$($(this).attr('data-area-id')).append($(detachedArea).detach());
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 42 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
			/* harmony import */
			var _functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);

			function _typeof(obj) {
				"@babel/helpers - typeof";
				if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
					_typeof = function _typeof(obj) {
						return typeof obj;
					};
				} else {
					_typeof = function _typeof(obj) {
						return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
					};
				}
				return _typeof(obj);
			}


			jQuery(document).ready(function ($) {
				//swich carosels
				if ($('.js-switch-carosel-mobile-wrap').length >= 1) {
					if ($(window).width() >= 992) {
						if ($('.js-switch-carosel-mobile').has('showroom-detail-product__carousel')) {
							Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* carouselById */ "a"])('.showroom-detail-product__carousel', '.showroom-detail-product__carousel-nav', false);
						} else {
							$('.js-switch-carosel-mobile').removeClass('video-caro').addClass('showroom-detail-product__carousel');
							Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* carouselById */ "a"])('.showroom-detail-product__carousel', '.showroom-detail-product__carousel-nav', false);
						}
					} else {
						if ($('.js-switch-carosel-mobile').has('showroom-detail-product__carousel')) {
							$('.js-switch-carosel-mobile').removeClass('showroom-detail-product__carousel').addClass('video-caro');
						}
					}
				} //get menu top position


				var productNavTopPosition = 0;
				var productTabPaneTopPosition = 0;

				if ($('.product-nav').length >= 1) {
					setTimeout(function () {
						// productNavTopPosition = $('.product-nav-wrap__content').offset().top;
						productNavTopPosition = $(".product-nav")[0].getBoundingClientRect().top;
						productTabPaneTopPosition = Math.round($($('.product-nav__link').attr('href')).offset().top);
					}, 200);
				}

				$(window).on({
					resize: function resize() {
						if ($('.product-nav').length >= 1) {
							setTimeout(function () {
								// productNavTopPosition = $('.product-nav-wrap__content').offset().top;
								productNavTopPosition = $(".product-nav")[0].getBoundingClientRect().top;
								productTabPaneTopPosition = Math.round($($('.product-nav__link').attr('href')).offset().top);
							}, 200);
						}

						if ($(window).width() >= 992) {
							if ($('.js-switch-carosel-mobile').has('showroom-detail-product__carousel')) {
								Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* carouselById */ "a"])('.showroom-detail-product__carousel', '.showroom-detail-product__carousel-nav', false);
							} else {
								$('.js-switch-carosel-mobile').removeClass('video-caro').addClass('showroom-detail-product__carousel');
								Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* carouselById */ "a"])('.showroom-detail-product__carousel', '.showroom-detail-product__carousel-nav', false);
							}
						} else {
							if ($('.js-switch-carosel-mobile').has('showroom-detail-product__carousel')) {
								$('.js-switch-carosel-mobile').removeClass('showroom-detail-product__carousel').addClass('video-caro');
							}
						}
					},
					scroll: function scroll() {
						var scroll = $(window).scrollTop();

						if ($(window).width() <= 992) {
							// console.log(productNavTopPosition);
							if (Math.round(scroll) >= Math.round(productNavTopPosition)) {
								$('.product-nav-wrap').addClass('fixed-nav');
							} else {
								$('.product-nav-wrap').removeClass('fixed-nav');
							}
						}
					}
				}); // mobile menu

				var $productNav = $('.product-nav');

				if ($productNav.length === 1) {
					var elemWidth = 0;
					$($productNav).find('.nav-item').each(function () {
						elemWidth += $(this).width();
					});
					Object(_functions__WEBPACK_IMPORTED_MODULE_1__[/* mobilePredNextButtons */ "c"])($('.product-nav'), $('.product-nav-wrap__prev'), $('.product-nav-wrap__next'), Math.round(elemWidth));
				}

				$('.js-show-hiden-options').on('click', function () {
					if ($(window).width() <= 992) {
						$(this).siblings('.tab-content__options--content').toggle(500);
					}
				});
				$('.tab-content__specifications--subheading').on('click', function () {
					if ($(this).hasClass('toggled')) {
						$(this).removeClass('toggled');
						$(this).find('.tab-content__specifications--subheading-icon-plus').fadeOut(100);
						$(this).find('.tab-content__specifications--subheading-icon-minus').fadeIn(100);
					} else {
						$(this).addClass('toggled');
						$(this).find('.tab-content__specifications--subheading-icon-plus').fadeIn(100);
						$(this).find('.tab-content__specifications--subheading-icon-minus').fadeOut(100);
					}

					$(this).parents('.js-specifications-subheading').siblings('.col-12').toggle(100);
				});
				$('.js-open-specifications-tab-btn').on('click', function () {
					$(this).siblings().removeClass('active');

					if ($(this).hasClass('active')) {
						$($(this).attr('data-open-description')).addClass('active').siblings().removeClass('active');
					} else {
						$(this).addClass('active');
						$($(this).attr('data-open-description')).addClass('active').siblings().removeClass('active');
					}
				});

				if ($('.showroom-detail-product-nav .nav-link').length >= 1) {
					var activeNavLinkAttr = $('.showroom-detail-product-nav .nav-link.active');

					if (_typeof($(activeNavLinkAttr).attr('data-more-information')) !== (true ? "undefined" : undefined) && $(activeNavLinkAttr).attr('data-more-information') !== false) {
						$($(activeNavLinkAttr).attr('data-more-information')).addClass('active');
						$($(activeNavLinkAttr).attr('data-more-information')).siblings('.showroom-detail-product__more-informations').removeClass('active');
					} else {
						$('.showroom-detail-product__more-informations').removeClass('active');
					}
				}

				$('.showroom-detail-product-nav .nav-link').on('click', function () {
					if (_typeof($(this).attr('data-more-information')) !== (true ? "undefined" : undefined) && $(this).attr('data-more-information') !== false) {
						$($(this).attr('data-more-information')).addClass('active');
						$($(this).attr('data-more-information')).siblings('.showroom-detail-product__more-informations').removeClass('active');
					} else {
						$('.showroom-detail-product__more-informations').removeClass('active');
					}
				});
				$('.js-show-hiden-installations-btn').on('click', function () {
					if ($(window).width() <= 992) {
						$(this).parents('.product-dyi-installer').siblings('.product-dyi-installer').find('.js-show-hiden-installations').fadeOut();
						$(this).parents('.product-dyi-installer').find('.js-show-hiden-installations').toggle(300);
						$('html, body').animate({
							scrollTop: $('.js-acordeon-scroll-position').offset().top - 200
						}, 800);
					}
				});
				$('.js-filter-fix-body').on('click', function () {
					if ($(window).width() <= 992) {
						$('body').toggleClass('modal-open_custom');

						if ($('header').hasClass('nav-down')) {
							$('header').toggleClass('nav-up');
						}
					}
				});
				$('.js-clear-filter').on('click', function () {
					$(this).parents('.js-filters-box').find('.js-defaulf-state').each(function () {
						if (!$(this).hasClass('selected')) {
							$(this).addClass('selected').siblings().removeClass('selected');
							$(this).parents('.my-custom-select').find('.my-custom-select__trigger span').text($(this).text());
						}
					});
					$(this).parents('.js-filters-box').find('input[type=text]').val('');
				});

				function iOS() {
					return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection
						|| navigator.userAgent.includes("Mac") && "ontouchend" in document;
				}

				iOS();
				$('.product-nav__link').on('click', function () {
					if ($(window).width() <= 992) {
						if (iOS()) {
							// window.scrollTop(productNavTopPosition - 150);
							$('html, body', parent.document).animate({
								scrollTop: productTabPaneTopPosition - productTabPaneTopPosition / 2
							}, 800);
						} else {
							$('html, body').animate({
								scrollTop: productTabPaneTopPosition - productTabPaneTopPosition / 2
							}, 800);
						}
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 43 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

			jQuery(document).ready(function ($) {
				if ($(window).width() < 992) {
					if ($('.js-mobile-removed-area').length >= 1 && !$('.js-mobile-removed-area').hasClass('detached')) {
						$('.js-desktop-removed-area').empty().append($('.js-mobile-removed-area').find('.wrapper').detach());
						$('.js-mobile-removed-area').addClass('detached');
					}
				}

				$(window).on({
					resize: function resize() {
						if ($(window).width() < 992) {
							if ($('.js-mobile-removed-area').length >= 1 && !$('.js-mobile-removed-area').hasClass('detached')) {
								$('.js-desktop-removed-area').empty().append($('.js-mobile-removed-area').find('.wrapper').detach());
								$('.js-mobile-removed-area').addClass('detached');
								$('.js-desktop-removed-area').removeClass('detached');
							}
						} else {
							if ($('.js-desktop-removed-area').length >= 1 && !$('.js-desktop-removed-area').hasClass('detached')) {
								$('.js-mobile-removed-area').empty().append($('.js-desktop-removed-area').find('.wrapper').detach());
								$('.js-desktop-removed-area').addClass('detached');
								$('.js-mobile-removed-area').removeClass('detached');
							}
						}
					}
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	}),
	/* 44 */
	/***/ (function (module, __webpack_exports__, __webpack_require__) {

		"use strict";
		/* WEBPACK VAR INJECTION */
		(function (jQuery) {/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
			/* harmony import */
			var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

			jQuery(document).ready(function ($) {
				// open first part of free in home consult form
				$('#js-mobile-first-home-consult-form-btn').on('click', function () {
					var modalId = $(this).attr('data-target'); //add heading

					$(modalId).find('h5#mobile-first-home-consult-form-title .js-heading').empty().append($('#js-mobile-first-home-consult-form').find('h4.home-consult-form__heading').text()); //add form

					$(modalId).find('.modal-body').empty().append($('#js-mobile-first-home-consult-form').clone());

					if (!$('body').hasClass('modal-open')) {
						$('body').addClass('modal-open_custom');
					}
				});
				$('#js-mobile-modal-first-home-consult-form-btn').on('click', function () {
					var modalId = $(this).attr('data-target'); //add heading

					$(modalId).find('h5#mobile-first-home-consult-form-title .js-heading').empty().append($('#js-mobile-first-home-consult-form').find('h4.home-consult-form__heading').text()); //add form

					$(modalId).find('.modal-body').empty().append($('#js-mobile-first-home-consult-form').clone());

					if (!$('body').hasClass('modal-open')) {
						$('body').addClass('modal-open_custom');
					}
				}); // open second part of free in home consult form

				$('#js-mobile-second-home-consult-form-btn').on('click', function () {
					var modalId = $(this).attr('data-target'); //add heading

					$(modalId).find('h5#mobile-second-home-consult-form-title .js-heading').empty().append($('#js-mobile-second-home-consult-form').find('h4.home-consult-form__heading').not('.bordered-heading').text());
					$(modalId).find('.modal-body').empty().append($('#js-mobile-second-home-consult-form').clone());
					$('body').addClass('modal-open_custom');
				});
				$('#js-mobile-modal-second-home-consult-form-btn').on('click', function () {
					var modalId = $(this).attr('data-target'); //add heading

					$(modalId).find('h5#mobile-second-home-consult-form-title .js-heading').empty().append($('#js-mobile-second-home-consult-form').find('h4.home-consult-form__heading').not('.bordered-heading').text());
					$(modalId).find('.modal-body form').empty().append($('#js-mobile-second-home-consult-form').clone());
					$('body').addClass('modal-open_custom');
				}); // open third part of free in home consult form

				$('#js-mobile-third-home-consult-form-btn').on('click', function () {
					var modalId = $(this).attr('data-target'); //add heading

					$(modalId).find('h5#mobile-third-home-consult-form-title .js-heading').empty().append($('#js-mobile-third-home-consult-form').find('h4.home-consult-form__heading').not('.bordered-heading').text());
					$(modalId).find('.modal-body').empty().append($('#js-mobile-third-home-consult-form').clone());
					$('body').addClass('modal-open_custom');
				});
				$('#js-mobile-home-consult-form-submit-btn').on('click', function (e) {
					e.preventDefault();
					$('.modal-title').find('.js-heading').empty();
					$('.modal-body').empty();
					$('body').removeClass('modal-open_custom');
				});

				function scrollFormToCenter() {
					setTimeout(function () {
						document.getElementById('home-consult-form').scrollIntoView({
							behavior: 'smooth',
							block: "center"
						});
					}, 700);
				} // close free in home consult form


				$('.free-in-home-consults-modal-close').on('click', function (e) {
					e.preventDefault();
					$('.modal-title').find('.js-heading').empty();
					$('.modal-body form').empty();
					$('body').removeClass('modal-open_custom');
				}); //show the first part of desktop form

				$('#js-desktop-first-home-consult-form-btn').on('click', function () {
					$(this).closest('.js-open-form').fadeOut(300);
					$('.home-consult-form').addClass('active');
					$('.home-consult-form').find('.first-content').addClass('opened active').fadeIn(500);
					$('#js-desktop-first-home-consult-nav-btn').removeAttr('disabled').addClass('visited active');
					scrollFormToCenter();
				});
				$('#js-desktop-first-home-consult-nav-btn').on('click', function () {
					$(this).closest('.home-consult-form__wrapper').find('.first-content').addClass('opened active').fadeIn(500).siblings('.home-consult-form__content').removeClass('opened active').fadeOut(300);
					$(this).addClass('active').siblings('button').removeClass('visited active').attr('disabled', 'disabled');
				}); // show the second part of desktop form

				$('#js-desktop-second-home-consult-form-btn').on('click', function () {
					$(this).closest('.first-content').removeClass('active').fadeOut(300);
					$(this).closest('.third-content').siblings('.home-consult-form__content').removeClass('active').fadeOut(300);
					$(this).closest('.first-content').siblings('.second-content').addClass('opened active').fadeIn(500);
					$('#js-desktop-second-home-consult-nav-btn').removeAttr('disabled').addClass('visited active').siblings('button').removeClass('active');
					scrollFormToCenter();
				});
				$('#js-desktop-second-home-consult-nav-btn').on('click', function () {
					$(this).closest('.home-consult-form__wrapper').find('.second-content').addClass('opened active').fadeIn(500).siblings('.home-consult-form__content').fadeOut(300);
					$(this).addClass('active').siblings('#js-desktop-third-home-consult-nav-btn').removeClass('visited active').attr('disabled', 'disabled');
				}); //show the third part of desktop form

				$('#js-desktop-third-home-consult-form-btn').on('click', function () {
					$(this).closest('.second-content').removeClass('active').fadeOut(300);
					$(this).closest('.third-content').siblings('.home-consult-form__content').removeClass('active').fadeOut(300);
					$(this).closest('.second-content').siblings('.third-content').addClass('opened active').fadeIn(500);
					$('#js-desktop-third-home-consult-nav-btn').removeAttr('disabled').addClass('visited active').siblings('button').removeClass('active');
					scrollFormToCenter();
				}); // last form button

				$('#js-desktop-last-home-consult-form-btn').on('click', function () {
					$(this).closest('.third-content').removeClass('opened active').fadeOut(300);
					$(this).closest('.third-content').siblings('.home-consult-form__content').removeClass('active').removeClass('opened').fadeOut(300);
					$(this).parents('.home-consult-form').find('.home-consult-form__nav--button').removeClass('visited active').attr('disabled', 'disabled');
					$(this).parents('.home-consult-form').removeClass('active');
					$('.js-open-form').fadeIn(500);
				});
			});
			/* WEBPACK VAR INJECTION */
		}.call(this, __webpack_require__(0)))

		/***/
	})
	/******/]);
